import java.util.Vector;
import java.util.Collections;

public class Chobo1{
	
	public static final String[] colors = {"지미","라면","차호루","니미","닝기리","후라이"};
	
	public static void main(String[] args){
		
		Vector<String> vt = new Vector<>();
		
		
		for (String color : colors)
		{
			vt.add(color);
		}
		
		//Collections.sort(vt);											// 컬렉션 클래스를 이용한 정렬
		Collections.sort(vt, Collections.reverseOrder());				// 컬렉션 클래스 메소드중 리버스 오더를 사용한 내림정렬
		
		
		int num = Collections.binarySearch(vt, "후라이",Collections.reverseOrder());
		System.out.printf("%d 번째에 지미가 있음.",num);
		System.out.println();
		
		
		for (String str : vt)
		{
			System.out.println(str);
		}
		
	}
}/*====================================
  ■■■ 클래스와 인스턴스 ■■■
====================================*/

// ※ Test075.java 파일과 세트!

// Test074.java		→ Test074.class
//					→ Rect.class

// Test075.java		→ Test075.class
// CircleTest.java	→ CircleTest.java

// 원의 넓이와 둘레 구하기
// 원의 넓이와 둘레를 구할 수 있는 클래스를 설계한다.
// (클래스명 : CircleTest)
// Test074.java 파일을 참조하여 설계할 수 있도록 한다.
// 데이터 입력은 BufferedReader 의 readLine() 활용

// 실행 예)
// 반지름 입력 : xxx

//>> 반지름이 xxx인 원의
//>> 넓이 : xxxx.xx
//>> 둘레 : xxxx.xx
// 계속하려면 아무 키나 누르세요...

// ※ 원의 넓이 = 반지름 * 반지름 * 3.141592
//	  원의 둘레 = 반지름 * 2 * 3.141592

// package default; 생략된것

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;


public class CircleTest  
{
	/*
	// 생성자 → 사용자 정의 생성자
	CircleTest()
	{
    }
	*/
	
	// default 생성자 → 자동 생성
	/*
	CircleTest()
	{
		// 텅 비어있음
	}
	*/
	
	// 주요 속성 (데이터)		→ 멤버 변수
	int r;						//-- 반지름
	final double PI = 3.141592;	//-- 원주율(변수의 상수화)
	
	
	// 주요 기능 (동작, 행위)	→ 멤버 메소드 
	// 반지름 입력 → 메소드 정의
	void input() throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("반지름 입력 : ");
		r = Integer.parseInt(br.readLine());
	}
	
	// 넓이 계산 기능			→ 메소드 정의
	double calArea()
	{
		// 원의 넓이 = 반지름 * 반지름 * 3.141592;
		return r * r * PI;
	}
	
	// 둘레 계산 기능			→ 메소드 정의
	double calLength()
	{
		// 원의 둘레 = 반지름 * 2 * 3.141592;
		double result = 0;
		
		result = r * 2 * PI;
		
		return result;
	}
	
	
	// 결과 출력 기능			→ 메소드 정의
	void print(double a, double l)
	{
		/*
		//>> 반지름이 xxx인 원의
		//>> 넓이 : xxxx.xx
		//>> 둘레 : xxxx.xx
		// 계속하려면 아무 키나 누르세요...
		*/
		
		System.out.printf("\n>> 반지름이 %d 인 원의\n",r);
		System.out.printf(">> 넓이 : %.2f\n",a);
		System.out.printf(">> 둘레 : %.2f\n",l);
	}
	
	
	
	/* 나의 풀이
	double r;
	final double PI = 3.141592; 
		
	void input() throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("반지름 입력 : ");
		
		r = (double)Integer.parseInt(br.readLine());

	}
	
	double calArea()
	{
		double result = 0;
		
		result = r * r * PI;
		
		return result;
	}
	
	double calLength()
	{
		double result = 0;
		
		result = r * 2 * PI;
		
		return result;
	}
	
	void print(double a, double l)
	{
		System.out.printf(">> 반지름이 %.2f 인 원의\n",r);
		System.out.printf(">> 넓이 : %.2f\n",a);
		System.out.printf(">> 둘레 : %.2f\n",l);
	}
	*/
}public class Class1
{
	public class Student
	{
		String name;
		int age;
		int grade;
	}
}package class1;

public class ClassStart3
{
	public static void main(String[] args){
		Student student1;
		student1 = new Student();
		student1.name = "학생1";
		student1.age = 15;
		student1.grade = 90;
		
		Student student2 = new Student();
		student2.name = "학생2";
		student2.age = 16;
		student2.grade = 80;
		
		System.out.println("이름 : " + student1.name + " 나이:" + student1.age + "성적:" + student1.grade);
		System.out.println("이름 : " + student2.name + " 나이:" + student2.age + "성적:" + student2.grade);
		
		
	}
}public class InfRecul
{
	public static void main(String[] args)
	{
		showHi(3);
	}
	
	public static void showHi(int cnt)	// 5
	{
		/*
		System.out.println("Hi~");
		showHi(cnt--);					// showHi(5);	showHi(5);	showHi(5);
		if (cnt==1)
		{
			return;
		}
		*/
		
		/*
		System.out.println("Hi~");
		showHi(--cnt);					// showHi(4);	showHi(3);	showHi(2);	showHi(1);	showHi(0);	showHi(-1);			
		if (cnt==1)						
		{
			return;
		}
		*/
		
		System.out.println("Hi~");								
		if (cnt==1)						
		{
			return;
		}
		showHi(--cnt);
	}	
}/*========================================================
 ■■■ 클래스와 인스턴스 ■■■
 - 클래스와 인스턴스 활용
=========================================================*/

// 학생별로 국어점수, 영어점수, 수학점수를 입력받아
// 총점 평균을 계산하는 프로그램을 구현한다.
// 단, 클래스의 개념을 활용하여 작성할 수 있도록한다.
// 또한 이과정에서 배열을 적극적으로 활용할 수 있도록한다.
// 클래스의 설계는 다음의 가이드 라인에 따라 진행할 수 있도록한다.

// [가이드라인]
// 프로그램을 구성하는 클래스
// 1. Record 클래스
//		- 속성만 존재하는 클래스로 설계할 것!!-----------------	check

// 2. Sungjuk 클래스
//		- 인원수를 입력받아, 입력받은 인원수 만큼
//		  이름, 국어점수, 영어점수, 수학점수를 입력받고
//		  총점과 평균을 산출하는 클래스로 설계할 것!!
//		  속성: 인원 수, Record 타입의 배열  ------------------	check
//		  기능: 인원 수 입력, 상세 데이터 입력, 총점 및 평균 연산, 결과 출력

// 3. Test105 클래스
//	    - main() 메소드가 존재하는 외부 클래스로 설계 할 것 !!

// 실행 예)
// 인원 수 입력(1~100) : 102
// 인원 수 입력(1~100) : -20
// 인원 수 입력(1~100) : 3

// 1번째 학생의 이름 입력 : xxx
// 국어 점수 : 90
// 영어 점수 : 80
// 수학 점수 : 70
// 2번째 학생의 이름 입력 : xxx
// 국어 점수 : 92
// 영어 점수 : 82
// 수학 점수 : 72
// 3번째 학생의 이름 입력 : xxx
// 국어 점수 : 82
// 영어 점수 : 72
// 수학 점수 : 62

// xxx 90 80 70	  240  xx.xx	2
// xxx 92 82 72	  xxx  xx.xx	1
// xxx 82 72 62	  xxx  xx.xx	3
// 계속하려면 아무 키나 누르세요...

// 학생 1명
public class Record
{
	// 학생 한 명을 표현할 수 있는 속성들로 구성...		check!!
	
	// String[] names;
	// int[] korScore;
	
	String name;				//-- 이름
	int[] score = new int[3];   //int kor, eng, mat;		//-- 국어점수, 영어점수, 수학점수
								// score[0] → 국어점수(kor)
								// score[1] → 영어점수(eng)
								// score[2] → 수학점수(mat)
								
	int tot;					//-- 총점
	double avg;					//-- 평균
	
	// 추가
	int rank;					//-- 석차
	
	
	/* 나의 풀이
	int nKor; 
	int nEng;
	int nMat;
	int nTot;
	double dAvg;
	String sName;
	*/
}/*
변수, 입출력, 객체직렬화(파일 저장 및 내보내기), 컬렉션(list(vector, arraylist, linkedlist), 
set(중복없이 구술주머니, 순서노상관, 트리셋(오름차순)), 
map(key value), stack(먼저들어간놈이 나중에 나온다), queue(선입선출), 이터레이터, 이누머레이션, ListIterator)
배열, 캘린더, 이중배열, 난수 생성, 문자열 비교, 예외처리(try catch), 반복문, 박싱 언박싱, 조건문
클래스 중첩(4가지),오버로딩, 오버라이딩, 상속, 추상메소드, 인터페이스 ,부모, 깊은 복사 얕은복사
static, 패키지, 생성자 , 초기화 블럭, 정렬(2가지,선택정렬, 버블정렬, 향상된 버블정렬), 향상된 for문
제네릭 표현식, 업캐스팅, 다운캐스팅
-------------------------------------------------------------------------------------------------------------------------------
*/

interface 식료품 유통기한 정리			// 
{
   1.비교 매서드 유통기한을 비교하고
   2.오름차순으로 정리를 해주는 추상메소드를 만들고
}


class 식료품 정리 implements 식료품 유통기한 정리
{
	1.  식료품 유통기한 정리 재정의
	2.  칼로리로 비교 정리
	3.  식료품 유통기한 정리를 통해서 선입선출 선택 
		
	// 사용자가 입력한 유통기한을 오름차순으로 정리하는 양식 구현 >> 스레드 동기화를 사용한 Vector로 구성할 가능성이 높음 / Collections.sort 을 사용하여 정렬(유통기한 순???)
	// 사용자 정보에서 칼로리 / 기타사항 / 불호 참조하여 기초대사량에 의거한 칼로리 분석 후 식단을 추천하는 로직 생성
	// --==>> 사용자정보에서 비교를 어떻게할것인지 생각 >> 기타사항 과 식료품과 매치되면 제외가 되는 조건문 필요 >> 지금있는 식료품의 칼로리의 합과 기초대사량에 의거한 식단의 합이 일치하도록 정리
	// 식료품 정보에서 어떻게 정보를 받아올지 생각. >> 객체 직렬화를 통해서 식품 불러들이기 >> 컬렉션을 통해 사용자 정보 받아오기
	
	
}



 
class 냉장고 extends 식료품 칼로리 정리					// 각자 만들어 오기
{
    1. 냉장고 기능은 유통기한으로 식료품을 정리해주는 메소드 재정의
    2. 칼로리 정보, 갯수 정보 -> 식단을 짜는 거 (한끼)
    
    3. 식료품 확인을하고 이거를 추가한 식단
    
    4. 냉장고 있는 임의의 재료로 랜덤 식단
}
import java.io.*;
import java.util.*;


class ShowMenu extends Allbest {
	
	ShowMenu() throws Exception
	{
		
	}
	
	void menu() throws Exception
	{
		String juso = System.getProperty("user.dir");
		File f0 = new File(juso,"\\Ingrlnfo\\foodStock.ser");
		
		FileInputStream fis = new FileInputStream(f0);
		ObjectInputStream ois = new ObjectInputStream(fis);
		
		hs = (Hashtable<String,Integer>)ois.readObject();
		
		fis.close();
		ois.close();
		
		Enumeration e1 = hs.keys();
		
		while (e1.hasMoreElements())
		{
			key1 = (String)e1.nextElement();
			value1 = (Integer)hs.get(key1);
			System.out.println(key1);
			System.out.println(value1);
		}
	}
	
	void jego() throws Exception
	{
		String juso = System.getProperty("user.dir");
		File f1 = new File(juso,"\\Ingrlnfo\\foodInfo.ser");
		
		FileInputStream fis1 = new FileInputStream(f1);
		ObjectInputStream ois1 = new ObjectInputStream(fis1);
		
		hss = (Hashtable<String,ArrayList<Integer>>)ois1.readObject();
		
		fis1.close();
		ois1.close();
		
		Enumeration e2 = hss.keys();
		
		
		while (e2.hasMoreElements())
		{
			key2 = (String)e2.nextElement();
			value2 = (ArrayList<Integer>)hss.get(key2);
			System.out.println(key2);
			System.out.println(value2);
		}
	}
}import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.Enumeration;
import java.util.Hashtable;

public class Sik {

    public static void main(String[] args) throws Exception{

        String filename = "C:\\JavaStudy\\JavaStudy\\Ingrlnfo\\ingrlnfo.ser";

        FileInputStream fir = new FileInputStream(filename);

        ObjectInputStream obj = new ObjectInputStream(fir);

        fir.close();
        obj.close();


        Hashtable<String,ArrayList<Integer>> hs = (Hashtable<String, ArrayList<Integer>>)obj.readObject();

        String key;
        ArrayList<Integer> value;

        Enumeration e = hs.keys();

        while (e.hasMoreElements());
        {
            key = (String)e.nextElement();

            value = (ArrayList<Integer>)hs.get(key);


        }
        System.out.print(key);





    }
}
import java.io.*;
import java.util.*;

public class Start {
	
			void first() throws Exception
			{	
			ShowMenu sm = new ShowMenu();
	
			Scanner sc = new Scanner(System.in);
		
			System.out.println("1. 재고확인  / 2. 매뉴확인");
			int s = sc.nextInt();
		
			switch (s)
			{
			case 1:sm.jego();
			case 2:sm.menu();
			}
		
			}	
		public static void main(String[] args) throws Exception{
			
			Start st = new Start();
			st.first();
		}
	}
	/*========================================================
 ■■■ 클래스와 인스턴스 ■■■
 - 클래스와 인스턴스 활용
=========================================================*/

// 학생별로 국어점수, 영어점수, 수학점수를 입력받아
// 총점 평균을 계산하는 프로그램을 구현한다.
// 단, 클래스의 개념을 활용하여 작성할 수 있도록한다.
// 또한 이과정에서 배열을 적극적으로 활용할 수 있도록한다.
// 클래스의 설계는 다음의 가이드 라인에 따라 진행할 수 있도록한다.

// [가이드라인]
// 프로그램을 구성하는 클래스
// 1. Record 클래스
//		- 속성만 존재하는 클래스로 설계할 것!!-----------------	check

// 2. Sungjuk 클래스
//		- 인원수를 입력받아, 입력받은 인원수 만큼
//		  이름, 국어점수, 영어점수, 수학점수를 입력받고
//		  총점과 평균을 산출하는 클래스로 설계할 것!!
//		  속성: 인원 수, Record 타입의 배열  ------------------	check
//		  기능: 인원 수 입력, 상세 데이터 입력, 총점 및 평균 연산, 결과 출력

// 3. Test105 클래스
//	    - main() 메소드가 존재하는 외부 클래스로 설계 할 것 !!

// 실행 예)
// 인원 수 입력(1~100) : 102
// 인원 수 입력(1~100) : -20
// 인원 수 입력(1~100) : 3

// 1번째 학생의 이름 입력 : xxx
// 국어 점수 : 90
// 영어 점수 : 80
// 수학 점수 : 70
// 2번째 학생의 이름 입력 : xxx
// 국어 점수 : 92
// 영어 점수 : 82
// 수학 점수 : 72
// 3번째 학생의 이름 입력 : xxx
// 국어 점수 : 82
// 영어 점수 : 72
// 수학 점수 : 62

// xxx 90 80 70	  240  xx.xx	2
// xxx 92 82 72	  xxx  xx.xx	1
// xxx 82 72 62	  xxx  xx.xx	3
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;


// [힌트]

// Record ob1 = new Record();
// Record ob2 = new Record();
// Record ob3 = new Record();

// Record[] rec = new Record[3];
// rec[0] = new Record();
// rec[1] = new Record();
// rec[2] = new Record();



public class Sungjuk
{
	// 주요 속성 구성
	int inwon;					//-- 인원 수
	Record[] rec;				//-- Record 타입의 배열(학생 한 명당 Record 배열 방 한 개 활용)	check!!
								//   Record 를 기반으로 생성된 객체만 담아낼 수 있는 배열		check!!
								
	// 기능 정의(기능 구성)
	// → 메소드 정의
	// ① 인원 수 입력
	public void set()
	{
		Scanner sc = new Scanner(System.in);
		
		do
		{
			System.out.print("인원 수 입력(1~100) : ");
			inwon = sc.nextInt();
	
		}
		while (inwon<1 || inwon>100);	
	
		// check!!
		// Record 클래스를 기반으로 생성된 객체(인스턴스)를 담을 수 있는
		// 배열방을 inwon만큼 생성한 것이지
		// Record 클래스의 인스턴스를 생성한 것은 아니다.
		rec = new Record[inwon];
	
	}
	
	// ② 상세 데이터 입력 + ③ 총점 및 평균 산출
	public void input()
	{
		Scanner sc = new Scanner(System.in);
		
		String[] title = {"국어 점수 : ", "영어 점수 : ", "수학 점수 : "};
		
		
		
		// 인원 수 만큼 반복 → 인원 수에 기반하여 만들어진 배열의 길이만큼 반복
		//for (int i=0; i<rec.length; i++)
		for (int i=0; i<inwon; i++)
		{
			// check!!
			// Record 클래스의 인스턴스 생성
			rec[i] = new Record();
			
			System.out.printf("%d번째 학생의 이름 입력 : ",(i+1));
			rec[i].name = sc.next();
			
			/*
			System.out.print("국어 점수 입력 : ");
			rec[i].kor = sc.nextInt();
			
			System.out.print("영어 점수 입력 : ");
			rec[i].eng = sc.nextInt();
			
			System.out.print("수학 점수 입력 : ");
			rec[i].mat = sc.nextInt();
			*/
			
			/*
			System.out.print("국어 점수 입력 : ");
			rec[i].score[0] = sc.nextInt();
			
			System.out.print("영어 점수 입력 : ");
			rec[i].score[1] = sc.nextInt();
			
			System.out.print("수학 점수 입력 : ");
			rec[i].score[2] = sc.nextInt();
			*/
			
			// for (int j=0; j<rec[i].score.length; j++)	
			for (int j=0; j<3; j++)							// j → 0 1 2 
			{
				// 안내 메세지 출력
				//System.out.print("과목 점수 : ");
				System.out.print(title[j]);					// j → 0 → "국어 점수 : "
															// j → 1 → "영어 점수 : "
															// j → 2 → "수학 점수 : "
						
				rec[i].score[j] = sc.nextInt();
				// rec[i].score[0] = sc.nextInt();	→ 국어 점수
				// rec[i].score[1] = sc.nextInt();	→ 영어 점수
				// rec[i].score[2] = sc.nextInt();	→ 수학 점수
				
				// 국어점수, 영어점수, 수학점수 데이터를
				// 반복적으로 입력받은 과정을 통해 총점에 대한 누적합 산출
				rec[i].tot += rec[i].score[j];
			}
			
			// 평균 산출
			//rec[i].avg = rec[i].tot / 3;
			//rec[i].avg = rec[i].tot / rec[i].score.length;
			
			//rec[i].avg = (double)rec[i].tot / 3;
			//rec[i].avg = (double)rec[i].tot / rec[i].score.length;
			//rec[i].avg = rec[i].tot / (double)rec[i].score.length;
			rec[i].avg = rec[i].tot / 3.0;
			
		}// close outer for
	}// close input()
	
	// ④ 결과 출력
	
	// xxx 90 80 70	  240  xx.xx	2
	// xxx 92 82 72	  xxx  xx.xx	1
	// xxx 82 72 62	  xxx  xx.xx	3
	public void print()
	{
		// 개행
		System.out.println();
		
		// 학생 한 명 당 반복 출력 구문 구성
		//for (int i =0; i<rec.length; i++)
		for (int i =0; i<inwon; i++)
		{
			// 석차 산출 메소드 호출
			ranking();
			
			// 이름 출력
			System.out.printf("%5s",rec[i].name);
			
			//성적 출력 → 과목의 수(국어, 영어, 수학)만큼 반복
			//for (int j=0; j<rec[i].score.length; j++)
			for (int j=0; j<3; j++)
				System.out.printf("%4d",rec[i].score[j]);
			
			// 총점, 평균 출력
			System.out.printf("%5d",rec[i].tot);
			System.out.printf("%8.2f",rec[i].avg);
			
			// check!!
			// 석차 출력 구문 추가!!
			System.out.printf("%5d",rec[i].rank);
			
			// 개행
			System.out.println();
		}
		
	}
	
	
	// ⑤ 석차 산출 메소드 추가
	//	  - 산출 과정에서 연산에 필요한 데이터가 이미 존재하는 상황 → 매개변수 필요하지 않음
	//    - Record 배열의 rank 속성 활용 → 반환 자료형 void
	//	  - 클래스 내부에서 활용할 메소드로 정의 → 접근 제어 지시자 private
	private void ranking()
	{
		// 모든 학생들의 등수 (석차, rank)를 1로 초기화
		for (int i=0; i<inwon; i++)
			rec[i].rank = 1;
		
		// 등수 산출 → 8명의 인원을 예로 들면
		for (int i=0; i<inwon-1; i++)		// 웅~~~   비교기준 → 0		1		2		3		4		5		6
		{
			for (int j=i+1; j<inwon; j++)	// 쑝쑝쑝  비교대상 → 1234567	234567	34567	4567	567		67		7
			{
				if (rec[i].avg>rec[j].avg)			// 비교기준이 비교대상의 평균보다 크다면
				{
					rec[j].rank++;					// 비교대상의 rank를 1만큼 증가
				}
				else if (rec[j].avg>rec[i].avg)		// 비교대상이 비교기준의 평균보다 크다면
				{
					rec[i].rank++;					// 비교기준의 rank를 1만큼 증가
				}
			}
		}
		
		
		
		
		
		/*
		int count=0;
		
		for (int i =0; i<rec.length-1; i++)
		{
			for (int j=i+1; j<rec.length; j++)
			{
				if (rec[i].tot < rec[j].tot)
				{
					count++;
				}
				rec[i].rank = count;
			}
			
		}
		*/
		
	}

	
	/* 나의 풀이
	Record[] rc;
	
	int num;
	
	void input()
	{
		Scanner sc = new Scanner(System.in);
		
		do
		{
			System.out.print("인원 수 입력(1~100) : ");
			num = sc.nextInt();
		}
		while (num<1 || num>100);
		
		rc = new Record[num];
		
		for (int i=0; i<rc.length; i++)
		{
			rc[i] = new Record();
		
			System.out.printf("%d번째 학생의 이름 입력 : ",i+1);
			rc[i].sName = sc.next();
			
			System.out.print("국어 점수 : ");
			rc[i].nKor = sc.nextInt();
			
			System.out.print("영어 점수 : ");
			rc[i].nEng = sc.nextInt();
			
			System.out.print("수학 점수 : ");
			rc[i].nMat = sc.nextInt();
			
		}
		System.out.println();		
	}
	
	int[] tot = new int[num];
	double[] avg = new double[num]; 
	
	void getTot()
	{
		for (int i=0; i<rc.length; i++)
		{
			rc[i].nTot = rc[i].nKor + rc[i].nEng + rc[i].nMat;
		}
		
	}
	
	void getAvg()
	{
		for (int i=0; i<rc.length; i++)
		{
			rc[i].dAvg = (double)rc[i].nTot / 3;
		}
	}
		
	void print()
	{
		for (int i=0; i<rc.length; i++)
		{
			System.out.printf("%s  %d %d %d  %d  %.2f\n",rc[i].sName,rc[i].nKor,rc[i].nEng,rc[i].nMat,rc[i].nTot,rc[i].dAvg);
		}
	}
	*/
	
				
}//import java.util.Queue;
//import java.util.LinkedList;

import java.util.Vector;
import java.util.Iterator;

public class Test000{
	
	// 정적 문자열 배열 선언 및 초기화
	private static final String[] colors
	= {"검정","노랑","초록","파랑","빨강","연두"};
	public static void main(String[] args){
		
		Vector<Object> v = new Vector<Object>();
		
		int i;
		String a;
		
		
		for (i=0;i<colors.length;i++)
		{
			v.add(colors[i]);
		}
		
		// 데이터 요소 추가
		v.addElement("씨벌");				// 마지막에 데이터 요소 추가
		v.insertElementAt("지미",0);		// 지정된 위치에 데이터 요소 추가
		v.set(0, "고자");
		
		Iterator<Object> it = v.iterator();
		
		while (it.hasNext())
		{
			a = (String)it.next();
			System.out.println("값 : " + a);
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		// Queue 실습
		/*
		Queue<String> qu = new LinkedList<String>();
		
		
		String[] str ={"박제훈","김믿음","정영훈","김태완"};
		

		for (String color : str)
		{
			qu.offer(color);
			//System.out.print(qu.element());				// 요소를 제거하지않고 head값을 반납 >> "박제훈"
		}

		
		while (qu.peek() != null)
		{
			String val = (String)qu.poll();					//
			System.out.println(val);
		}
		*/
		
	}
}public class Test011
{
	public static void main(String[] arg)
	{
		// 주요 변수 선언 및 초기화
		int a = 10, b=20;          //--가로 세로
		int x,y;
		
		//연산 및 처리
		x= a*b;
		y = (a + b) *2;
		
		//결과 출력
		//System.out.println("넓이 : " + x);
		//System.out.println("둘레 : " + y);
		//--==>> 넓이 : 200
		//       둘레 : 60
		
		System.out.println("넓이 : " + y);/*==============================================
■■■자바 기본 프로그래밍■■■
-변수와 자료형
-자바 기본 입출력 : BufferedReader 클래스 활용
==============================================*/

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test012
{
	public static void main(String[] args) throws IOException
	{
		int n = 10;
		
		// 키보드 장착(생성)
		// -> BufferedReader 클래스 기반의 인스턴스(객체) 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		//------------------------------------
		//  문자 입력을 읽어들이는 장치
		//                                      ---------------------
		//                                      바이트 -> 문자(번역)
		//                                                            -----------
		//                                                            바이트 입력값
		
		// 주요 변수 선언 및 초기화
		int r;                      //-- 반지름(r)
		final double PI = 3.141592; //-- 원주율(ㅠ) -> 변수의 상수화 [final]
		double a,b;                 //-- 원의 넓이(a), 원의 둘레(b)
		
		// 연산 및 처리
		// 1.사용자에게 안내 메세지 출력
		//System.out.println("원의 반지름 입력 : ");
		System.out.print("원의 반지름 입력 : ");
		
		// 2. 사용자가 입력한 값을 받아와 반지름 변수 r에 담아내기
		//r=br.readLine();          //--BufferedReader 의 readLine()
		//                          // -> 입력 대기열에 남아있는 문자열 반환
		//r = "2345"
		
		//Integer.parseInt("2345); -> 2345
		//Integer.parseInt("90"); -> 90
		//Integer.parseInt("윤영식"); - 에러발생
		//Integer.parseInt("abcd"); - 에러발생
		//Integer.parseInt
		//-- 매개변수로 넘겨받은 문자열 데이터를 정수형으로 변환
		// 단, 이때 넘겨받은 문자열 데이터는 숫자 모양(형태)이어야한다 -  NumberFormat
		
		// 원의 반지름 입력 : 2345
		r = Integer.parseInt(br.readLine());
		//r = Integer.parseInt("2345");
		//r = 2345;
		//-- 사용자가 입력한 값을 br 즉 BufferedReader 의 readLine()
		// 메소드를 활용하여 문자열 형태로 읽어들인 후
		// 그값을 Integer.parseInt() 를 통해 숫자형(정수형)으로 반환 후
		// 정수 형태의 반지름 변수 r에 담아내는 과정
		
		// 3. 넓이 및 둘레 계산
		//    - 연산 결과를 각각 변수 a 와 b에 담아내기
		a = r * r * PI;
		b = r * 2 * PI;
		
	
		// 최종 결과 출력
		// - 변수 a 와 b 에 담겨있는 값 출력
		//System.out.println(">> 넓이 : " + a);
		//System.out.println(">> 둘레 : " + b);
		//--  원의 반지름 입력 : 42
        //    >> 넓이 : 5541.768288
        //    >> 둘레 : 263.893728
		
		// 원의 반지름 입력 : 42
		// >> 반지름이 42인 원의 넓이는 5541.77 이며,
		// >> 반지름이 42인 원의 둘레는 263.89 이다.
		
		System.out.printf(">> 반지름이 %d인 원의 넓이는 %.2f 이며\n>> 반지름이 %d인 원의 둘레는 %.2f 이다.\n",r,a,r,b);
	}
}

// 실행결과

/*
원의 반지름 입력 : 42
>> 반지름이 42인 원의 넓이는 5541.77 이며
>> 반지름이 42인 원의 둘레는 263.89 이다.
계속하려면 아무 키나 누르십시오 . . .
*//*==============================================
■■■자바 기본 프로그래밍■■■
-변수와 자료형
-자바 기본 입출력 : BufferedReader 클래스 활용
==============================================*/

// ○ 퀴즈
//    삼각형의 밑 변의 길이와 높이를 사용자로부터 입력받아
//    이 삼각형의 넓이를 구하는 프로그램을 구현한다.

// 실행 예)
// 삼각형의 넓이 구하는 프로그램
// - 삼각형의 밑변 입력 : 30
// - 삼각형의 높이 입력 : 50

// >> 밑변이 30, 높이가 50인 삼각형의 넓이 : xxx
// 계속하려면 아무 키나 누르세요... 

// 문제 인식 및 분석
// 삼각형의 넓이 = 밑변 * 높이 / 2
// 사용자로부터 데이터를 입력받아 처리 →  BufferedReader 활용
// 밑변과 높이를 사용자로부터 입력받는다고 해서
// BufferedReader 두 개를 활용할 필요 X

// import는 클래스가 작성되기 전에 작성해야한다.
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test013
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언
		
		// BufferedReader 인스턴스 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		// 밑변, 높이, 넓이
		
		int underLength,height;   // 밑변, 높이
		          
		double area;   // 넓이(c) = 밑변(a) * 높이(b) / 2    --- 실수형태로 (check!!)
		
		// 연산 및 처리
		// 1. 사용자에게 안내 메세지 출력
		System.out.println("■ 삼각형의 넓이를 구하는 프로그램 ■");
		System.out.print("- 삼각형의 밑변 입력 : ");
		
		// 2. 사용자가 입력한 데이터(문자열)를 정수형태로 변환한 후
		//    변수 underLength 에 담아내기
		underLength = Integer.parseInt(br.readLine());
		
		// 3. 다시 사용자에게 안내 메세지 출력
		System.out.print("- 삼각형의 높이 입력 : ");
		
		// 4. 사용자가 입력한 데이터(문자열)를 정수 형태로 변환한 후
		//    변수 height 에 담아내기
		height = Integer.parseInt(br.readLine());
		
		// 5. 삼각형의 넓이를 구하는 연산 처리
		//    삼각형의 넓이 = 밑변 * 높이 / 2
		// area = underLength * height / 2;           
		//      정수형       정수형  정수형        → 정수 기반의 연산(즉, 몫을 취하고 나머지는 버림)
		
		// area = (double)(underLength * height / 2.0);  → (X)
		
		area = underLength * height / 2.0;
		//      정수형       정수형  정수형        → 실수 기반의 연산
		
		
		
		//  실수 자료형이 결과값으로 나오는 과정에서
		//  실수 기반의 연산이 필요한 상황이다.
		//  정수형 2 가 아닌 실수형 2.0 으로 나눗셈 연산을 수행하게 되면
		//  이 연산을 실수 기반으로 처리된다.
		
		// 결과 출력
		System.out.println();     //-- 개행
		
		//System.out.printf("\n>> 밑변이 %d, 높이가 %d인 삼각형의 넓이 : %.2f\n", underLength, height, area);
		System.out.printf(">> 밑변이 %d,높이가 %d인 삼각형의 넓이 : %.2f\n",underLength,height,area);
		
		// 실행결과
		
		/*■ 삼각형의 넓이를 구하는 프로그램 ■
             삼각형의 밑변 입력 : 30
             삼각형의 높이 입력 : 50
             >> 밑변이 30,높이가 50인 삼각형의 넓이 : 750
             계속하려면 아무 키나 누르십시오 . . .*/
		
		
	}
}/*==============================================
■■■자바 기본 프로그래밍■■■
-변수와 자료형
-자바 기본 입출력 : BufferedReader 클래스 활용
==============================================*/

// 사용자로 부터 이름 국어점수 영어점수 수학점수를 입력받아
// 이름과 총점을 출력하는 프로그램을 구현한다.

//실행 예)
// 이름을 입력하세요 : 윤영식
// 국어 점수 입력 : 90
// 영어 점수 입력 : 80
// 수학 점수 입력 : 70

// ====[결과]====
// 이름 : 윤영식
// 총점 : 240
// 계속하려면 아무 키나 누르세요...
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test014
{
	public static void main(String[] args) throws IOException
	{
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		String name;
		int korean,english,math,total;
		
		System.out.print("이름을 입력하세요 : ");
		
		name = br.readLine();
		
		System.out.print("국어 점수를 입력 : ");
		korean = Integer.parseInt(br.readLine());
		
		System.out.print("영어 점수를 입력 : ");
		english = Integer.parseInt(br.readLine());
		
		System.out.print("수학 점수를 입력 : ");
		math = Integer.parseInt(br.readLine());
		
		total = korean + english + math;
		
		System.out.println();
		System.out.println(" ====[결과]==== ");
		System.out.printf(" 이름 : %s\n",name);
		System.out.printf(" 총점 : %d\n",total);
		
		/*
		이름을 입력하세요 : 윤영식
        국어 점수를 입력 : 90
        영어 점수를 입력 : 80
        수학 점수를 입력 : 70

         ====[결과]====
        이름 : 윤영식
        점 : 240
        계속하려면 아무 키나 누르십시오 . . .*/
		
/* 
import java.io.InputStreaReader;
import java.io.BufferedReader;
import java.io.IOException;

public class Test014
		{
			public static void main(String[] args) throws IOException
		{
			// 주요 변수 선언
			
			// BufferedReader 인스턴스 생성
			InputStreamReader isr = new InputStreamReader(System.in);
			BufferedReader br = new BufferedReader(isr);
			
			// BufferedReader br = new BufferedReader(isr);
			//                  ↓
			// BufferedReader br = new BufferedReader( new InputStreamReader(System.in);
			String strName;        //-- 이름변수
			int nKor, nEng, nMat   //-- 국어,영어,수학 점수 변수
			int nTot               //-- 총점 변수
			
			String strTemp         //-- 문자열 임시 저장 변수
			// 연산 및 처리
			// - 사용자에게 안내 메세지 출력(이름 입력 안내)
			System.out.print("이름을 입력하세요 : ");
			
			// - 사용자가 입력한 값(외부 데이터 → 문자열)을 변수에 담아내기
			strName = br.readLine();
			
			// - 사용자에게 안내 메세지 출력(국어 점수 입력 안내)
			System.out.print("국어 점수 입력 : ");
			
			// - 사용자가 입력한 값(외부 데이터 → 문자열)을 변수에 담아내기
			//nKor = Integer.parseInt(br.readLine());
		    strTemp = br.readLine();
			nKor = Integer.parseInt(strTemp);
			
			// 결과 출력
			
			
			
	}
	}*/	
		
		
		
		
		
		
	}
}/*===============================
■■■ 자바 기본 프로그래밍■■■
- 변수와 자료형
- 실수형 데이터타입 정밀도 테스트
================================*/

public class Test019
{
	public static void main(String[] args)
	{
		//주요 변수 선언
		float a = 0;
		double b = 0;
		
		
		//연산 및 처리 → 반복 연산 → 반복문 구성 → 100000(십만)번 반복
		for(int i = 1; i<=100000; i++)
		{
			//확이(테스트)
			//System.out.println("반복문 출력");
			//System.out.println(i);
			
			a += 100000;        //-- a를 100000 만큼 증가시켜라!!!
			b += 100000;        //-- b를 100000 만큼 증가시켜라!!!
			
			
			
		}
		//a → 10000000000/100000 → 100000
		//b → 10000000000/100000 → 100000
		
		
		//결과 출력
		System.out.println("flaot a : " + (a/100000));
		System.out.println("double b : " + (b/100000));
	}
}
// 실행 결과

/*
flaot a : 99996.055
double b : 100000.0
계속하려면 아무 키나 누르십시오 . . .
*//*===================================
■■■ 자바 기본 프로그래밍 ■■■
- 산술 연산자
-BufferedReader
-printf()
====================================*/
//○ 사용자로부터 임의의 정수를 두번 입력받아
//사칙 연산 및 나머지 연산을 수행하여
//그 결과를 출력하는 프로그램을 구현한다.
//단 입력받는 과정은 BufferedReader 를 활용할수 있도록 하고
//출력하는 과정은 printf() 메소드를 활용할수 있도록 한다.
//또한 나눗셈 연산은 편의상 정수 기반 (몫을 취하는 형태)으로 처리한다.

// 실행예)
//첫번쨰 정수 입력 : 10
//두번쨰  정수 입력 : 2

// ===결과===
// 10 + 2 = 12
// 10 - 2 = 10
// 10 * 2 = 20
// 10 / 2 = 5
// 10 % 2 = 0
//============
//계속하려면 아무 키나 누르세요...
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test020
{
	public static void main(String[] args) throws IOException
		{
		/*
		int a,b;
		int c,d,e,f,g;
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 
		System.out.printf("첫번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.printf("두번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		
		c = a + b;
		d = a - b;
		e = a * b;
		f = a / b;
		g = a % b;
		
		System.out.printf("===결과===\n");
		System.out.printf("%d + %d = %d\n",a,b,c);
		System.out.printf("%d - %d = %d\n",a,b,d);
		System.out.printf("%d * %d = %d\n",a,b,e);
		System.out.printf("%d / %d = %d\n",a,b,f);
		System.out.printf("%d %% %d = %d\n",a,b,g);
		System.out.printf("==========\n");
		*/
		
		//주요 변수 선언
	    int num1, num2;                 //-- 사용자 입력값을 담을 변수
		int res1,res2,res3,res4,res5;   //-- 각각의 연산 결과를 담을 변수
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//연산 및 처리
		System.out.print("첫번째 정수 입력 : ");
		num1 = Integer.parseInt(br.readLine());
		
		System.out.print("두번째 정수 입력 : ");
		num2 = Integer.parseInt(br.readLine());
		
		res1 = num1 + num2;
		res2 = num1 - num2;
		res3 = num1 * num2;
		res4 = num1 / num2;
		res5 = num1 % num2;
		
		
		//결과 출력
		//System.out.printf("%n====[결과]====%n");
		System.out.printf("\n====[결과]====\n");
		System.out.printf("%d + %d = %d\n",num1,num2,res1);
		System.out.printf("%d - %d = %d\n",num1,num2,res2);
		System.out.printf("%d * %d = %d\n",num1,num2,res3);
		System.out.printf("%d / %d = %d\n",num1,num2,res4);
		System.out.printf("%d %% %d = %d\n",num1,num2,res5);
		System.out.printf("================\n");
		
		
	}
	
}

/*
실행 결과
첫번째 정수 입력 : 40
두번째 정수 입력 : 5

====[결과]====
40 + 5 = 45
40 - 5 = 35
40 * 5 = 200
40 / 5 = 8
40 % 5 = 0
===============
계속하려면 아무 키나 누르십시오 . . .
*/

/* 
실행 결과

첫번째 정수 입력 : 10
두번째 정수 입력 : 2
===결과===
10 + 2 = 12
10 - 2 = 8
10 * 2 = 20
10 / 2 = 5
10 % 2 = 0
==========
계속하려면 아무 키나 누르십시오 . . .
*/

/*=====================================
■■■ 연산자 (Operator) ■■■
- 비트 단위 연산자
=====================================*/


public class Test021
{
	public static void main(String[] args)
	{
		int a = 10, b = -10;
		
		System.out.printf("~a : %d%n",~a);
		System.out.printf("~b : %d%n",~b);
		
	}
}
// 실행결과

/*
~a : -11
~b : 9
계속하려면 아무 키나 누르십시오 . . .
*/

/*
a = 10;      →     00001010

                       ↓ ~a
				1	1111111      (맨 앞의 1은 탈락)
					11110101     →  -11 → check?  → ok!
				+	00001011     →  11
				-------------
				    00000000     →  0
					
					
b = -10;     →  	????????
                    
                    00001010     → 10
					   ↓
					   ↓ 1의보수           	  	
					   ↓ (비트열 반전)            2의보수 (1의 보수 → +1)
					   ↓
					      1  
				    11110101
				+          1   → 더하기 1
				-------------
				    11110110
					
				1	111111
					11110110 → -10?
				+	00001010 → 10
				-------------
					00000000 
					
					
					11110110
					
					   ↓   -b
					   
					00001001    → 8 + 1 → 9   
					   

*/public class Test022
{
	public static void main(String[] args)
	{
		//주요 변수 선언
		int a=13, b=7;
		int c, d, e;
		
		//연산 및 처리
		c = a & b;
		d = a | b;
		e = a ^ b;
		
		//결과 출력
		System.out.printf("a & b = %d\n",c);
		System.out.printf("a | b = %d\n",d);
		System.out.printf("a ^ b = %d\n",e);
		
	}
}

//실행 결과

/*
a & b = 5
a | b = 15
a ^ b = 10
계속하려면 아무 키나 누르십시오 . . .
*/

/*
      13  → 00001101
	 & 7  → 00000111	
	 ----------------
	         00000101  → 4 + 1 → 5

	  13  → 00001101
	 | 7  → 00000111
	 ----------------
	         00001111  → 8 + 4 + 2 + 1 → 15
			 
      13  → 00001101
	 ^ 7  → 00000111
	 ----------------
			 00001010  → 8 + 2 → 10
*/
			 
			 /*=================================================
■■■ 연산자 (Operator) ■■■
- 비트 단위 연산자
- 두 변수에 담겨있는 내용(값) 바꾸기 → 스왑 (swap)
  → 『^(xor)』 연산자 활용
==================================================*/

public class Test023
{
	public static void main(String[] args)
	{
		// 주요 변수 선언 및 초기화
		int x = 20, y = 23;             //-- 서로 다른 값이 담겨있는 두 변수
		//int temp;                       //-- 임시 저장 변수
		
		//담겨있는 내용물 확인
		System.out.printf("x → %d, y → %d\n",x,y);
		//--==>> x → 20, y → 23
		
		// 연산 처리
		/*
		temp = x;
		x = y;
		y = temp;
		*/
		
		/*
		temp = y;
		y = x;
		x = temp;
		*/
		
		/*
		x=x^y;
		y=y^x;
		x=x^y;
		*/
		
		y=y^x;
		x=x^y;
		y=y^x;
		
		// 결과 출력
		System.out.printf("x → %d, y → %d\n",x,y);
	}
}

//실행 결과

/*
x → 20, y → 23
x → 23, y → 20
계속하려면 아무 키나 누르십시오 . . .
*/

/*
x=20, y=23

x=x^y;      → x=20^23;
              
			  00010100 → 20
			^ 00010111 → 23
			----------------
			  00000011 →  3
			
			→ x=3;
			
			
y=y^x;      → y=23^3;

              00010111 → 23
			^ 00000011 →  3
			----------------
			  00010100 → 16 + 4 → 20
			
			→ y=20;
			
			
x=x^y;      → x=3^20;
                 
			  00000011 →  3
			^ 00010100 → 20
			----------------
			  00010111 → 16 + 4 + 2 + 1 → 23
			  
			→ x=23;  

*//*===============================
■■■ 연산자 (Operator) ■■■
- 비트 단위 연산자
================================*/


public class Test024
{
	public static void main(String[] args)
	{
		int x = 128;      // 00000000 00000000 00000000 10000000
		
		System.out.printf("x << 3 : %d%n",x << 3);
		// 00000000 00000000 00000000 10000000
		// 00000000 00000000 00000100 00000000
		//--==>> x << 3 : 1024
		
		System.out.printf("x >> 3 : %d%n",x >> 3);
		// 00000000 00000000 00000000 10000000
		// 00000000 00000000 00000000 00010000
		//--==>> x >> 3 : 16
		
		System.out.printf("x * 8 : %d%n",x * 8);
		//--==>> x * 8 : 1024
		System.out.printf("x / 8 : %d%n",x / 8);
		//--==>> x / 8 : 16
		
		System.out.println("---------------------------");
		
		System.out.printf("x << 24 : %d%n", x << 24);
		// 00000000 00000000 00000000 10000000
		// 10000000 00000000 00000000 00000000
		//--==>> x << 24 : -2147483648
		
		System.out.printf("x << 25 : %d%n", x << 25);
		System.out.printf("x << 26 : %d%n", x << 26);
		System.out.printf("x << 27 : %d%n", x << 27);
		//--==>> x << 25 : 0
        //       x << 26 : 0
        //       x << 27 : 0
		System.out.printf("x << 32 : %d%n", x << 32);     // 다시 자기값으로 돌아간다.
		//--==>> x << 32 : 128
	}
}


/*
x << 3 : 1024
x >> 3 : 16
계속하려면 아무 키나 누르십시오 . . .
*/

/*
x << 3 : 1024
x >> 3 : 16
x * 8 : 1024
x / 8 : 16
---------------------------
x << 24 : -2147483648
x << 25 : 0
x << 26 : 0
x << 27 : 0
x << 32 : 128
계속하려면 아무 키나 누르십시오 . . .
*//*===============================
■■■ 연산자 (Operator) ■■■
- 논리 단위 연산자
================================*/

public class Test025
{
	public static void main(String[] args)
	{
		boolean a = true ,b = false;
		
		System.out.printf("a && b : %b%n" ,(a && b));
		System.out.printf("a || b : %b%n" ,(a || b));
		System.out.printf("!a     : %b%n" , !a);
		System.out.printf("!b     : %b%n" , !b);
		
			
	}
}
//실행 결과

/*
a && b : false
a || b : true
!a     : false
!b     : true
계속하려면 아무 키나 누르십시오 . . .
*//*===============================
■■■ 연산자 (Operator) ■■■
- 조건 단위 연산자 == 삼항 연산자
================================*/

/*
			 
           │
피연산자 연산자 피연산자 연산자 피연산자
--------        --------        --------
  1항              2항             3항
  
피연산자   ?    피연산자   :    피연산자
--------        ---------       --------
  1항              2항             3항
  
1항의 연산 결과  → true     →  2항 수행(치환)
                 → false    →  3항 수행(치환)
  
*/

// 사용자로부터 임의의 정수를 입력받아
// 입력받은 정수가 짝수인지 홀수인지 판별하는 프로그램을 구현한다
// 단, 조건 연산자(삼항연산자)를 활용하여 문제를 해결할수 있도록 한다

// 실행 예)
// 임의의 정수 입력 : 371

// =====[판별결과]====
// 371 → 홀수
// ===================
//계속하려면 아무 키나 누르세요...


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

//import java.io.*;

public class Test026
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n;                 //-- 사용자로부터 입력받은 임의의 정수를 담아둘 변수
		String strResult;      //-- 홀수인지 짝수인지에 대한 판별 결과를 담게될 변수
		
		
		// 연산 및 처리
		System.out.print("임의의 정수 입력 : ");
		n = Integer.parseInt(br.readLine());
		
		// 홀수인지 짝수인지에 대한 판별 연산
		// ____ ? ____ : ____
		// 수식1  수식2  수식3
		
		// 수식 1 : 참(true) 또는 거짓(false)을 반환할 수 있는 수식 형태로 작성
		// 수식 2 : 수식1 의 처리 결과가 참(true)일 경우 수행하는 영역
		// 수식 3 : 수식1 의 처리 결과가 거짓(false)일 경우 수행하는 영역
		
		// 입력받은 정수(n)가 홀수인지, 짝수인지 확인하기 위한 연산
		// → n 을 2로 나누어 나머지가 0이면        → 짝수
		//                             0이 안아니면 → 홀수
		
		// n 을 2로 나눈 나머지가 0 이다? "짝수" : "홀수";
		// n % 2 == 0 ? "짝수" : "홀수";
		// (n % 2 == 0) ? "짝수" : "홀수";
		
		//임의의 정수 입력 : 30
		// n = 30
		// (30 % 2 == 0) ? "짝수" : "홀수";
		// (0 == 0) ? "짝수" : "홀수";
		// (true) ? "짝수" : "홀수";
		// "짝수";
		
		//strResult = "짝수";
		strResult = (n % 2 == 0) ? "짝수" : "홀수";
		// 임의의 정수 입력 : 273
		// n = Integer.parseInt("273");
		// n = 273
		// strResult = (n % 2 == 0) ? "짝수" : "홀수";
		// strResult = (273 % 2 == 0) ? "짝수" : "홀수";
		// strResult = (1 == 0) ? "짝수" : "홀수";
		// strResult = (false) ? "짝수" : "홀수";
		// strResult = "홀수";
		
		// 결과 출력
		System.out.println();
		System.out.println("====[판별결과]====");
		System.out.printf("%d → %s%n",n,strResult);
		System.out.println("==================");
	
	}
}
/*
임의의 정수 입력 : 327

====[판별결과]====
327 → 홀수
==================
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 320

====[판별결과]====
320 → 짝수
==================
계속하려면 아무 키나 누르십시오 . . .
*//*===============================
■■■ 연산자 (Operator) ■■■
- 조건 단위 연산자 == 삼항 연산자
================================*/

// 사용자로부터 임의의 정수를 입력받아
// 입력받은 정수가 양수인지, 음수인지, 0인지 구분하여
// 이결과를 출력하는 프로그램을 구현한다
// 단, 입력 데이터는 BufferedReader를 활용하여 처리하고
// 조건 연산자(삼항 연산자)를 활용하여 기능을 구현할 수 있도록 한다.

// 실행 예)
// 임의의 정수 입력 : -42
// -42 → 음수 
// 계속하려면 아무키나 누르세요...

// 임의의 정수 입력 : 1024
// 1024 → 양수
// 계속하려면 아무키나 누르세요...

// 임의의 정수 입력 : 0 
// 0 → 영
// 계속하려면 아무키나 누르세요...



import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test027
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n;
		String strResult;
		
		//연산 및 처리
		System.out.print("임의의 정수 입력 : ");
		n = Integer.parseInt(br.readLine());
		
		/*
		n 이 0보다 크다    → true    →  n 은 양수
		                   → false   →  n 은 0보다 작다    → true     → n 은 음수
						                                     → false    → n 은 영
															 
		(n > 0) ? ("양수") : (다시 확인);													 
		                     ------------
							 (n < 0) ? ("음수") : ("영");
							 
		(n > 0) ? ("양수") : (n < 0) ? ("음수") : ("영");
		strResult = (n > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		*/
		strResult = (n > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// 567
		// strResult = (n > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = (567 > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = (true) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = "양수";
		
		// -5 
		// strResult = (n > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = (-5 > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = (false) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = ((n < 0) ? ("음수") : ("영"));
		// strResult = ((-5 < 0) ? ("음수") : ("영"));
		// strResult = ((true) ? ("음수") : ("영"));
		// strResult = "음수";
		
		// 0
		// strResult = (n > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = (0 > 0) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = (false) ? ("양수") : ((n < 0) ? ("음수") : ("영"));
		// strResult = ((n < 0) ? ("음수") : ("영"));
		// strResult = ((0 < 0) ? ("음수") : ("영"));
		// strResult = ((false) ? ("음수") : ("영"));
		// strResult = "영";
		
		
		// 결과 출력
		System.out.println(n + " → " + strResult);
		
		
		/*
		int num;
		String strResult;
			
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("임의의 정수 입력 : ");
		num = Integer.parseInt(br.readLine());
		
		strResult = (num > 0) ? "양수" : (num == 0) ? "영" : "음수";
		
		System.out.println("====[판별결과]====");
		System.out.printf("%d → %s%n",num,strResult);
		System.out.println("==================");
		*/
	}
}
/*
임의의 정수 입력 : -258
-258 → 음수
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 149
149 → 양수
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 0
0 → 영
계속하려면 아무 키나 누르십시오 . . .
*/
// -----------------------------------------
/*
임의의 정수 입력 : 34
====[판별결과]====
34 → 양수
==================
계속하려면 아무 키나 누르십시오 . . .
*/


/*
임의의 정수 입력 : -32
====[판별결과]====
-32 → 음수
==================
계속하려면 아무 키나 누르십시오 . . .
*/


/*
임의의 정수 입력 : 0
====[판별결과]====
0 → 영
==================
계속하려면 아무 키나 누르십시오 . . .
*//*===============================
■■■ 연산자 (Operator) ■■■
- 조건 단위 연산자 == 삼항 연산자
================================*/

// ○ 사용자로부터 임의의 한 문자를 입력받아
//    입력받은 문자가 대문자이면 소문자로, 소문자이면 대문자로
//    알파벳이 아닌 기타 문자라면 그 문자를 입력받은 그대로 출력하는
//    프로그램을 구현한다.

// 실행 예)
// 한 문자 입력 : A
// A → a
// 계속하려면 아무 키나 누르세요...

// 한 문자 입력 : b
// b → B
// 계속하려면 아무 키나 누르세요...

// 한 문자 입력 : 7
// 7 → 7
// 계속하려면 아무키나 누르세요...


import java.io.IOException;

public class Test028
{
	public static void main(String[] args) throws IOException
	{
		// 풀이
		/*
		char temp;
		
		System.out.print("한 문자 입력 : ");
		temp = (char)System.in.read();          //int 타입을 char타입으로 강제 형변환
		
		//확인
		System.out.println("입력받은 값 확인 : " + temp);
		
		//temp == 'A';   →  대문자!!
		//temp == 'B';   →  대문자!!
		//temp == 'C';   →  대문자!!
		//temp == 'd';   →  소문자!!
		//temp == 'e';   →  소문자!!
		
		//String tempResult = (temp == 'A') ? ("A구나") : ("A가 아니구나");
		
		//String tempResult = (temp >= 65 && temp <= 90) ? ("대문자") : ("대문자 아님");
		//System.out.println("결과 : " + tempResult);
		
		//String tempResult = (temp >= 'A' && temp <= 'Z') ? ("대문자") : ("대문자 아님");
		//System.out.println("결과 : " + tempResult);
		
		//대문자 → 소문자
		// 'A'(65) → 'a'(97) → +32
		// 'B'(66) → 'b'(98) → +32
		// 'C'(67) → 'c'(99) → +32
		
		// 소문자 → 대문자
		// 'a'(97) → 'A'(65) → -32
		// 'b'(98) → 'B'(66) → -32
		// 'c'(99) → 'C'(67) → -32
 		*/
		
		char ch, result;
		
		System.out.print("한 문자 입력 : ");
		ch = (char)System.in.read();
		
		// result = (입력값대문자) ? (소문자변환) : ((입력갑소문자) ? (대문자변환) : (그대로));
		result = (ch >= 'A' && ch <= 'Z') ? ((char)(ch + 32)) : ((ch >= 'a' && ch <= 'z') ? ((char)(ch-32)) : (ch));
		
		// 'Q' (→ 81)
		// result = (81 >= 65 && ch <= 'Z') ? ((char)(ch + 32)) : ((ch >= 'a' && ch <= 'z') ? ((char)(ch-32)) : (ch));
		// result = (true && ch <= 'Z') ? ((char)(ch + 32)) : ((ch >= 'a' && ch <= 'z') ? ((char)(ch-32)) : (ch));
		// result = (true && 81 <= 90) ? ((char)(ch + 32)) : ((ch >= 'a' && ch <= 'z') ? ((char)(ch-32)) : (ch));
		// result = (true && true) ? ((char)(ch + 32)) : ((ch >= 'a' && ch <= 'z') ? ((char)(ch-32)) : (ch));
		// result = (true) ? ((char)(ch + 32)) : ((ch >= 'a' && ch <= 'z') ? ((char)(ch-32)) : (ch));
		// result = ((char)(ch + 32));
		// result = ((char)(81 + 32));
		// result = ((char)(113));
		// result = ('q');
		// result = 'q';
		
		System.out.println(ch + " → " + result);
		
		/*
		char a,b;
		
		System.out.print("한 문자를 입력 : ");
		
		a = (char)System.in.read();
		
		b = (90 >= a && a >= 65) ? (char)(a + 32): ((122 >= a && a >= 97) ? (char)(a - 32): (a));  
		
		System.out.printf("%c → %c%n",a,b);
		*/
	
	}
}
// 풀이 결과 확인

/* 
한 문자 입력 : A
A → a
계속하려면 아무 키나 누르십시오 . . .
*/

/*
한 문자 입력 : s
s → S
계속하려면 아무 키나 누르십시오 . . .
*/

/*
한 문자 입력 : 6
6 → 6
계속하려면 아무 키나 누르십시오 . . .
*/

//==========================================

/*
한 문자를 입력 : A
A → a
계속하려면 아무 키나 누르십시오 . . .
*/

/*
한 문자를 입력 : a
a → A
계속하려면 아무 키나 누르십시오 . . .
*/

/*
한 문자를 입력 : 5
5 → 5
계속하려면 아무 키나 누르십시오 . . .
*//*===============================
■■■ 연산자 (Operator) ■■■
- 조건 단위 연산자 == 삼항 연산자
================================*/

// ○ 사용자로부터 임의의 연도를 입력받아
//    입력받은 연도가 윤년인지 평년인지 판별하여
//    그결과를 출력하는 프로그램을 구현한다.
//    단, 입력은 BufferedReader를 활용하고
//    조건 연산자(삼항 연산자)를 활용하여 연산을 수행할수 있도록 한다.

// 실행 예)
// 임의의 연도 입력 : 2000
// 2000년 → 윤년
// 계속하려면 아무키나 누르세요...

// 임의의 연도 입력 : 2012
// 2012년 → 윤년
// 계속하려면 아무키나 누르세요...

// 임의의 연도 입력 : 2022
// 2022년 → 평년
// 계속하려면 아무키나 누르세요...

// ※ 2월이 28일까지 있는해 → 평년
//          29일까지 있는해 → 윤년

// 4년마다 29일, 100년마다 28일 그대로, 400년마다 29일

// ※ 윤년의 판별 조건
//    연도가 4의 배수이면서 100의 배수가 아니거나
//    400의 배수이면 윤년!!
//    그렇지 않으면 평년!!

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test029
{
	public static void main(String[] args) throws IOException
	{
		// 풀이
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int year;             //-- 사용자가 입력한 임의의 연도를 담아낼 변수
		String strResult;     //-- 윤년인지 평년인지 판별 결과를 담아낼 변수
		
		System.out.print("임의의 연도 입력 : ");
		year = Integer.parseInt(br.readLine());
		
		// 연도가 4의 배수                 연도가 100의 배수가 아님                   연도가 400의 배수
		// → 연도를 4로 나눈 나머지가 0   → 연도를 100으로 나눈 나머지가 0이 아님   → 연도를 400으로 나눈 나머지가 0
		// → year % 4 == 0                → year % 100 != 0                         → year % 400 == 0
		
		// 『year % 4 == 0』 이면서 『year % 100 != 0』 거나 『year % 400 == 0』이면 윤년
		// 『year % 4 == 0』 && 『year % 100 != 0』 || 『year % 400 == 0』이면 윤년
		
		strResult = (year % 4 == 0 && year % 100 != 0 || year % 400 == 0) ? "윤년" : "평년";
		
		System.out.printf("%d → %s%n",year,strResult);
		
		/*
		int year;
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("임의의 연도 입력 : ");
		year = Integer.parseInt(br.readLine());
		
		//나의 풀이
		String result = ((year % 4 == 0) && (year % 100 != 0)) ? "윤년" : (year % 400 == 0) ? "윤년" : "평년";
		//-----------------------------------------------------------------------------------------------------
		//String result = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0) ? "윤년" : "평년";
		//String result = (year % 400 == 0) || ((year % 4 == 0) && (year % 100 != 0)) ? "윤년" : "평년";
		 
		System.out.printf("%d년 → %s%n",year,result);
		*/
	}
}


// 풀이 결과
/*
임의의 연도 입력 : 2024
2024 → 윤년
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도 입력 : 2025
2025 → 평년
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도 입력 : 1992
1992 → 윤년
계속하려면 아무 키나 누르십시오 . . .
*/

//나의 결과

/*
임의의 연도 입력 : 2024
2024년 → 윤년
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도 입력 : 1900
1900년 → 평년
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도 입력 : 2000
2000년 → 윤년
계속하려면 아무 키나 누르십시오 . . .
*/
/*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// 1. 프로그램을 작성할떄 주어진 조건에 따라
//    분기 방향을 정하기 위해 사용되는 제어문에는
//    if 문 , if ~ else문 조건 연산자

//2. if문은 if 다음의 조건이 참 일경우
//   특정 문장을 수행하고자 할때 사용되는 구문이다

// 사용자로부터 이름 국어점수 영어점수 수학점수를 입력받아
// 다음과 같은 형태로 출력하는 프로그램을 작성한다
// 산출되는 등급은 평균점수를 기준으로 처리한다

// 90점이상 :A
// 80점이상 90점 미만 : B
// 70점이상 80점 미만 : C
// 60점이상 70점 미만 : D
// 60점 미만          : F

// 단 BufferedReader를 활용하여 데이터를 입력받을수있도로 하며
// printf() 메소드를 통해 출력할수 있도록 한다.
// 실행 예)
// 이름 입력 : 
// 국어 점수 :
// 영어 점수 :
// 수학 점수 :

// >> 당신의 이름은 입니다
// >> 국어 점수는 90,
// >> 영어 점수는 80,
// >> 수학 점수는 70,
// >> 총점은 240이고 평균은 80.00입니다.
// >> 등급은 B입니다.
// 계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test030 
{
	public static void main(String[] args) throws IOException
	{
		// 풀이
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//1. 사용자로부터 이름을 입력받는다.
		System.out.print("이름 입력 : ");
		String strName = br.readLine();
		
		//2. 사용자로부터 국어점수, 영어점수, 수학점수를 입력받는다.
		System.out.print("국어 점수 : ");
		String strKor = br.readLine();
		System.out.print("영어 점수 : ");
		String strEng = br.readLine();
		System.out.print("수학 점수 : ");
		String strMat = br.readLine();
		
		//3. 문자열 형태로 입력받는 과목 점수를 정수 형태로 변환한다.
		int nKor = Integer.parseInt(strKor);
		int nEng = Integer.parseInt(strEng);
		int nMat = Integer.parseInt(strMat);
		
		//4. 산술 연산을 통해 총점과 평균을 산출한다.
		int nTot = nKor + nEng + nMat;            //-- 총점
		//double fAvg = nTot / 3;
		//double fAvg = (double)(nTot / 3);       //-- (X)
		//double fAvg = (double)nTot / 3;         //-- (O)
		double fAvg = nTot / 3.0;                 //-- 평균
		
		//5. 등급에 대한 조건 검사를 수행한다.
		//char grade;
		char grade = 'F';
		
		if (fAvg >= 90)
		{
			grade = 'A';
		}
		else if (fAvg >= 80)
		{
			grade = 'B';
		}
		else if (fAvg >= 70)
		{
			grade = 'C';
		}
		else if (fAvg >= 60)
		{
			grade = 'D';
		}
		else if (fAvg < 60)
		{
			grade = 'F';
		}
		// else (fAvg < 60)
		// {
		//    grade = 'F';
		// }
	
		//6. 최종 결과 출력
		System.out.printf("\n>> 당신의 이름은 %s 입니다.\n",strName);
		System.out.printf(">> 국어 점수는 %s,\n",strKor);
		System.out.printf(">> 영어 점수는 %s,\n",strEng);
		System.out.printf(">> 수학 점수는 %s,\n",strMat);
		System.out.printf(">> 총점은 %d이고 평균은 %.2f입니다.\n",nTot,fAvg);
		System.out.printf(">> 등급은 %c 입니다.\n",grade);
		
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		String sName;
		int nKor,nEng,nMat;
		int nTot;
		double avg;
		char grade;
		
		System.out.print("이름 입력 : ");
		sName = br.readLine();
		System.out.print("국어 점수 : ");
		nKor = Integer.parseInt(br.readLine());
		System.out.print("영어 점수 : ");
		nEng = Integer.parseInt(br.readLine());
		System.out.print("수학 점수 : ");
		nMat = Integer.parseInt(br.readLine());
		
		nTot = nKor + nEng + nMat;
		
		avg = nTot / 3.0;
		
		if (avg >= 90)
		{
			grade = 'A';
		}
		else if (avg >= 80 && avg < 90)
		{
			grade = 'B';
		}
		else if (avg >= 70 && avg < 80)
		{
			grade = 'C';
		}
		else if (avg >= 60 && avg < 70)
		{
			grade = 'D';
		}
		else
			grade = 'F';
		
		System.out.printf("당신의 이름은 %s입니다.%n",sName);
		System.out.printf("국어 점수는 %d, %n",nKor);
		System.out.printf("영어 점수는 %d, %n",nEng);
		System.out.printf("수학 점수는 %d, %n",nMat);
		System.out.printf("총점은 %d이고, 평균은 %.2f입니다.%n",nTot,avg);
		System.out.printf("등급은 %c입니다.",grade);
		*/
	}
}
//실행 결과

/* 
이름 입력 : 윤영식
국어 점수 : 90
영어 점수 : 80
수학 점수 : 70

>> 당신의 이름은 윤영식 입니다.
>> 국어 점수는 90,
>> 영어 점수는 80,
>> 수학 점수는 70,
>> 총점은 240이고 평균은 80.00입니다.
>> 등급은 B 입니다.
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// 1. 프로그램을 작성할떄 주어진 조건에 따라
//    분기 방향을 정하기 위해 사용되는 제어문에는
//    if 문 , if ~ else문 조건 연산자, 복합  if (if 문 중첩)
// switch 문 등이 있다

//2. if문은 if 다음의 조건이 참(true) 일경우
//   특정 문장을 수행하고자 할때 사용되는 구문이다

// 사용자로부터 임의의 정수를 입력받아
// 홀수/ 짝수를 판별하는 프로그램을 구현한다.
// 단 if~else구문을 중첩시키는 것이 아니라
// 단일 if 구문을 활용하여 처리 할수 있도록 한다.

//실행 예)
// 임의의 정수 입력 : 20
// >> 20은(는)짝수입니다

// 임의의 정수 입력: 37
// >> 37은(는) 홀수입니다.

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;


public class Test031
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int num;
		
		System.out.print("임의의 정수 입력 : ");
		num = Integer.parseInt(br.readLine());
		
		if (num % 2 == 0)
		{
			System.out.printf(">> %d은(는) 짝수입니다.\n",num);
		}
		if (num % 2 != 0)
		{
			System.out.printf(">> %d은(는) 홀수입니다.\n",num);
		}
		
		
		
		
		
	}
}
/*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// Test031 → 홀수 , 짝수구분 → 단일 if 구문

// 홀수, 짝수, 영 → if ~ else 문 중첩

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test032
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int num;
		
		System.out.print("임의의 정수 입력 : ");
		num = Integer.parseInt(br.readLine());
		// 풀이
		/*
		if (num%2 == 0)
		{
			System.out.println(num + " → 짝수");
		}
		else if (num%2 != 0)
		{
			System.out.println(num + " → 홀수");
		}
		else 
		{
			System.out.println(num + " → 영");
		}
		*/
		/*
		if (num%2 != 0)
		{
			System.out.println(num + " → 홀수");
		}
		else if (num == 0)
		{
			System.out.println(num + " → 영");
		}
		else if (num%2 == 0)
		{
			System.out.println(num + " → 짝수");
		}
		*/
		
		String result = "판정 불가"; //-- 오류방지를 위한 초기값 설정
		
		if (num%2 != 0)
		{
			result = "홀수";
		}
		else if (num == 0)
		{
			result = "영";
		}
		else if (num%2 == 0)
		{
			result = "짝수";
		}
		
		System.out.println(num + " → " + result);
		
		
		
		/*
		if (num == 0)
		{
			System.out.printf("%d은(는) 영입니다.\n",num);	
		}
		else if (num % 2 == 0)
		{
			System.out.printf("%d은(는) 짝수입니다.\n",num);
		}
		else
			System.out.printf("%d은(는) 홀수입니다.\n",num);
		*/		
	}
}/*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// 사용자로부터 임의의 정수를 입력받아
// 다음과 같은 판별결과를 출력하는 프로그램을 구현한다.

// 2의배수 / 3의 배수 / 2와 3의 배수 / 2와 3의 배수가 아님

// 실행 예)
// 임의의 정수 입력 : 4
// >>4 → 2의 배수
// 계속하려면 아무 키나 누르세요...

// 임의의 정수 입력 : 9
// >>9 → 3의 배수
// 계속하려면 아무 키나 누르세요...

// 임의의 정수 입력 : 12
// >>12 → 2와 3의 배수
// 계속하려면 아무 키나 누르세요...

// 임의의 정수 입력 : 17
// >>17 → 2와 3의 배수 아님
// 계속하려면 아무 키나 누르세요...
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test033
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n;
		
		System.out.print("임의의 정수 입력 : ");
		n = Integer.parseInt(br.readLine());
		
		if (n == 0)
		{
			System.out.printf(">> %d → 영\n",n);
		}
		else if (n % 2 == 0 && n % 3 == 0)
		{
			System.out.printf(">> %d → 2와 3의 배수\n",n);
		}
		else if (n % 2 == 0)
		{
			System.out.printf(">> %d → 2의 배수\n",n);
		}
		else if (n % 3 == 0)
		{
			System.out.printf(">> %d → 3의 배수\n",n);
		}
		else if (n % 2 != 0 || n % 3 != 0)                         // 논리연산을 할때에는 잘못 사용하여도 오류가 나타나지 않기 때문에 사용시 주의해야한다.
		{
			System.out.printf(">> %d → 2와 3이 배수 아님\n",n);
		}
		else
			System.out.printf(">> 판정불가 확인 필요\n");
	}
}
// 실행 결과

/*
임의의 정수 입력 : 4
>> 4 → 2의 배수
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 9
>> 9 → 3의 배수
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 12
>> 12 → 2와 3의 배수
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 17
>> 17 → 2와 3이 배수 아님
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// ○ 과제
//    사용자로부터 임의의 연도를 입력받아 
//    입력받은 연도가... 윤년인지, 평년인지 판별하여
//    그 결과를 출력하는 프로그램을 구현한다.
//    단, 입력은 BufferedReader를 활용하고
//    if 조건문을 활용하여 연산을 수행할 수 있도록 한다.

// 실행 예)
// 임의의 연도 입력 :
// 2000년 → 윤년
// 계속하려면 아무키나 누르세요...

// 임의의 연도 입력 : 2022
// 2022년 → 평년
// 계속하려면 아무키나 누르세요...

// ※ 2월이 28일까지 있는해 → 평년
//          29일까지 있는해 → 윤년

// 4년마다 29일, 100년마다 28일 그대로, 400년마다 29일

// ※ 윤년의 판별 조건
//    연도가 4의 배수이면서 100의 배수가 아니거나
//    400의 배수이면 윤년!!
//    그렇지 않으면 평년!!

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test034
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언
		
		// BufferedReader 인스턴스 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 
		
		int year;                                                     // 임의의 연도를 저장하는 변수
		String res;                                                   // 평년,윤년 결과를 저장하는 변수
		
		// 연산 및 처리
		System.out.print("임의의 연도 입력 : ");                      // "임의의 연도 입력 : " 출력    
		year = Integer.parseInt(br.readLine());                       // 입력받은 문자열 형태의 값을 정수형으로 반환후 year에 저장 
		
		if (year % 4 == 0 && year % 100 != 0 || year % 400 == 0)      // 연도가 4의 배수 이면서 100의 배수가 아니거나 400의 배수인 경우 
			res = "윤년";                                             // 위의 조건이 만족하면 "윤년"
		else                                                          // 나머지 연도 
			res = "평년";                                             // 위의 조건을 만족하지 않는 나머지는 "평년"
		
		// 결과 출력
		System.out.printf("\n%d년 → %s\n",year,res);                 // 결과 출력
	}
}
// 실행 결과
/*
임의의 연도 입력 : 1992

1992년 → 윤년
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도 입력 : 1900

1900년 → 평년
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 연산처리 결과를 출력하는 프로그램을 구현한다.
// 단, if 조건문을 활용하여 처리할수 있도록 하며,
// 연산 결과는 편의상 정수 기반으로 처리될수 있도록 한다.

// 실행 예)
// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 123
// 연산자 입력[+ - * /] : +

// >> 10 + 123 = 133
// 계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test035
{
	public static void main(String[] args) throws IOException
	{
		/*
		// 방법 ①
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a, b, op;                       //-- 첫 번째 정수, 두 번째 정수, 연산자
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		
		System.out.print("연산자 입력[+ - * /] : ");
		op = System.in.read();
		
		// 테스트(확인)
		// System.out.printf("사용자가 입력한 연산자 : %d\n",op);   // '+' → 43, '-' → 45, '*' → 42, '/' → 47
		// System.out.printf("사용자가 입력한 연산자 : %c\n",(char)op);
		
		if (op == 43)
		{
			//System.out.println("덧셈 연산 수행");
			System.out.printf("\n>> %d + %d = %d\n",a,b,(a+b));
		}
		else if (op == 45)
		{
			//System.out.println("뺄셈 연산 수행");
			System.out.printf("\n>> %d - %d = %d\n",a,b,(a-b));
		}
		else if (op == 42)
		{
			//System.out.println("곱셈 연산 수행");
			System.out.printf("\n>> %d * %d = %d\n",a,b,(a*b));
		}
		else if (op == 47)
		{
			//System.out.println("나눗셈 연산 수행");
			System.out.printf("\n>> %d / %d = %d\n",a,b,(a/b));
			//System.out.printf("\n>> %d / %d = %.2f\n",a,b,(double)(a/b));
		}
		else
		{
			System.out.printf("\n>> 입력 과정에 오류가 존재합니다.");
		}
		*/
		
		/*
		// 방법 ②
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a,b;          //-- 첫 번째 정수,두번째정수
		char op;          //-- 연산자
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		
		System.out.print("두 번쨰 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		
		System.out.print("연산자 입력[+ - * /] : ");
		//op = (char)Integer.parseInt(br.readLine());  // 그대로 반환
		op = (char)System.in.read(); // 아스키코드 값으로 변환후 반환
		// Integer.parseInt("1234");   → 1234
		// Integer.parseInt("1");      → 1
		// Integer.parseInt("+");      → 에러
		
		//테스트 확인
		//System.out.println("사용자가 입력한 연산자 : " + op);
		
		if (op=='+')//사용자가 입력한 연산자가 '+' 라면...
		{
			// a와b 의 덧셈 연산을 수행하여 출력
			System.out.printf("\n>> %d + %d = %d\n",a,b,(a+b));
		}
		else if (op=='-')//사용자가 입력한 연산자가 '-' 라면...
		{
			// a와b 의 뺄셈 연산을 수행하여 출력
			System.out.printf("\n>> %d - %d = %d\n",a,b,(a-b));
		}
		else if (op=='*')//사용자가 입력한 연산자가 '*' 라면...
		{
			// a와b 의 곱셈 연산을 수행하여 출력
			System.out.printf("\n>> %d * %d = %d\n",a,b,(a*b));
		}
		else if (op=='/') //사용자가 입력한 연산자가 '/' 라면...
		{
			// a와b 의 나눗셈 연산을 수행하여 출력
			System.out.printf("\n>> %d / %d = %d\n",a,b,(a/b));
		}
		else
		{
			System.out.println("\n>> 입력 과정에 오류가 존재합니다.");
		}
		*/
		
		/*
		// 방법 ③
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a,b,result=0;         //-- 첫 번째 정수, 두 번째 정수, 연산 결과
		char op;                  //-- 연산자
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		System.out.print("연산자 입력[+ - * /] : ");
		op = (char)System.in.read();
		
		if (op=='+')
			result = a + b;
		else if (op=='-')
			result = a - b;
		else if (op=='*')
			result = a * b;
		else if (op=='/')
			result = a / b;
		
		//else
		//{
		//	result = -1;
		//}
		
		System.out.printf("\n>> %d %c %d = %d\n",a,op,b,result);
		*/
		
		
		// 나의 풀이
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int num1, num2;
		char op;
		int res = 0;
			
		System.out.print("첫 번째 정수 입력 : ");
		num1 = Integer.parseInt(br.readLine());
		
		System.out.print("두 번째 정수 입력 : ");
		num2 = Integer.parseInt(br.readLine());
		
		System.out.print("연산자 입력[+ - * /] : ");
		op = (char)System.in.read();
		
		if (op == '+')
		{
			res = num1 + num2;
			System.out.printf(">> %d %c %d = %d%n",num1,op,num2,res);
			 
		}
		else if (op == '-')
		{
			res = num1 - num2;
			System.out.printf(">> %d %c %d = %d%n",num1,op,num2,res);
						
		}
		else if (op == '*')
		{
			res = num1 * num2;
			System.out.printf(">> %d %c %d = %d%n",num1,op,num2,res);
			
		}
		else if (op == '/')
		{
			res = num1 / num2;
			System.out.printf(">> %d %c %d = %d%n",num1,op,num2,res);
		}
		else
		{
			System.out.println("올바른 값을 넣으세요");
		}	
		
	}
}
// 실행결과
/*
첫 번째 정수 입력 : 12
두 번째 정수 입력 : 34
연산자 입력[+ - * /] : +

>> 12 + 34 = 46
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 34
두 번째 정수 입력 : 22
연산자 입력[+ - * /] : -

>> 34 - 22 = 12
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 12
두 번째 정수 입력 : 4
연산자 입력[+ - * /] : *

>> 12 * 4 = 48
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 50
두 번째 정수 입력 : 10
연산자 입력[+ - * /] : /

>> 50 / 10 = 5
계속하려면 아무 키나 누르십시오 . . .
*/

// 나의 결과
/*
첫 번째 정수 입력 : 5
두 번째 정수 입력 : 8
연산자 입력[+ - * /] : +
>> 5 + 8 = 13
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 48
두 번째 정수 입력 : 36
연산자 입력[+ - * /] : -
>> 48 - 36 = 12
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 72
두 번째 정수 입력 : 6
연산자 입력[+ - * /] : *
>> 72 * 6 = 432
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 280
두 번째 정수 입력 : 7
연산자 입력[+ - * /] : /
>> 280 / 7 = 40
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// 사용자로부터 임의의 정수 세 개를 입력받아
// 작은 수에서 큰 수 순으로 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 10
// 두 번째 정수 입력 : 370
// 세 번째 정수 입력 : 26

// >> 정렬 결과 : 10 26 370
// 계속하려면 아무 키나 누르세요...

// ① 첫 번째 정수 vs 두 번째 정수 크기 비교
//    → 첫 번째 정수가 두 번째 정수보다 클 경우... 자리바꿈
		
// ② 첫 번째 정수 vs 세 번째 정수 크기 비교
//    → 첫 번째 정수가 세 번째 정수보다 클 경우... 자리바꿈
		
// ③ 두 번째 정수 vs 세 번째 정수 크기 비교
//    → 두 번째 정수가 세 번째 정수보다 클 경우... 자리바꿈
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test036
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a, b, c;                  //-- 사용자가 입력하는 임의의 정수를 담아둘 변수
		// int temp;                  //-- 임시 저장 변수
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		System.out.print("세 번째 정수 입력 : ");
		c = Integer.parseInt(br.readLine());
		
		//테스트 (확인)
		System.out.printf("\n>> 입력확인 : %d %d %d\n",a,b,c);
		
		// ① 첫 번째 정수가 두 번째 정수보다 클 경우... 자리바꿈
		if (a > b)
		{
			//자리 바꿈
			/*
			temp = a;
			a = b;
			b = temp;
			*/
			a = a^b;
			b = b^a;
			a = a^b;
		}
        // ② 첫 번째 정수가 세 번째 정수보다 클 경우... 자리바꿈
		if (a > c)
		{
			// 자리 바꿈
			/*
			temp = a;
			a = c;
			c = temp;
			*/
			a = a^c;
			c = c^a;
			a = a^c;
		}
        // ③ 두 번째 정수가 세 번째 정수보다 클 경우... 자리바꿈
		if (b > c)
		{
			// 자리 바꿈
			/*
			temp = b;
			b = c;
			c = temp;
			*/
			b = b^c;
			c = c^b;
			b = b^c;
		}
		
		// 결과 확인
		
		System.out.printf("\n>> 정렬 결과 : %d %d %d\n",a,b,c);
		
		
		//나의 풀이
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a,b,c;
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		System.out.print("세 번째 정수 입력 : ");
		c = Integer.parseInt(br.readLine());
		
		if (a<=b && a<=c && b<=c)
			System.out.printf("\n>> 정렬 결과 : %d %d %d\n",a,b,c);
		else if (a<=b && a<=c && b>=c)
			System.out.printf("\n>> 정렬 결과 : %d %d %d\n",a,c,b);
		else if (a>=b && b<=c && a<=c)
			System.out.printf("\n>> 정렬 결과 : %d %d %d\n",b,a,c);
		else if (a>=b && b<=c && a>=c)
			System.out.printf("\n>> 정렬 결과 : %d %d %d\n",b,c,a);
		else if (a<=b && b>=c && a>=c)
			System.out.printf("\n>> 정렬 결과 : %d %d %d\n",c,a,b);
		else if (a>=b && b>=c && a>=c)
			System.out.printf("\n>> 정렬 결과 : %d %d %d\n",c,b,a);
		else
			System.out.println("입력 오류");
		*/
		
	}
}
// 실행 결과
/*
첫 번째 정수 입력 : 360
두 번째 정수 입력 : 140
세 번째 정수 입력 : 12

>> 입력확인 : 360 140 12

>> 정렬 결과 : 12 140 360
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 43
두 번째 정수 입력 : 12
세 번째 정수 입력 : 56

>> 입력확인 : 43 12 56

>> 정렬 결과 : 12 43 56
계속하려면 아무 키나 누르십시오 . . .
*/



//나의 결과
/*
첫 번째 정수 입력 : 15
두 번째 정수 입력 : 30
세 번째 정수 입력 : 48

>> 정렬 결과 : 15 30 48
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 5
두 번째 정수 입력 : 43
세 번째 정수 입력 : 10

>> 정렬 결과 : 5 10 43
계속하려면 아무 키나 누르십시오 . . .
*/
/*
첫 번째 정수 입력 : 120
두 번째 정수 입력 : 72
세 번째 정수 입력 : 33

>> 정렬 결과 : 33 72 120
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/


// 사용자로부터 임의의 정수 5개를 입력받아
// 짝수별, 홀수별 합계를 출력한느 프로그램을 구현한다.
// 단, Scanner 를 활용하여 데이터를 입력받을 수 있도록 한다.

// 실행 예)
// 임의의 정수 5개 입력(공백 구분) : 1 2 3 4 5

//  >> 짝수의 합은 6, 홀수의 합은 9 입니다.
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;

public class Test037
{
	public static void main(String[] args)
	{
		
		// 주요 변수 선언
		Scanner sc = new Scanner(System.in);
		
		int num1, num2, num3, num4, num5;    //-- 사용자로부터 입력받는 다섯 개의 정수를 담아둘 변수
		int even=0;                            //-- 짝수의 누적 합을 담아낼 변수 선언
		int odd=0;                             //-- 홀수의 누적 합을 담아낼 변수 선언
		
		// ※ 누적합을 담아낼 변수에 대한 초기화 check!
		// 연산 및 처리
		System.out.print("임의의 정수 5개 입력(공백 구분) : ");          // 1 2 3 4 5 
		// num1 = Integer.parseInt(sc.next());
		num1 = sc.nextInt();
		num2 = sc.nextInt();
		num3 = sc.nextInt();
		num4 = sc.nextInt();
		num5 = sc.nextInt();
		
		if (num1%2==0)  // num1이 짝수일 때
			//even을 num1만큼 증가
			even += num1;
		else       // num1이 홀수일 때
			//odd를 num1만큼 증가
			odd += num1;
			
		if (num2%2==0)
			even += num2;
		else       
			odd += num2;
			
		if (num3%2==0)  
			even += num3;
		else    
			odd += num3;
			
		if (num4%2==0)  
			even += num4;
		else
			odd += num4;
			
		if (num5%2==0)  
			even += num5;
		else 
			odd += num5;

		
		// 결과 출력
		System.out.printf("\n>> 짝수의 합은 %d, 홀수의 합은 %d 입니다\n",even,odd);
		
		
		
		// 나의 풀이
		/*
		Scanner sc = new Scanner(System.in);
		
		int a, b, c, d, e;
		int Tot1 = 0,Tot2 = 0;
		
		System.out.print("임의의 정수 5개 입력(공백 구분) : ");
		a = sc.nextInt();
		b = sc.nextInt();
		c = sc.nextInt();
		d = sc.nextInt();
		e = sc.nextInt();
		
		if (a % 2 == 0)
		{
			Tot1 += a;
		}
		else 
		{
			Tot2 += a;
		}
		if (b % 2 == 0)
		{
			Tot1 += b;
			
			// Tot1 = Tot1 + b;
		}
		else 
		{
			Tot2 += b;
		}
		if (c % 2 == 0)
		{
			Tot1 += c;
		}
		else 
		{
			Tot2 +=  c;
		}
		if (d % 2 == 0)
		{
			Tot1 +=  d;
		}
		else 
		{
			Tot2 +=  d;
		}
		if (e % 2 == 0)
		{
			Tot1 += e;
		}
		else 
		{
			Tot2 += e;
		}
		
		System.out.printf("\n>> 짝수의 합은 %d, 홀수의 합은 %d\n",Tot1,Tot2);
		*/
			
	}
}
// 실행 결과
/*
임의의 정수 5개 입력(공백 구분) : 11 22 33 44 55

>> 짝수의 합은 66, 홀수의 합은 99 입니다
계속하려면 아무 키나 누르십시오 . . .
*/


// 나의 실행 결과
/*
임의의 정수 5개 입력(공백 구분) : 11 12 13 14 15

>> 짝수의 합은 26, 홀수의 합은 39
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// ○ 과제
//    사용자로부터 임의의 알파벳 한 문자를 입력받아 이를 판별하여
//    입력받은 알파벳이 모음일 경우만 결과를 출력하는 프로그램을 구현한다.
//    단, 대소문자를 모두 적용할 수 있도록 처리한다.
//    또한, 알파벳 이외의 문자가 입력되었을 경우
//    입력 오류에 대한 내용을 사용자에게 안내해 줄 수 있도록 한다.

// 실행 예)
// 임의의 알파벳 한 문자 입력 : A        //-- (대문자 모음)
// >>  모음 OK~!!!
// 계속하려면 아무 키나 누르세요...

// 임의의 알파벳 한 문자 입력 : a        //-- (소문자 모음) 
// >>  모음 OK~!!!
// 계속하려면 아무 키나 누르세요...

// 임의의 알파벳 한 문자 입력 : B        //-- (모음 아님)
// 계속하려면 아무 키나 누르세요...

// 임의의 알파벳 한 문자 입력 : 5        //-- (알파벳 아님)
// >> 입력 오류~!!
// 계속하려면 아무 키나 누르세요...


import java.io.IOException;

public class Test038
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언
	    char a;              // 입력받을 변수 선언
		
		// 연산 및 처리
		System.out.print("임의의 알파벳 한 문자를 입력 : ");   
		a = (char)System.in.read();                  
		
		if (a == 65 || a == 69 || a == 73 || a == 79 || a == 85 || a == 97 || a == 101 || a == 105 || a == 111 || a == 117)  // 알파벳 모음 (대문자,소문자)
		{
			System.out.println("\n>> 모음 OK~!!!\n");                                                                        // 결과 출력
		}
		else if ((a>=65 && a<=90) || (a>=97 && a<=122))                                                                      // 모음이 아닌 알파벳
		{
			System.out.println("");                                                                                          // 결과 출력
		}
		else
			System.out.println(">> 입력 오류~!!");		                                                                     // 기타 문자 결과 출력
	}
}
// 실행 결과
// 대문자 모음
/*
임의의 알파벳 한 문자를 입력 : E

>> 모음 OK~!!!

계속하려면 아무 키나 누르십시오 . . .
*/

// 소문자 모음
/*
임의의 알파벳 한 문자를 입력 : e

>> 모음 OK~!!!

계속하려면 아무 키나 누르십시오 . . .
*/

// 모음 아님
/*
임의의 알파벳 한 문자를 입력 : b

계속하려면 아무 키나 누르십시오 . . .
*/

// 기타 문자
/*
임의의 알파벳 한 문자를 입력 : 5
>> 입력 오류~!!
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 실행 흐름의 컨트롤 (제어문) ■■■
- if 문
- if ~ else 문 실습
=============================================*/

// ○ 과제
//    사용자로부터 임의의 문자 하나를 입력받아
//    대문자이면 소문자로, 소문자이면 대문자로
//    알파벳이 아닌 기타 문자이면 입력 오류 처리하는 프로그램을 구현한다.

// 실행 예)
// 한 문자 입력 : A
// >> A → a
// 계속하려면 아무 키나 누르세요...

// 한 문자 입력 : b
// >> b → B
// 계속하려면 아무 키나 누르세요...

// 한 문자 입력 : 3
// >> 입력 오류~!!
// 계속하려면 아무 키나 누르세요...


import java.io.IOException;

public class Test039
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언
		char ch;                              // 입력할 문자 변수 선언
		
		// 연산 및 처리
		System.out.print("한 문자 입력 : ");      
		ch = (char)System.in.read();          // 문자를 입력받는다.
		
		if (ch>=65 && ch<=90)                                          // 대문자인 경우                                
			System.out.printf("\n>> %c → %c\n",ch,(char)(ch + 32));    
		else if (ch>=97 && ch<=122)                                    // 소문자인 경우
			System.out.printf("\n>> %c → %c\n",ch,(char)(ch - 32));
		else
			System.out.println("\n>> 입력 오류~!!!");                  // 알파벳이 아닌 경우
	}
}
// 실행 결과
/*
한 문자 입력 : B

>> B → b
계속하려면 아무 키나 누르십시오 . . .
*/

/*
한 문자 입력 : g

>> g → G
계속하려면 아무 키나 누르십시오 . . .
*/

/*
한 문자 입력 : 6

>> 입력 오류~!!!
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- switch 구문
===========================================*/

/*
○ 다중 선택문이라 하며, .switch 문 다음의 수식 값에 따라
   실행 순서를 여러 방향으로 분기할떄 사용하는 문장이다.

○ 형식 구조
   switch (수식)
   {
	   case 상수1 : 문장1; [break;]
	   case 상수2 : 문장2; [break;]
	   case 상수3 : 문장3; [break;]
	   
	   [default : 문장n+1; [break;]]
   }
   
   switch 문의 『수식』과 『case』의 상수는
   byte, short, int, long 형이어야 한다.
   + 『문자 타입(char)』
   + 『문자열 타입(String)』	
   
   case 문 뒤에 『break;』 가 없는 형태인 경우
   다음 case 문의 문장을 계속해서(이어서) 수행하게 된다. (→ 기본 모델)
   『break;』 가 존재할 경우
   해당 지점에서 수행을 멈춘 후 switch 문을 빠져나간다.  (→ 일반 모델)
*/
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test040
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		String name;                //-- 이름
		int kor, eng, mat, tot;     //-- 국어점수, 영어점수, 수학점수, 총점
		//double avg;                 
		int avg;                    //-- 평균
		
		// char grade;                 //-- 등급
		char grade = 'F';
		
		System.out.print("이름 입력 : ");
		name = br.readLine();
		
		System.out.print("국어점수 입력 : ");
		kor = Integer.parseInt(br.readLine());
		
		System.out.print("영어점수 입력 : ");
		eng = Integer.parseInt(br.readLine());
		
		System.out.print("수학점수 입력 : ");
		mat = Integer.parseInt(br.readLine());
		
		tot = kor + eng + mat;
		// avg = tot / 3.0;
		avg = tot / 3;
		/*
		if (avg>=90)
		{
			grade = 'A';
		}
		else if (avg>=80)
		{
			grade = 'B';
		}
		else if (avg>=70)
		{
			grade = 'C';
		}
		else if (avg>=60)
		{
			grade = 'D';
		}
		else
			grade = 'F';
		*/
		/*
		switch (avg/10)
		{
			case 10: grade='A'; break;
			case  9: grade='A'; break;
			case  8: grade='B'; break;
			case  7: grade='C'; break;
			case  6: grade='D'; break;
			case  5: grade='F'; break;
			case  4: grade='F'; break;
			case  3: grade='F'; break;
			case  2: grade='F'; break;
			case  1: grade='F'; break;
			case  0: grade='F'; break;
		}
		*/
		/*
		switch (avg/10)
		{
			case 10: grade='A'; break;
			case  9: grade='A'; break;
			case  8: grade='B'; break;
			case  7: grade='C'; break;
			case  6: grade='D'; break;
			default : grade = 'F';
		}
		*/
		
		switch (avg/10)
		{
			case 10: case  9: grade='A'; break;
			case  8: grade='B'; break;
			case  7: grade='C'; break;
			case  6: grade='D'; break;
			// default : grade = 'F';               // default를 사용하지 않으면 에러 발생 → 변수 char grade = 'F' 해줘야지 없어도 에러 발생 안한다.
		}
		
		
		// 나의 풀이
		/*
		switch (avg/10)
		{
		case 10: grade = 'A'; break;	
		case 9 : grade = 'A'; break;
		case 8 : grade = 'B'; break;
		case 7 : grade = 'C'; break;
		case 6 : grade = 'D'; break;
		default : grade = 'F';
		}
		*/
		
		
		System.out.println();
		System.out.printf(">> 당신의 이름은 %s 입니다.\n",name);
		//System.out.printf(">> 총점은 %d, 평균은 %.2f 입니다.\n",tot,avg);
		System.out.printf(">> 총점은 %d, 평균은 %d 입니다.\n",tot,avg);
		System.out.printf(">> 등급은 %c 입니다.\n",grade);
	
	}
}
// 실행 결과
// if 문
/*
이름 입력 : 윤영식
국어점수 입력 : 90
영어점수 입력 : 80
수학점수 입력 : 70

>> 당신의 이름은 윤영식 입니다.
>> 총점은 240, 평균은 80 입니다.
>> 등급은 B 입니다.
계속하려면 아무 키나 누르십시오 . . .
*/

// switch 문/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- switch 구문
===========================================*/


// 사용자로부터 1 부터 3까지의 정수중 하나를 입력받아
// 입력받은 정수만큼의 별문자(★)가 출력되는 프로그램을 작성한다
// 단, 두 가지 방법으로 구현할 수 있도록 한다.

// ① switch 문의 일반 모델을 사용하여 구현한다.
// ② switch 문의 기본 모델을 사용하되, 
//   『break』 를 딱 한번만 사용할수 있도록 한다.

// 실행 예)
// 임의의 정수 입력(1~3) : 3
// ★★★
// 계속하려면 아무 키나 누르세요...

// 실행 예)
// 임의의 정수 입력(1~3) : 1
// ★
// 계속하려면 아무 키나 누르세요...

// 실행 예)
// 임의의 정수 입력(1~3) : 7
// 입력 오류~!!!
// 계속하려면 아무 키나 누르세요...
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test041
{
	public static void main(String[] args) throws IOException
	{
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		
		int n;
		System.out.print("임의의 정수 입력(1~3) : ");
		n = Integer.parseInt(br.readLine());
		
		// ①
		/*
		switch (n)
		{
			case 1: System.out.println("★"); break;
			case 2: System.out.println("★★"); break;
			case 3:  System.out.println("★★★"); break;
			default : System.out.println("입력 오류~!!!");
		}
		*/
		
		// ②
		switch (n)
		{
			default : System.out.print("입력 오류~!!!");
			          break;
			case 3: System.out.print("★");
			case 2: System.out.print("★");
			case 1: System.out.print("★");
		}
		System.out.println();
		
		
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a;
		String str = new String();
		
		System.out.print("임의의 정수 입력(1~3) : ");
		a = Integer.parseInt(br.readLine());
		*/
		/*
		switch (a)
		{
			case 3: str = "★★★"; break;
			case 2: str = "★★"; break;
			case 1: str = "★"; break;
			default : str = "입력 오류~!!!";
		}
		*/
		/*
		switch (a)
		{
			case 3: str = "★"; 
			case 2: str += "★";
			case 1: str += "★"; break;
			default: str = "입력 오류~!!!";
		}
		
		System.out.printf("\n%s\n",str);
		*/
	}
}
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- switch 구문
===========================================*/

// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산자의 연산 처리 결과를 출력하는 프로그램을 구현한다.
// 단, switch 문을 활용하여 처리할 수 있도록 하며,
// 연산 결과는 편의상 정수 형태로 처리할 수 있도록 한다.

// 실행 예)
// 첫번째 정수 입력 : 3
// 첫번째 정수 입력 : 3
// 연산자 입력[+ - * /] : +

//>> 3 + 12 = 15
//계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;


public class Test042
{
	public static void main(String[] args) throws IOException
	{
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a,b,result;
		int op;
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		System.out.print("연산자 입력[+ - * /] : ");
		op = System.in.read();
		
		// '+' → op:43, '-' → op:45, '*' → op:42, '/' → op:47
		
		switch (op)
		{
			case 43:result = a + b; break;
			case 45:result = a - b; break;
			case 42:result = a * b; break;
			case 47:result = a / b; break;
			default: return;               // 1. 값을 반환 
			                               // 2. return;을 포함되어 있는 메소드 종료 → main() 메소드 종료 → 프로그램 종료
		}
		
		System.out.println();
		System.out.printf(">> %d %c %d = %d\n",a,op,b,result);
		*/
		
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a,b,result;
		// int op;
		char op;
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		System.out.print("연산자 입력[+ - * /] : ");
		// op = System.in.read();
		op = (char)System.in.read();
		
		// '+' → op:43, '-' → op:45, '*' → op:42, '/' → op:47
		
		switch (op)
		{
			case '+':result = a + b; break;
			case '-':result = a - b; break;
			case '*':result = a * b; break;
			case '/':result = a / b; break;
			default: return;               // 1. 값을 반환 
			                               // 2. return;을 포함되어 있는 메소드 종료 → main() 메소드 종료 → 프로그램 종료
		}
		
		System.out.println();
		System.out.printf(">> %d %c %d = %d\n",a,op,b,result);
		*/
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a,b,result;
		// char op;
		String op;
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		System.out.print("연산자 입력[+ - * /] : ");
		// op = (char)System.in.read();
		op = br.readLine();
		
		// '+' → op:43, '-' → op:45, '*' → op:42, '/' → op:47
		
		switch (op)
		{
			// case '+':result = a + b; break;
			case "+":result = a + b; break;
			// case '-':result = a - b; break;
			case "-":result = a - b; break;
			// case '*':result = a * b; break;
			case "*":result = a * b; break;
			// case '/':result = a / b; break;
			case "/":result = a / b; break;
			default: return;               // 1. 값을 반환 
			                               // 2. return;을 포함되어 있는 메소드 종료 → main() 메소드 종료 → 프로그램 종료
		}
		
		System.out.println();
		// System.out.printf(">> %d %c %d = %d\n",a,op,b,result);
		System.out.printf(">> %d %s %d = %d\n",a,op,b,result);
		
		
		// 나의 풀이
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a, b, result = 0;
		char op;
		
		System.out.print("첫 번째 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		b = Integer.parseInt(br.readLine());
		System.out.print("연산자 입력[+ - * /] : ");
		op = (char)System.in.read();
		
		
		switch (op)
		{
		case '+':result = a + b; break;
		case '-':result = a - b; break;
		case '*':result = a * b; break;
		case '/':result = a / b; break;
		}
		System.out.printf("\n%d %c %d = %d\n",a,op,b,result);
		*/
	}
}
//실행 결과
/*
첫 번째 정수 입력 : 30
두 번째 정수 입력 : 20
연산자 입력[+ - * /] : -

>> 30 - 20 = 10
계속하려면 아무 키나 누르십시오 . . .
*/

/*
첫 번째 정수 입력 : 30
두 번째 정수 입력 : 20
연산자 입력[+ - * /] : )
계속하려면 아무 키나 누르십시오 . . .
*/

/*
첫 번째 정수 입력 : 50
두 번째 정수 입력 : 10
연산자 입력[+ - * /] : /

>> 50 / 10 = 5
계속하려면 아무 키나 누르십시오 . . .
*/

/*
첫 번째 정수 입력 : 30
두 번째 정수 입력 : 20
연산자 입력[+ - * /] : +

>> 30 + 20 = 50
계속하려면 아무 키나 누르십시오 . . .
*/
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- switch 구문
===========================================*/

// 사용자로부터 임의의 연도와 월을 입력받아
// 해당 월의 마지막 날짜를 확인할 수 있는 프로그램을 구현한다.

// 실행 예)
// 임의의 연도를 입력하세요 : 2024
// 임의의 월을 입력하세요   : 2

// >> 2024년 2월은 29일까지 있습니다.
// 계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test043
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		// int y,m,d;							//-- 연,월,일
		int y,m,d=-1;
		
		// 연산 및 처리
		System.out.print("임의의 연도를 입력하세요 : ");
		y = Integer.parseInt(br.readLine());
		
		System.out.print("임의의 월를 입력하세요   : ");
		m = Integer.parseInt(br.readLine());
		
		switch (m)
		{
			/*
			case 1: d = 31; break;
			case 2: d = 0; break;
			case 3: d = 31; break;
			case 4: d = 30; break;
			case 5: d = 31; break;
			case 6: d = 30; break;
			case 7: d = 31; break;
			case 8: d = 31; break;
			case 9: d = 30; break;
			case 10: d = 31; break;
			case 11: d = 30; break;
			case 12: d = 31; break;
			*/
			
			case 1: case 3: case 5: case 7: case 8: case 10: case 12: d = 31; break;
			case 4: case 6: case 9: case 11: d = 30; break;
			case 2: 
				if (y%4==0 && y%100!=0 || y%400==0)
				{
					d=29;
				}
				else
				{
					d = 28;
				}
				break;
			// default: return;
			// default: d=-1; break;
		}
		
		if (d!=-1)
		{
			// 정상적인 결과 처리
			System.out.println("\n>>" + y + "년" + m + "월은" + d + "일까지 있습니다.");
		}
		else
		{
			System.out.println("\n>> 입력 오류~!!!");
		}
		
		
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int year = 0,month = 0;
		int day = 0;
		
		System.out.print("임의의 연도를 입력하세요 : ");
		year = Integer.parseInt(br.readLine());
		System.out.print("임의의 월을 입력하세요   : ");
		month = Integer.parseInt(br.readLine());
		

		switch (month)
		{
			case 2:
				if (year % 2 == 0 && year % 100 != 0 || year % 400 == 0)
					day = 29;
			    else
					day = 28; break;
			case 1: case 3: case 5: case 7: case 8: case 10: case 12: day = 31; break;
			case 4: case 6: case 9: case 11: day = 30; break;
			default : return;
		}
		
		System.out.printf("\n>> %d년 %d월은 %d일까지 있습니다.\n",year,month,day);
		*/
	}
}

/*
임의의 연도를 입력하세요 : 2024
임의의 월를 입력하세요   : 2

>>2024년2월은29일까지 있습니다.
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도를 입력하세요 : 2025
임의의 월를 입력하세요   : 2

>>2025년2월은28일까지 있습니다.
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도를 입력하세요 : 2024
임의의 월를 입력하세요   : 10

>>2024년10월은31일까지 있습니다.
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 연도를 입력하세요 : 2024
임의의 월를 입력하세요   : 11

>>2024년11월은30일까지 있습니다.
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문 실습 및 관찰
===========================================*/

/*
○ 반복문의 개요

	주어진 조건이 『참(true)』인 경우
	일정한 영역의 문장을 반복 수행하다가
	조건식이 『거짓(false)』이 된는 순간이 오면,
	반복 수행을 중단하는 문장이다.
	이러한 반복문에는 『while』, 『do~while』, 『for』 문 등이 있으며
	반복의 제어를 위해 『break』, 『continue』문을 
	사용하는 경우가 있다.
	
○ while 문

	조건식을 먼저 비교하여
	조건식의 처리결과가 참인 경우, 특정 영역을 반복 수행하는 문장으로
	반복의 횟수가 정해져 있지 않은 경우나
	반복 횟수가 많은 경우 주로 사용한다.
	while문은 조건이 맞지 않은 경우
	반복은 커녕 단 한 번도 실행되지 않을 수 있다
	
○ while 문의 형식 및 구조

	while (조건식)
	{
		실행문;
	}
*/

public class Test044
{
	public static void main(String[] args)
	{
		/*
		int n=0;
		
		while (n<=10)
		{
			System.out.println("n=" + n);
			n++;
		}
		*/
		
		/*
		int n=0;
		
		while (n<=10)
		{
			n++;
			System.out.println("n=" + n);
		}
		*/
		
		/*
		int n=0;
		
		while (n++<=10)
		{
			System.out.println("n=" + n);
		}
		*/
		
		/*
		int n=0;
		
		while (++n<=10)
		{
			System.out.println("n=" + n);
		}
		*/
	    
		/*
		int n=0;
		
		while (n++<=10)
		{
			System.out.println("n=" + ++n);
		}
		*/
		
		/*
		int n=1;
		
		while (n<10)
		{
			System.out.println("n=" + n);
			n++;
		}
		*/
		
		// 1부터 100 까지의 합을 계산하여
		// 결과를 출력하는 프로그램을 구현한다.
		// 단, while 반복문을 활용한다.
		
		// 실행 예)
		// 1부터 100까지의 합 : xxxx
		// 계속하려면 아무 키나 누르세요...
		
		// ※ 문제 인식 및 분석
		//	  1. 출력 구문이 반복문의 영역 밖에 위치해야 한다.
		//    2. 1부터 1씩 증가할 변수와 누적합을 담을 변수
		//		 이렇게 두 개의 변수가 필요하다.
		
		// 1부터 차례로 담아 1씩 증가하는 변수 선언 및 초기화
		// int n = 1;
		int n = 0;
		
		// 누적합을 계산하여 담아낼 변수 선언 및 초기화
		int sum=0;
		
		// 연산 및 처리(반복문 구성)
		while (n<100)              // 0 1 2 3... 99
		{
			// 을 1만큼 증가
			n++;                   // 1 2 3 4... 100
			
			// sum 을 n만큼씩 증가
			sum += n;              // ??? += 100;
			
		}
		
		// 결과 출력
		System.out.println("1부터 100까지의 합 : " + sum);
		
		
		
		// 나의 풀이	
		/*
		int n = 1, res = 0;
		
		while (n<=100)
		{
			res += n;
			n++;
		}
		
		System.out.printf("1부터 100까지의 합 : %d\n",res);
		*/
	}
}
/*
1부터 100까지의 합 : 5050
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문 실습 및 관찰
===========================================*/

// 1부터 100까지의 정수 중에서
// 짝수들의 합을 계산하여 결과값을 출력하는 프로그램을 구현한다.
// 단 조건문을 사용하지 않도록 하며
// while 반복문을 활용하여 처리할 수 있도록 한다.

// 실행 예)
// 1부터 100까지의 수중 짝수의합 : xxxx

// ※ 문제 인식 및 분석
//    2 + 4 + 6 + 8 ... + 100
//    초기값 : 2
//    증가값 : 2
//    한계값 : 100
public class Test045
{
	public static void main(String[] args)
	{
		
		// 주요 변수 선언 및 초기화
		int n = 2;
		int sum = 0;
		
		// 연산 및 처리 ( 반복 연산 → 누적합 산출)
		while (n<=100)      // n → 2 4 6 8 ... 100
		{
			// sum 을 n만큼 증가
			sum += n;
			
			// n을 2만큼 증가
			n += 2;
		}
		
		// 결과 출력
		System.out.println("1부터 100 까지의 수 중 짝수의합 : " + sum);
		
		
		/*
		// 결과 출력
		
		int n=2, sum=0;
		
		while (n<100)
		{
			sum += n;			
		}
		System.out.println("1부터 100까지의 수 중 짝수의합 : " + sum);
		*/
	}
}
//실행 결과

/*
1부터 100 까지의 수 중 짝수의합 : 2550
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문 실습 및 관찰
===========================================*/

// 1부터 100까지의 정수중에서
// 짝수들의 합과 홀수들의 합을 따로 구분하여 계산한다.
// 그리고 결과값을 출력하는 프로그램을 구현한다.
// 단 반복문은 while문을 사용할 수 있도록 하며,
// 조건 구문은  if 조건문을 사용하여 작성할 수 있도록 한다.

// 실행 예)
// 1부터 100까지의 정수 중
// 짝수의 합 : xxxx
// 홀수의 합 : xxxx
public class Test046
{
	public static void main(String[] args)
	{
		
		// 주요 변수 선언 및 초기화
		int n = 1;                //-- 1부터 100까지 1씩 증가할 변수
		int even = 0;			  //-- 짝수들의 누적합을 담아낼 변수
		int odd = 0;			  //-- 홀수들의 누적합을 담아낼 변수	
		
		// 연산 및 처리(반복 연산 → 누적합 산출) 
		while (n<=100)
		{
			if (n % 2 == 0) // n이 짝수일 경우
			{
				// even 에 누적합 연산
				even += n;
			}
			else if (n % 2 != 0) // n이 홀수일 경우
			{
				// odd에 누적합 연산
				odd += n;
			}
			else
			{
				System.out.println("판별 불가 데이터~!!!");
				return;		//-- 메소드 종료 → main() 메소드 종료 → 프로그램 종료
			}
			
			n++;
		}
		
		//결과 출력
		System.out.println("1부터 100 까지의 정수 중");
		System.out.println("짝수의 합 : " + even);
		System.out.println("홀수의 합 : " + odd);
	
		
		
		
		
		/*
		int n = 1, sum1 = 0, sum2 = 0;
		
		while (n<=100)
		{
			if (n % 2 == 0)
			{
				sum1 += n;
			}
			else
			{
				sum2 += n;
			}
			n++;
		}
		
		System.out.println("1부터 100까지의 정수 중");
		System.out.printf("짝수의 합 : %d\n",sum1);
		System.out.printf("홀수의 합 : %d\n",sum2);
		*/
	}
}
/*
1부터 100 까지의 정수 중
짝수의 합 : 2550
홀수의 합 : 2500
계속하려면 아무 키나 누르십시오 . . .*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문 실습 및 관찰
===========================================*/

// 실행 예)
// 1부터 100까지 정수의 합 : 5050
// 1부터 100까지 짝수의 합 : 2550
// 1부터 100까지 홀수의 합 : 2500
// 계속하려면 아무 키나 누르세요...
public class Test047
{
	public static void main(String[] args)
	{
		// 주요 변수 선언 및 초기화
		// int n=1, sum=0, odd=0, even=0;
		int n=1, sum, odd, even;
		sum=odd=even=0;
		
		// 연산 및 처리
		while (n<=100)
		{
			sum +=n;
			
			if (n%2==0)
			{
				even += n;
			}
			else if (n%2!=0)
			{
				odd += n;
			}
			else
			{
				System.out.println("판별 불가 데이터");
				return;
			}
			
			n++;
		}
		
		//결과 출력
		System.out.println("1부터 100까지 정수의 합 : " + sum);
		System.out.println("1부터 100까지 짝수의 합 : " + even);
		System.out.println("1부터 100까지 홀수의 합 : " + odd);
		
		
		/*
		int n = 1;
		int tot = 0;
		int even = 0;
		int odd = 0;
		
		while (n<=100)
		{
			tot += n;
			
			if (n % 2 ==0)
			{
				even += n;
			}
			else if (n % 2 != 0)
			{
				odd +=n;
			}
			else
				return;
			
			n++;
		}
		
		System.out.println("1부터 100까지 정수의 합 : " + tot);
		System.out.println("1부터 100까지 짝수의 합 : " + even);
		System.out.println("1부터 100까지 홀수의 합 : " + odd);
		*/
		
	}
}

// 실행 결과
/*
1부터 100까지 정수의 합 : 5050
1부터 100까지 짝수의 합 : 2550
1부터 100까지 홀수의 합 : 2500
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 1부터 100까지 정수의 합을 구하되...
// 10의 배수가 될때 마다...
// 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 1~10 까지의 합 : XX
// 1~20 까지의 합 : XXX
// 1~30 까지의 합 : XXX
// 1~40 까지의 합 : XXX
//        :
// 1~100 까지의 합 : XXX
// 계속하려면 아무 키나 누르세요...

public class Test048
{
	public static void main(String[] args)
	{
		int n = 1, sum = 0;  //-- n → 1부터 1씩 증가할 변수
					         //-- sum → 누적합을 담아낼 변수
		
		while (n<=100)	//-- 12345...100 → 100번 반복
		{
			// 테스트 (확인)
			// System.out.println("n=" + n +", sum=" + sum);
			sum += n;   //-- sum 을 n 만큼씩 증가
			
			// 테스트 (확인)
			// System.out.println("n=" + n +", sum=" + sum);
			
			if (n%10==0)	// n 이 10 의 배수일 경우
			{
				// 출력
				// System.out.println("n=" + n);
				// System.out.println("sum=" + sum);
				System.out.printf("1 ~ %d 까지의 합 : %d\n",n,sum);
			}
									
			n++;        //-- n을 1만큼씩 증가
			
			// 테스트 (확인)
			// System.out.println("n=" + n +", sum=" + sum);
		}
		System.out.println("1부터 100까지의 합 : " + sum);
		
		/*
		int n = 1, sum =0;
		
		while (n<=100)
		{
			sum += n;
			
			if (n%10==0)
			{
				System.out.printf("1 ~ %d 까지의 합 : %d\n",n,sum);
			}
			n++;
		}
		*/
	}
}

// 실행 결과

/*
1 ~ 10 까지의 합 : 55
1 ~ 20 까지의 합 : 210
1 ~ 30 까지의 합 : 465
1 ~ 40 까지의 합 : 820
1 ~ 50 까지의 합 : 1275
1 ~ 60 까지의 합 : 1830
1 ~ 70 까지의 합 : 2485
1 ~ 80 까지의 합 : 3240
1 ~ 90 까지의 합 : 4095
1 ~ 100 까지의 합 : 5050
1부터 100까지의 합 : 5050
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 1 + (1+2) + (1+2+3) + (1+2+3+4) + .... + (1+2+3+...+10)

// 의 연산 처리 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 연산 결과 : xxxx
// 계속하려면 아무 키나 누르세요...

public class Test049
{
	public static void main(String[] args)
	{
		int n = 0;
		int s1 = 0, s2 = 0;
		
		while (n<10)
		{
			n++;
			s1 += n;
			s2 += s1;
		}
		System.out.println("연산 결과 : " + s2);
		
		/*
		int n = 1, sum1 = 0, sum2 = 0;
		
		while (n<=10)
		{
			sum1 += n;
			n++;
			sum2 += sum1;
		}
		System.out.println("연산 결과 : " + sum2);
		*/
	}
}

// 실행 결과

/*
연산 결과 : 220
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 1/2 + 2/3 + 3/4 + ... + 9/10
// 의 연산을 실수 기반으로 처리하여 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 연산 결과 : xxx
// 계속하려면 아무 키나 누르세요...

/*

	n → 1 ~ 9 (→ 0 ~ 8)	
	|
	1/2 + 2/3 + 3/4 + ... + 9/10
	  |
	(n+1)
	
  (n-1)
	|
	1/2 + 2/3 + 3/4 + ... + 9/10
	  |
	  n → 2 ~ 10 (→ 1 ~ 9)
*/
public class Test050
{
	public static void main(String[] args)
	{
		// 주요 변수 선언 및 초기화
		int n =0;			//-- 1부터 1씩 증가하게 될 변수
		double sum=0;		//-- 누적합을 담아낼 변수
							// → 실수 기반 연산 → 실수 형태로 처리
		
		// 연산 및 처리
		while (n<9)			//-- n → 0 1 2 3 4 5 6 7 8
		{
			// 증감식 구성
			//-- 최종적으로 반복문의 조건을 무너뜨리게 되는 열쇠가 되는 구문
			n++;			//-- n → 1 2 3 4 5 6 7 8 9
			
			sum += (double)n/(n+1);
			// 1/2 + 2/3 + 3/4 + ... + 9/10
			// 1.0/2 + 2.0/3 + 3.0/4 + ... + 9.0/10
			// 정수 가번 나눗셈 연산은 몫만 반환하기 때문에
			// 실수 기반 연산을 수행하도록 처리하기 위해서
			// 나눗셈 연산자를 중심으로 피연산자 중 하나를
			// 실수형태로 만들어 주는 과정
		}
		
		// 결과 출력
		// System.out.println("연산 결과 : " + sum);
		//--==>> 
		
		System.out.printf("연산 결과 : %f\n",sum);
		//
		
		
		
		
		/*
		double n=0;
		double sum=0;
		
		while (n<9)
		{
			n++;
			sum += n / (n+1);  
		}
		System.out.println("연산 결과 : " + sum);
		*/
	}
}
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 1 - 2 + 3 - 4 + 5 - 6 + 7 - 8 + 9 - 10
// 연산 처리 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 연산 결과 : xxx
// 계속하려면 아무 키나 누르세요...

public class Test051
{
	public static void main(String[] args)
	{
		int n = 0, res=0;
		
		while (n<10)		// n → 0 ~ 8
		{
			n++;			// n → 1 3 5 7 9
			res += n;		//-- sum 을 n 만큼 증가
			n++;			// n → 2 4 6 8 10
			res -= n;		//-- sum 을 n 만큼 감소
		}
		
		// 결과 출력
		System.out.println("연산 결과 : " + res);
		
	}
}

// 실행 결과

/*
연산 결과 : -5
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 사용자로부터 임의의 정수를 입력받아
// 해당 값의 자리수를 출력하는 프로그램을 구현한다.

// 실행 예)
// 임의의 정수 입력 : 39754
// >> 39754의 자릿수는 5
// 계속하려면 아무 키나 누르세요...

// 실행 예)
// 임의의 정수 입력 : 1
// >> 1의 자릿수는 1
// 계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test052
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언 및 초기화
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int n;				//-- 사용자의 입력값을 담아낼 변수
		int len;			//-- 입력받은 정수의 자릿수을 담아낼 변수
		int temp;			//-- 사용자의 입력값을 담아낼 임시 저장 변수
		
		// 연산 및 처리
		System.out.print("임의의 정수 입력 : ");
		n = Integer.parseInt(br.readLine());
		temp=n;
		len=1;
		
		while (temp>=10)
		{
			len++;
			temp/=10;
		}
		
		// 결과 출력
		System.out.println(">>" + n + "의 자릿수는" + len);
		
		
		
		/*
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int a, b=0;
		int tmp=0;
		
		System.out.print("임의의 정수 입력 : ");
		a = Integer.parseInt(br.readLine());
		tmp = a;
		
		while (a>0)
		{
			a /= 10;
			b++;
		}

		System.out.println(">>" + tmp + "의 자릿수는" + b);
		*/
	}
}
// 실행 결과
/*
임의의 정수 입력 : 35475
>>35475의 자릿수는5
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 10
>>10의 자릿수는2
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 1 * 2 * 3 * 4 * ... * 10
// 의 연산 처리 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 연산 결과 : xxx
// 계속하려면 아무 키나 누르세요...

public class Test053
{
	public static void main(String[] args)
	{
		// 주요 변수 선언 및 초기화
		int n=0;			//-- 루프 변수
		int result=1;		//-- 누적합을 담아낼 변수
							//   → 1로 초기화!!
		
		// 연산 및 처리
		while (n<10)
		{
			n++;
			result *= n;	//-- 누적곱 연산
		}
		
		// 결과 출력
		System.out.println("연산 결과 : " + result);
		
		
		/*
		int n=0,res=1;
		
		while (n<10)
		{
			n++;
			res *= n;
		}
		System.out.println("연산 결과 : " + res);
		*/
	}
}
// 실행 결과

/*
연산 결과 : 3628800
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 사용자로부터 임의의 정수를 입력받아
// 입력받은 정수가 소수인지 아닌지를 판별하여
// 결과를 출력하는 프로그램을 구현한다.

// ※ 소수 : 1또는자기 자신의 값 이외에 어떤 수로도
//나누어 떨어지지 않는 수.
//단, 1은 소수 아님.

// 실행 예)
// 임의의 정수 입력 : 10
// >> 10 → 소수 아님
//계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test054
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int num;				//-- 사용자의 입력값을 담아낼 변수
		int n=2;				//-- 입력값을 대상으로 나눗셈 연산을 수행할 변수
								//   2부터 시작해서 1씩 증가
								//   ex) 입력값 11 → n:2 3 4 5 6...10
							
		// 연산 및 처리
		//-- 사용자에게 안내 메세지 출력, 입력값 얻어오기
		System.out.print("임의의 정수 입력 : ");
		num = Integer.parseInt(br.readLine());
		
		//-- 사용자가 어떤 값을 입력한 상태인지 알 수 없지만
		//   이 값을 소수로 간주(가정)한다.
		// String flag = "소수";
		// char flag = 'T';
		boolean flag = true;	//-- num(→ 사용자 입력값)은 소수일 것이다!!
		
		
		while (n<num)
		{
			// 테스트(확인)
			// System.out.println("반복문 수행... n은" + n);
			
			// 확인 연산
			//-- n 으로 num을 나누어 떨어지는 확인
			//						 (→ 나머지가 0인지 확인)
			if (num%n==0)
			{
				//테스트(확인)
				// 앗! 난 너를 소수라고 생각했는데
				// 넌 소수가 아니었어
				// System.out.println("넌 소수가 아니구나!");
				flag = false;
				
				// 추가 테스트(확인)
				// System.out.println("조건 확인 n은" + n);
				
				break;			//-- 멈춘다(+ 그리고 빠져나간다.)
								//   → break 를 감싸는 가장 가까운 반복문
			}
			n++;
		}
		
		// 테스트(확인)
		// System.out.println("flag 확인 : " + flag);
		
		// 첫 번째 허들을 넘어온 결과... 에 더하여.. 1이 아닌 상황인가?
		// ... 1 → 넌 소수아니구나
		
		// 결과 출력
		// (최종 결과값을 출력하기 전에 수행해야 할 추가 확인
		//  → 입력값이 1이 아닌지 에 대한 검토)
		if (flag && num != 1)
		{
			// 위 조건도 true... 추가확인... 입력값이 1도 아님 → 최종적으로 소수
			System.out.printf("%d → 소수\n",num);
		}
		else
		{
			// 위 조건이 false 이거나... 추가확인... 입력값이 1인 상황 → 최종적으로 소수 아님
			System.out.printf("%d → 소수 아님\n",num);
		}
		
		
		
		/*
		// 주요 변수 선언 및 초기화
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n, b=1;
		int tmp;
		String str = "";
		
		
		//연산 및 처리
		System.out.print("임의의 정수 입력 : ");
		n = Integer.parseInt(br.readLine());
		tmp = n;
		
		if (n == 1)
		{
			str = "소수 아님";
		}
		while (b<=tmp)
		{
			b++;
			
			if (tmp == b)
			{
				str = "소수";
				break;
			}
			else if (tmp % b == 0)
			{
				str = "소수아님"; break;
			}
		}
		
		// 결과 출력
		System.out.println(">>" + n + "→" + str);
		*/
	}
}

// 실행 결과
/*
임의의 정수 입력 : 10
10 → 소수 아님
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 13
13 → 소수
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 987
987 → 소수 아님
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 1001
1001 → 소수 아님
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력 : 1
1 → 소수 아님
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 사용자로부터 임의의 두 정수를 입력받아
// 입력받은 두 정수 중
// 작은 수부터 큰 수까지의 합을 구하여
// 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 첫 번째 정수 입력 : 100
// 두 번째 정수 입력 : 200
// >> 100 ~ 200 까지의 합 : xxxxx
// 계속하려면 아무 키나 누르세요...

// 실행 예)
// 첫 번째 정수 입력 : 1000
// 두 번째 정수 입력 : 2
// >> 2 ~ 1000 까지의 합 : xxxxx
// 계속하려면 아무 키나 누르세요...
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test055
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언 및 초기화
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n;				//-- 루프 변수로 활용할 변수
		int su1,su2;		//-- 첫 번째, 두 번째 사용자 입력값을 담아낼 변수
		int result=0;		//-- 누적합을 담아낼 변수
		
		// 연산 및 처리
		System.out.print("첫 번째 정수 입력 : ");
		su1 = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		su2 = Integer.parseInt(br.readLine());
		
		// 입력받은 두 수의 크기 비교 및 자리 바꿈
		// 즉, su1 이 su2 보다 큰 경우 두 수의 자리를 바꿀 수 있도록 처리
		if (su1>su2)
		{
			// 자리 바꿈
			su1 = su1^su2;
			su2 = su2^su1;
			su1 = su1^su2;
		}
		
		// 반복 연산 수행
		// 반복 연산을 수행하기 전에,
		// 작은 수를 따로 저장하여 루프 변수로 활용한다.
		// (결과 출력 과정에서 입력받은 작은 수가 필요한데...
		// 그 수를 직접적으로 반복 연산 과정에서 사용하게 되면...
		// 원래의 값을 확인할 수 없기 때문에...)
		n = su1;
		
		while (n<=su2)
		{
			result += n;
			n++;
		}
		
		
		// 결과 출력
		System.out.printf(">> %d ~ %d 까지의 합 : %d\n",su1,su2,result);
		
		/* 나의 풀이
		int n1, n2;
		int sum=0;
		int tmp1,tmp2;
		
		System.out.print("첫 번째 정수 입력 : ");
		n1 = Integer.parseInt(br.readLine());
		System.out.print("두 번째 정수 입력 : ");
		n2 = Integer.parseInt(br.readLine());
		tmp1 = n1;
		tmp2 = n2;
		
		if (tmp1>tmp2)
		{
			while (tmp2<=tmp1)
			{
				sum += tmp2;
				tmp2++;
			}
			System.out.printf("\n>> %d ~ %d 까지의 합 : %d\n",n2,n1,sum);
		}
		else if (tmp1<tmp2)
		{
			while (tmp1<=tmp2)
			{
				sum += tmp1;
				tmp1++;
			}
			System.out.printf("\n>> %d ~ %d 까지의 합 : %d\n",n1,n2,sum);
		}
		else
		{
			System.out.println(">> 입력 오류");
	    */
			
	}
}
// 실행 결과

/*
첫 번째 정수 입력 : 100
두 번째 정수 입력 : 200
>> 100 ~ 200 까지의 합 : 15150
계속하려면 아무 키나 누르십시오 . . .
*/

/*
첫 번째 정수 입력 : 1000
두 번째 정수 입력 : 2
>> 2 ~ 1000 까지의 합 : 500499
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// ○ 과제
//	  사용자로부터 임의의 정수를 입력받아
//    1부터 입력받은 그 정수까지의 
//    전체 합과, 짝수의 합과, 홀수의 합을
//    각각 결과값으로 출력하는 프로그램을 구현한다.

//실행 예)
// 임의의 정수 입력 : 586
// >> 1 ~ 586 까지의 정수의 합 : xxxxx
// >> 1 ~ 586 까지의 짝수의 합 : xxxxx
// >> 1 ~ 586 까지의 홀수의 합 : xxxxx
// 계속하려면 아무 키나 누르세요...
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test056
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언 및 초기화
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int num;										//-- 사용자의 입력값을 담아낼 변수
		int	n=1;										//-- 루프 변수로 활용할 변수
		int tot=0,even=0,odd=0;							//-- 총합, 짝수의 합, 홀수의 합을 담아낼 변수
		
		// 연산 및 처리
		System.out.print("임의의 정수 입력 : ");
		num = Integer.parseInt(br.readLine());
		
		while (n<=num)									//-- 1 ~ num 까지 반복문 실행
		{
			if (n % 2 == 0)								//-- n이 짝수일 경우 
			{
				even += n;								//-- 짝수의 누적합 연산
			}
			else if (n % 2 !=0)							//-- n이 홀수일 경우
			{
				odd += n;								//-- 홀수의 누적합 연산
			}
			
			tot += n;									//-- 정수의 누적합 연산
			
			n++;										//-- n을 1만큼 증가시키는 증감식
		}
		
		System.out.printf(">> 1 ~ %d 까지의 정수의 합 : %d\n",num,tot);		// 정수의 총합 출력 
		System.out.printf(">> 1 ~ %d 까지의 짝수의 합 : %d\n",num,even);	// 짝수의 합 출력	
		System.out.printf(">> 1 ~ %d 까지의 홀수의 합 : %d\n",num,odd);		// 홀수의 합 출력
		
	}
}


/*
임의의 정수 입력 : 10
>> 1 ~ 10 까지의 정수의 합 : 55
>> 1 ~ 10 까지의 짝수의 합 : 30
>> 1 ~ 10 까지의 홀수의 합 : 25
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(while)문 실습
===========================================*/

// 사용자로부터 원하는 단(구구단)을 입력받아
// 해당 구구단을 출력하는 프로그램을 구현한다.
// 단 1단~9단 사이의 수를 입력받은 상황이 아니라면
// 이에 대한 안내를 한 후 프로그램을 종료할수 있도록 처리한다.

// 실행 예)
// 원하는 단 (구구단) 입력 : 7
// 7 * 1 = 7
// 7 * 2 = 14
// 7 * 3 = 21
//   :
// 7 * 9 = 63
// 계속하려면 아무 키나 누르세요...

// 원하는 단(구구단) 입력 : 11
// 1부터 9까지의 정수만 입력이 가능합니다.
// 계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test057
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언 및 초기화
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int dan;					//-- 사용자로부터 입력값을 정수형태로 담아낼 변수(단)
		
		System.out.print("원하는 단(구구단) 입력 : ");
		dan = Integer.parseInt(br.readLine());
		
		// 입력값이 조건에 맞게 처리되었는지에 대한 확인
		if (dan<1 || dan>9)
		{
			System.out.println("1부터 9까지의 정수만 입력이 가능합니다.");
			return;
		}
		int n =0;
		// 결과 출력
		while (n<9)
		{
			n++;
			// 테스트(확인)
			// System.out.println("n : "+ n);
			System.out.printf("%d * %d = %d\n",dan,n,(dan*n));
		}
		
		
		
		/* 나의 풀이
		int n,su=1;
		int result;
		
		System.out.print("원하는 단(구구단) 입력 : ");
		n = Integer.parseInt(br.readLine());
		
		if (n<=9 && n>0)
		{
			while (su<=9)
				{
					result = n * su;
					System.out.printf("%d * %d = %d\n",n,su,result);
					su++;					
				}
		}
		else
			System.out.println("1부터 9까지의 정수만 입력이 가능합니다.");

		*/
	}
}
// 실행 결과

/*
원하는 단(구구단) 입력 : 13
1부터 9까지의 정수만 입력이 가능합니다.
계속하려면 아무 키나 누르십시오 . . .
*/

/*
원하는 단(구구단) 입력 : 5
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
계속하려면 아무 키나 누르십시오 . . .
*/
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(do~while)문 실습
===========================================*/

/*
○ 개요

	『do~while』문은 while문과 마찬가지로
	특정한 영역을 반복수행하는 반복문이다.
	다만, while문과 다른점은
	조건식에 대한 검사를 반복문을 수행한 이후에 한다는 것이다.
	이와 같은성격으로 인해 반드시 한번은 수행하게 되는 특징을 갖는다.
	
○ 형식 및 구조

	do
	{
		실행문;
	}
	while(조건식);
*/

public class Test058
{
	public static void main(String[] args)
	{
		// ※ while 반복문을 통해 구현했던 내용들을
		//    do~while 문을 통해서도 구현할 수 있다.
		/*
		int n=1;
		
		do
		{
			System.out.println("n=" + n);
			n++;
		}
		while (n<=10);
		*/
		
		/*
		int n=1;
		
		do
		{
			n++;
			System.out.println("n=" + n);
		}
		while (n<=10);
		*/
		
		/*
		int n=0;
		
		do
		{
			n++;
			System.out.println("n=" + n);
		}
		while (n<10);
		*/
		
		/*
		int n=0;
		
		do
		{
			System.out.println("n=" + ++n);
		}
		while (n<=10);
		*/
		
		/*
		int n=100;
		
		do
		{
			System.out.println("n=" + ++n);
		}
		while (n<=10);
		*/
		
		// do ~ while 문의 활용 모델
		// 예를 들어... 사용자로부터 특정 범위의 정수가 입력될 때 까지
		// 입력받는 행위 자체를 반복해서 수행해야 하는 상황이라 가정한다.
		// 즉, 최소 한 번은 사용자의 입력값을 받아 오는 처리를 수행해야
		// 원하는 범위의 값을 제대로 입력했는지 확인할 수 있고
		// 이로 인해 반복을 추가로 수행할지 말지의 여부를 결정할 수 있는 상황이다.
		
		java.util.Scanner sc = new java.util.Scanner(System.in);
		int num;
		
		do
		{
			System.out.print("100 이상의 정수를 입력하세요 : ");
			num = sc.nextInt();
		}
		while (num<100);
		
		System.out.println(num + " → 100 이상의 정수 입력 완료~!!!");
	}
}

/*
100 이상의 정수를 입력하세요 : 10
100 이상의 정수를 입력하세요 : 20
100 이상의 정수를 입력하세요 : 30
100 이상의 정수를 입력하세요 : 99
100 이상의 정수를 입력하세요 : 100
100 → 100 이상의 정수 입력 완료~!!!
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(do~while)문 실습
===========================================*/

// 사용자로부터 여러 개의 양의 정수를 입력받아
// 그 합을 계산하여 출력하는 프로그램을 작성한다.
// 단 사용자가 -1 을 입력하는 순간
// 더이상 입력 반복 행위를 중단하고
// 그동안 입력된 정수의 합을 출력해주는 프로그램을 구현한다.
// 즉 -1 을 입력중지 커맨드로 활용한다.
// do ~ while 문을 활용하여 문제를 해결할 수 있도록 한다.

// 실행 예)
// 1번째 정수 입력(-1 종료) : 10
// 2번째 정수 입력(-1 종료) : 5
// 3번째 정수 입력(-1 종료) : 8
// 4번째 정수 입력(-1 종료) : 9
// 5번째 정수 입력(-1 종료) : 200
// 6번째 정수 입력(-1 종료) : -1

// 현재까지 입력된 정수의 합 : 232
// 계속하려면 아무 키나 누르세요...

// 1번째 정수 입력(-1 종료) : -1

// 현재까지 입력된 정수의 합 : 0
// 계속하려면 아무 키나 누르세요..
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test059
{
	public static void main(String[] args) throws IOException
	{
		// 주요 변수 선언 및 초기화
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int num;				//-- 사용자의 입력값을 담아낼 변수
		int sum = 0;			//-- 누적합을 연산하여 담아낼 변수
		int n=1;				//-- 루프 변수로 활용하여 몇 번째 입력값인지를 담아낼 변수
		
		// 연산 및 처리
		do
		{
			System.out.printf("%d번째 정수 입력(-1 종료) : ",n);
			num = Integer.parseInt(br.readLine());
			sum += num;
			
			n++;
		}
		while (num != -1);		//-- num 이 -1 이 아닐 경우(계속해서 반복)
		
		// 테스트(확인)
		// System.out.println("-1 입력 → 종료");
		
		
		//결과 출력
		System.out.printf("\n>> 현재까지의 입력된 정수의 합 : %d\n",(sum+1));
		
		/*나의 풀이
		int n1=1,n2=0;
		int result=0;
		
		do
		{
			System.out.printf("%d번째 정수 입력(-1 종료) : ",n1,n2);
			n2 = Integer.parseInt(br.readLine());
			
			if (n2==-1)
				break;
	
			result += n2;
			n1++;
			
		}
		while (n2!=-1);
		
		System.out.printf("현재까지 입력된 정수의 합 : %d\n",result);
		*/
		
		
	}
}
// 실행 결과

/*
1번째 정수 입력(-1 종료) : 1
2번째 정수 입력(-1 종료) : 2
3번째 정수 입력(-1 종료) : 3
4번째 정수 입력(-1 종료) : 4
5번째 정수 입력(-1 종료) : 5
6번째 정수 입력(-1 종료) : 6
7번째 정수 입력(-1 종료) : 7
8번째 정수 입력(-1 종료) : 8
9번째 정수 입력(-1 종료) : 9
10번째 정수 입력(-1 종료) : 10
11번째 정수 입력(-1 종료) : -1

>> 현재까지의 입력된 정수의 합 : 55
계속하려면 아무 키나 누르십시오 . . .
*/
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(do~while)문 실습
===========================================*/

// 사용자로부터 원하는 단(구구단)을 입력받아
// 해당 구구단을 출력하는 프로그램을 구현한다.
// 단 1단~9단 사이의 수를 입력받은 상황이 아니라면
// 이에 대한 안내를 한 후 프로그램을 종료할수 있도록 처리한다.

// 실행 예)
// 원하는 단 (구구단) 입력 : 7
// 7 * 1 = 7
// 7 * 2 = 14
// 7 * 3 = 21
//   :
// 7 * 9 = 63
// 계속하려면 아무 키나 누르세요...

// 원하는 단(구구단) 입력 : 11
// 원하는 단(구구단) 입력 : -5
// 원하는 단(구구단) 입력 : 0
// 원하는 단(구구단) 입력 : 2
// 2 * 1 = 2
// 2 * 2 = 4
// 2 * 3 = 6
//   :
// 2 * 9 = 18
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;

public class Test060
{
	public static void main(String[] args)
	{
		// 주요 변순 선언 및 초기화
		Scanner sc = new Scanner(System.in);
		
		int dan;				//-- 사용자로부터 입력값을 정수 형태로 담아낼 변수
		
		int n=0;
		
		do
		{
			System.out.print("원하는 단(구구단) 입력 : ");
			dan = sc.nextInt();
		}
		while (dan>9 || dan<1);		//-- 입력값이 조건에 맞게 처리되었는지에 대한 확인
		
		while (n<9)
		{
			n++;
			System.out.printf(" %d * %d = %d\n",dan,n,(dan * n));
		}		
	}
}
// 실행 결과

/*

*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
===========================================*/

/*
○ 개요

	『for』 문은 정해진 횟수만큼 반복해야 하는 경우
	유용하게 사용되어지는 반복문으로
	『while』문과 마찬가지로 반복 실행해야 하는 구문이
	조건에 맞지 않을 경우 한번도 수행하지 않을 수 있으며
	루프 변수의 초기값, 조건식, 증감식 등을 한 지점에서 확인할 수 있기때문에
	가독성이 높은 반복문에 해당한다.
	
○ 형식 및 구조
	
	for(수식1; 수식2; 수식3)
	{
		실행문;
	}
	
	- 수식1은 루프 변수의 초기화를 위해 사용되며
			  최초 단 한번만 실행된다.
	- 수식2는 조건식을 나타내는 것으로 이 조건식(수식2)이 만족하면
			  루프를 반복해서 수행하게 된다
			  for문의 진행순서는 수식2가 참이면 반복문을 수행하고
			  수식3을 실행한 후 수식2의 조건식을 다시 검사하는 구조로 진행된다
			  따라서 처음에 조건식의 처리결과가 거짓일 경우
			  『for』 루프에 한번도 수행하지 않게 되는 것이다.
	- 수식3은 루프변수의 재초기화를 위해 사용되어지며
			  반복문의 조건식을 무너뜨리게 되는 증감식으로 처리한는 것이 일반적이다.
			  컴마(『,』)를 이용하여 여러문자을 함꼐 수행할 수도 있다.
*/

public class Test061
{
	public static void main(String[] args)
	{
		int n=1,m;				//-- n : while에서 사용할 루프 변수
								//	 m : for에서 사용할 루프 변수
		
		while (n<=10)
		{
			System.out.println("n=" +n);
			n++;
		}
		System.out.println();
		
		// ※ 위의  while 문을 for문으로 바꾼다.
		
		for (m=1; m<=10; m++)
			System.out.println("m=" + m);
	}
}
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
===========================================*/

// 1부터 100까지의 정수 중에서
// 4의 배수만 출력하는 프로그램을 구현한다.
// 단, for문 을 활용해야 하며
// 한줄에 5개씩만 출력할 수 있도록 한다.

// 실행 예)
//  4  8 12 16 20
// 24 28 32 36 40
//       :
//       :
// 계속하려면 아무 키나 누르세요...
public class Test062
{
	public static void main(String[] args)
	{
		for (int n=4; n<=100; n+=4)
		{
			System.out.printf("%4d",n);     // %?d ?만큼 공간을 확보해서 우측 정렬
			
			if (n%(4*5)==0)					//-- 출력 구문이 4*5의 배수가 될때 마다
				System.out.println();		//-- 개행
		}
		/*
		int num;
		int n=0;
		
		for (num=4;num<=100;num+=4)
		{
			System.out.printf("%d ",num);
			n++;
			
			if (n%5==0)
			{
				System.out.println();
			}
			
		}
		*/
	}
}

// 실행 결과

/*
   4   8  12  16  20
  24  28  32  36  40
  44  48  52  56  60
  64  68  72  76  80
  84  88  92  96 100
계속하려면 아무 키나 누르십시오 . . .
*/

/*
4 8 12 16 20
24 28 32 36 40
44 48 52 56 60
64 68 72 76 80
84 88 92 96 100
계속하려면 아무 키나 누르십시오 . . .
*/
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
- 반복문의 중첩 구문을 활용한 구구단 출력
===========================================*/

// 실행 예)
/*
[2단]
2 * 1 = 2
2 * 2 = 4
  :
[3단]
  :
  :
9 * 9 = 81
계속하려면 아무 키나 누르세요...
*/


public class Test063
{
	public static void main(String[] args)
	{
		int i,j;					//-- 루프 변수
		
		// 웅~~~ 웅~~~ 웅~~~
		for (i=2; i<=9; i++)		//-- 단 처리				→ 2 3 4 5 6 7 8 9
		{
			// 테스트(확인)
			// System.out.println("웅~~~~~~");
			System.out.printf("\n====[%d단]====\n",i);
			
			// 쑝쑝숑~~~~
			for (j=1; j<=9; j++)	//-- 곱해지는 수 처리		→ 1 2 3 4 5 6 7 8 9
			{
				// 테스트(확인)
				// System.out.println("쑝!");
				// System.out.printf("%d\n",j);
				// System.out.printf("%d * %d\n",i,j);
				System.out.printf("%d * %d = %2d\n",i,j,(i*j));
			}
			
		}
	}	
}

/*

====[2단]====
2 * 1 =  2
2 * 2 =  4
2 * 3 =  6
2 * 4 =  8
2 * 5 = 10
2 * 6 = 12
2 * 7 = 14
2 * 8 = 16
2 * 9 = 18

====[3단]====
3 * 1 =  3
3 * 2 =  6
3 * 3 =  9
3 * 4 = 12
3 * 5 = 15
3 * 6 = 18
3 * 7 = 21
3 * 8 = 24
3 * 9 = 27

====[4단]====
4 * 1 =  4
4 * 2 =  8
4 * 3 = 12
4 * 4 = 16
4 * 5 = 20
4 * 6 = 24
4 * 7 = 28
4 * 8 = 32
4 * 9 = 36

====[5단]====
5 * 1 =  5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45

====[6단]====
6 * 1 =  6
6 * 2 = 12
6 * 3 = 18
6 * 4 = 24
6 * 5 = 30
6 * 6 = 36
6 * 7 = 42
6 * 8 = 48
6 * 9 = 54

====[7단]====
7 * 1 =  7
7 * 2 = 14
7 * 3 = 21
7 * 4 = 28
7 * 5 = 35
7 * 6 = 42
7 * 7 = 49
7 * 8 = 56
7 * 9 = 63

====[8단]====
8 * 1 =  8
8 * 2 = 16
8 * 3 = 24
8 * 4 = 32
8 * 5 = 40
8 * 6 = 48
8 * 7 = 56
8 * 8 = 64
8 * 9 = 72

====[9단]====
9 * 1 =  9
9 * 2 = 18
9 * 3 = 27
9 * 4 = 36
9 * 5 = 45
9 * 6 = 54
9 * 7 = 63
9 * 8 = 72
9 * 9 = 81
계속하려면 아무 키나 누르십시오 . . .
*/
/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
- 반복문의 중첩 구문을 활용한 구구단 출력
===========================================*/

/*
2 * 1 =  2  3 * 1 =  3  4 * 1 =  4  5 * 1 =  5
2 * 2 =  4  3 * 2 =  6  4 * 2 =  8  5 * 2 = 10
2 * 3 =  6  3 * 3 =  9  4 * 3 = 12  5 * 3 = 15
2 * 4 =  8  3 * 4 = 12  4 * 4 = 16  5 * 4 = 20
2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25
2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30
2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35
2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40
2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45

6 * 1 =  6  7 * 1 =  7  8 * 1 =  8  9 * 1 =  9
6 * 2 = 12  7 * 2 = 14  8 * 2 = 16  9 * 2 = 18
6 * 3 = 18  7 * 3 = 21  8 * 3 = 24  9 * 3 = 27
6 * 4 = 24  7 * 4 = 28  8 * 4 = 32  9 * 4 = 36
6 * 5 = 30  7 * 5 = 35  8 * 5 = 40  9 * 5 = 45
6 * 6 = 36  7 * 6 = 42  8 * 6 = 48  9 * 6 = 54
6 * 7 = 42  7 * 7 = 49  8 * 7 = 56  9 * 7 = 63
6 * 8 = 48  7 * 8 = 56  8 * 8 = 64  9 * 8 = 72
6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81
*/

// 2중첩 * 2
//  ↓
// 3중첩 * 1

public class Test064
{
	public static void main(String[] args)
	{
		// (1) Test063과 비교하여
		//	   출력 방향(순서)이 다르기 때문에
		//     반복문의 제어 흐름과 달라져야 한다.
		//	   (콘솔 기반의 출력 환경이기 때문에...)
		
		// (2) (1)에 따라...
		//	   단과 곱해지는 수의 위치가
		//	   달라진 상태에서의 반복문 구성
		
		/* 2중 for문 2개
		// 첫 번째 문단
		for (int i=1; i<=9; i++)		//-- 웅 → 곱해지는 수
		{
			for (int j=2; j<=5; j++)	//-- 쓩 → 단
			{
				// 테스트(확인)
				// System.out.printf(j + ", " + i + "  ");
				System.out.printf("%4d * %d = %2d",j,i,(j*i));
			}
			System.out.println();		//-- 개행
		}
		System.out.println();			//-- 문단과 문단 사이 개행
		
		// 두 번째 문단
		for (int i=1; i<=9; i++)		//-- 웅 → 곱해지는 수
		{
			for (int j=6; j<=9; j++)	//-- 쓩 → 단
			{
				// 테스트(확인)
				// System.out.printf(j + ", " + i + "  ");
				System.out.printf("%4d * %d = %2d",j,i,(j*i));
			}
			System.out.println();
		}
		*/
		
		// (3) 위에서 처리한 결과를
		//	   두 문단으로 반복하는 반복문 구성
		//	   (두 번 반복하는 반복문에 위의 결과의 일부를 삽입)
		
		/*
		// 문단 구성
		for (int h=0; h<=1; h++)			// h → 0 1
		{
			// 테스트(확인)
			// System.out.println("테스트" + h);
			for (int i=1; i<=9; i++)		//-- 웅 → 곱해지는 수
			{
				for (int j=2; j<=5; j++)	//-- 쓩 → 단
				{
				// 테스트(확인)
				// System.out.printf(j + ", " + i + "  ");
					System.out.printf("%4d * %d = %2d",j,i,(j*i));
				}
				System.out.println();		//-- 개행
			}
			System.out.println();			//-- 개행 → 문단과 문단 사이 추가개행
		}
		*/
		
		// (4) 같은 구문을
		//	   두 개의 문단으로 나누어 처리하는 과정에서
		//	   문단에 따라 다르게 주어지는 환경(h의 값)을 활용하는 방법으로
		//	   반복문 3중첩 구성
		
		// 3중첩 for문 1개
		// 문단 구성
		for (int h=0; h<=1; h++)			// h → 0 1
		{
			// 테스트(확인)
			// System.out.println("테스트" + h);
			for (int i=1; i<=9; i++)		//-- 웅 → 곱해지는 수
			{
				for (int j=2; j<=5; j++)	//-- 쓩 → 단
				{
					// 테스트(확인)
					// System.out.printf(j + ", " + i + "  ");
					// System.out.printf("%4d * %d = %2d",j,i,(j*i));
					System.out.printf("%4d * %d = %2d",j+(h*4),i,((j+(h*4))*i));
				}
				System.out.println();		//-- 개행
			}
			System.out.println();			//-- 개행 → 문단과 문단 사이 추가개행
		}
		
		// cf) 그냥 다른 구조...
		
		int a,b,c;
		for (a=2; a<=6; a+=4)
		{
			for (b=1; b<=9; b++)
			{
				for (c=a; c<=(a+3); c++)
				{
					System.out.printf("%4d * %d = %2d",c,b,(c*b));
				}
				System.out.println();
			}
			System.out.println();
		}
		
		
		
		/* 나의 풀이
		int i,j,k;
		
		for (k=0; k<=4; k+=4)
		{
			for (j=1;j<=9;j++)
			{
				for (i=2;i<=5;i++)
				{
					System.out.printf("%d * %d = %2d  ",(i+k),j,((i+k)*j));
				}
				System.out.println();
			}
			System.out.println();
		}
		*/
		
		/*
		int i,j;
		
		for (j=1; j<=9; j++)
		{
			for (i=2; i<=5;i++)
			{
				System.out.printf("%d * %d = %2d  ",i,j,(i*j));
			}
			System.out.println();
		}
		System.out.println();
		
		for (j=1; j<=9;j++)
		{
			for (i=6; i<=9; i++)
			{
				System.out.printf("%d * %d = %2d  ",i,j,(i*j));
			}
			System.out.println();
		}
		*/
	}
}

// 실행 결과

/*
   2 * 1 =  2   3 * 1 =  3   4 * 1 =  4   5 * 1 =  5
   2 * 2 =  4   3 * 2 =  6   4 * 2 =  8   5 * 2 = 10
   2 * 3 =  6   3 * 3 =  9   4 * 3 = 12   5 * 3 = 15
   2 * 4 =  8   3 * 4 = 12   4 * 4 = 16   5 * 4 = 20
   2 * 5 = 10   3 * 5 = 15   4 * 5 = 20   5 * 5 = 25
   2 * 6 = 12   3 * 6 = 18   4 * 6 = 24   5 * 6 = 30
   2 * 7 = 14   3 * 7 = 21   4 * 7 = 28   5 * 7 = 35
   2 * 8 = 16   3 * 8 = 24   4 * 8 = 32   5 * 8 = 40
   2 * 9 = 18   3 * 9 = 27   4 * 9 = 36   5 * 9 = 45

   6 * 1 =  6   7 * 1 =  7   8 * 1 =  8   9 * 1 =  9
   6 * 2 = 12   7 * 2 = 14   8 * 2 = 16   9 * 2 = 18
   6 * 3 = 18   7 * 3 = 21   8 * 3 = 24   9 * 3 = 27
   6 * 4 = 24   7 * 4 = 28   8 * 4 = 32   9 * 4 = 36
   6 * 5 = 30   7 * 5 = 35   8 * 5 = 40   9 * 5 = 45
   6 * 6 = 36   7 * 6 = 42   8 * 6 = 48   9 * 6 = 54
   6 * 7 = 42   7 * 7 = 49   8 * 7 = 56   9 * 7 = 63
   6 * 8 = 48   7 * 8 = 56   8 * 8 = 64   9 * 8 = 72
   6 * 9 = 54   7 * 9 = 63   8 * 9 = 72   9 * 9 = 81

계속하려면 아무 키나 누르십시오 . . .
*/


/* 나의 결과
2 * 1 =  2  3 * 1 =  3  4 * 1 =  4  5 * 1 =  5
2 * 2 =  4  3 * 2 =  6  4 * 2 =  8  5 * 2 = 10
2 * 3 =  6  3 * 3 =  9  4 * 3 = 12  5 * 3 = 15
2 * 4 =  8  3 * 4 = 12  4 * 4 = 16  5 * 4 = 20
2 * 5 = 10  3 * 5 = 15  4 * 5 = 20  5 * 5 = 25
2 * 6 = 12  3 * 6 = 18  4 * 6 = 24  5 * 6 = 30
2 * 7 = 14  3 * 7 = 21  4 * 7 = 28  5 * 7 = 35
2 * 8 = 16  3 * 8 = 24  4 * 8 = 32  5 * 8 = 40
2 * 9 = 18  3 * 9 = 27  4 * 9 = 36  5 * 9 = 45

6 * 1 =  6  7 * 1 =  7  8 * 1 =  8  9 * 1 =  9
6 * 2 = 12  7 * 2 = 14  8 * 2 = 16  9 * 2 = 18
6 * 3 = 18  7 * 3 = 21  8 * 3 = 24  9 * 3 = 27
6 * 4 = 24  7 * 4 = 28  8 * 4 = 32  9 * 4 = 36
6 * 5 = 30  7 * 5 = 35  8 * 5 = 40  9 * 5 = 45
6 * 6 = 36  7 * 6 = 42  8 * 6 = 48  9 * 6 = 54
6 * 7 = 42  7 * 7 = 49  8 * 7 = 56  9 * 7 = 63
6 * 8 = 48  7 * 8 = 56  8 * 8 = 64  9 * 8 = 72
6 * 9 = 54  7 * 9 = 63  8 * 9 = 72  9 * 9 = 81

계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
===========================================*/

// 다중 반복문(반복문의 중첩)을 활용한 별찍기==

// ○ 과제
//		다음과 같은 내용이 출력될수 있도록
//		반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

// 실행 예)
/*

	 *
	**
   ***
  ****
 *****

*/

public class Test065
{
	public static void main(String[] args)
	{
		int i,j,k;

		for (i=1; i<=5; i++)
		{
			for (j=1;j<=(5-i); j++)     // 공백이 1씩 감소 
			{
				System.out.print(" ");	
			}
			for (k=1;k<=i;k++)			// 별이 1씩 증가
			{
				System.out.print("*");
			}		
			System.out.println();
		}
	}
}/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
===========================================*/

// 다중 반복문(반복문의 중첩)을 활용한 별찍기

// ○ 과제
//		다음과 같은 내용이 출력될수 있도록
//		반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

// 실행 예)
/*

	 *
	***
   *****
  *******
 *********

*/

public class Test066
{
	public static void main(String[] args)
	{
		int i,j,k;
		
		for (i=1;i<=5;i++ )
		{
			for (j=1;j<=(5-i);j++)
			{
				System.out.print(" ");
			}
			for (k=1;k<=i*2-1;k++)
			{
				System.out.print("*");
			}
			System.out.println();
		}

	}
}/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
===========================================*/

// 다중 반복문(반복문의 중첩)을 활용한 별찍기

// ○ 과제
//		다음과 같은 내용이 출력될수 있도록
//		반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

// 실행 예)
/*

 *********
  *******
   *****
    *** 
	 *
	
*/

public class Test067
{
	public static void main(String[] args)
	{
		int i,j,k;
		
		for (i=1; i<=5; i++)
		{
			for (j=1;j<i;j++)
			{
				System.out.print(" ");
			}
			for (k=1;k<=(5-i)*2+1;k++)
			{
				System.out.print("*");
			}
			System.out.println();
		}

	}
}/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- 반복문(for)문 실습
===========================================*/

// 다중 반복문(반복문의 중첩)을 활용한 별찍기

// ○ 과제
//		다음과 같은 내용이 출력될수 있도록
//		반복문의 중첩 구문을 작성하여 프로그램을 구현한다.

// 실행 예)
/*

     *
    ***
   *****
  *******
 *********
  *******
   *****
    *** 
	 *
	
*/

public class Test068
{
	public static void main(String[] args)
	{
		int i,j,k;
		
		for (i=1; i<=5; i++)
		{
			for (j=1; j<5; j++)
			{
				System.out.print(" ");
				for (k=1; k<=i*2-1; k++)
				{
					System.out.print("*");
				}
				System.out.println();
			}
		}
		
		for (i=1; i<=5; i++)
		{
			for (j=1; j<i; j++)
			{
				System.out.print(" ");
				for ( k=1; k<=(5-i)*2; k++)
				{
					System.out.print("*");
				}
				System.out.println();
			}
		}

	}
}/*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- break 실습
===========================================*/

// ※ break 키워드가 지니는 의미
//		→ 멈춘다 (+ 그리고 빠져나간다)

// 다음가 같은 처리가 이루어지는 프로그램을 구현한다.
// 단, 입력받은 정수는 1~100 범위 안에서만
// 가능하도록 처리한다.

// 실행 예)

// 임의의 정수 입력 : -10

// 임의의 정수 입력 : 0

// 임의의 정수 입력 : 2024

// 임의의 정수 입력 : 10
// >> 1~10까지의 합 : 55
// 계속하시겠습니까(Y/N)? : y

// 임의의 정수 입력 : 100\
// >> 1~100까지의 합 : 5050
// 계속하시겠습니까(Y/N)? : N
// 계속하려면 아무 키나 누르세요...	→ 프로그램 종료


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test069
{
	public static void main(String[] args)	throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		// check!!
		// int n,s=0,i;
		int n,s,i;
		//-- n : 사용자 입력값을 담아둘 변수
		//-- s : 누적합 연산 결과를 담아낼 변수
		//-- i : 1부터 1씩 사용자의 입력값까지 증가할 변수
		
		char ch;
		//-- 프로세스를 계속 진행할지 말지의 여부를 담아둘 변수
		
		while (true)
		{
			do
			{
				System.out.print("\n임의의 정수 입력 : ");
				n = Integer.parseInt(br.readLine());
			}
			while (n<1 || n>100); 
		
			// 테스트(확인)
			// System.out.println("유효한 정수 입력 완료!");
			
			// 누적합 변수의 초기화 위치  check!!
			
			s = 0;
		
			// 1부터 입력값(n)까지의 누적합 연산
			// → 1 부터 입력값(n)까지 반복
		
			for (i=1;i<=n;i++)
			{
				
				s += i;			//-- s 를 i 만큼 증가 → 누적합 연산
			
			}
		
			System.out.printf(">> 1 ~ %d 까지의 합 : %d\n",n,s);
			
			System.out.print("계속하시겠습니까(Y/N)? : ");
			ch = (char)System.in.read();
			//-- 계속할지 말지에 대한 여부(의사표현)
			
			// 그만할래 → 반복문 빠져나감
			/*
			if (ch=='N' || ch=='n')				//-- N 또는 n 입력한거 맞아???
			{
				
			}
			*/
			if (ch != 'Y' && ch != 'y')	//-- Y 또는 y 입력하지 않은거 맞아??
			{
				// 반복문을 멈추고 빠져나갈 수 있는 코드 작성 필요
				//-- 즉, 위와 같은 의사 표현을 했다면
				//   그 동안 수행했던 반복문을 멈추고 빠져나가야 한다.
				break;
				//-- 멈춘다 + (그리고 빠져나간다)
			}
			
			// 엔터값(\r\n) 처리
			System.in.skip(2);
			
		}// end while(true)
			
	}//end main()
	
}//end class Test069

// 실행 결과

/*

임의의 정수 입력 : -1

임의의 정수 입력 : 101

임의의 정수 입력 : 10
>> 1 ~ 10 까지의 합 : 55
계속하시겠습니까(Y/N)? : y

임의의 정수 입력 : 100
>> 1 ~ 100 까지의 합 : 5050
계속하시겠습니까(Y/N)? : n
계속하려면 아무 키나 누르십시오 . . .

*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- continue 실습
===========================================*/

// ※ continue 키워드가 지니는 의미
//		→ (뒷부분 무시하고 +) 계속해라

// continue 를 활용하여
// 다음과 같이 출력될 수 있도록 프로그램을 구현한다.

// 실행 예)
/*
1 : 1
3 : 4
5 : 9
7 : 16

  :
  
99 : 2500
계속하려면 아무 키나 누르세요...
*/

public class Test070
{
	public static void main(String[] args)
	{
		
		int n=0, s=0;
		
		while (n<100)
		{
			n++;								//		
												//		앞부분		
			// 테스트 (확인)					//
			// System.out.println("n : " + n);	//
			
			if (n%2==0)							//-- n이 짝수라면...
			{		
				continue;						//-- 뒷부분 무시하고... 계속해라
			}
			
			s += n;								//		뒷부분
			System.out.println(n + " : " + s);	//
		}
		
		/*
		int n,s=0;
		
		for (n=1;n<100;n++)
		{
			if (n % 2 ==0)
			{
				continue;	
			}
				
			s += n;
			System.out.printf("%d : %d\n",n,s);
		}
		*/
	
	}
}
// 실행 결과

/*
1 : 1
3 : 4
5 : 9
7 : 16
9 : 25
11 : 36
13 : 49
15 : 64
17 : 81
19 : 100
21 : 121
23 : 144
25 : 169
27 : 196
29 : 225
31 : 256
33 : 289
35 : 324
37 : 361
39 : 400
41 : 441
43 : 484
45 : 529
47 : 576
49 : 625
51 : 676
53 : 729
55 : 784
57 : 841
59 : 900
61 : 961
63 : 1024
65 : 1089
67 : 1156
69 : 1225
71 : 1296
73 : 1369
75 : 1444
77 : 1521
79 : 1600
81 : 1681
83 : 1764
85 : 1849
87 : 1936
89 : 2025
91 : 2116
93 : 2209
95 : 2304
97 : 2401
99 : 2500
계속하려면 아무 키나 누르십시오 . . .
*//*===========================================
■■■ 실행 흐름의 컨트롤 (제어문)■■■
- return 실습
===========================================*/

// ※ return 키워드가 지니는 의미
//	  1. 값의 반환
//	  2. 메소드 종료

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
public class Test071
{
	public static void main(String[] args) throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int n,s;
		
		// System.out.print("임의의 정수 입력 : ");
		System.out.print("임의의 정수 입력(10이상) : ");
		n = Integer.parseInt(br.readLine());
		
		if (n<10)
		{
			System.out.println("10 이상의 정수를 입력해야 합니다.");
			return;			// return xxx;
			//-- 메소드 종료 → return문을 포함하고 있는 메소드
			//	→ main() 메소드 → 프로그램 종료
		}
		
		s=0;
		
		for (int i=1; i<=n; i++)
		{
			s +=i;
		}
		
		System.out.println("연산 결과 : " + s);
	}
}

// 실행 결과

/*
임의의 정수 입력(10이상) : 100
연산 결과 : 5050
계속하려면 아무 키나 누르십시오 . . .
*/

/*
임의의 정수 입력(10이상) : 5
10 이상의 정수를 입력해야 합니다.
계속하려면 아무 키나 누르십시오 . . .
*//*====================================
  ■■■ 지역변수와 전역변수 ■■■
====================================*/

// Test073.java 와 비교

// ※ 지역 변수는 초기화 과정을 거치지 않으면 사용할 수 없다.
//		(→ 즉, 자바가 자동으로 초기화를 수행해 주거나 하지 않는다.)
public class Test072
{
	// 클래스 영역
	// 변수 선언 (클래스의 전 지역에서 다 보이고 접근도 가능
	// 전역변수
	
	public static void main(String[] args)
	{
		// 메소드의 영역(main() 메소드)
		// 변수 선언 (main() 메소드에서만 보이고 접근도 가능)
		// 지역 변수
		
		int n;
		//-- 선언 후 초기화 과정을 거치지 않은 상태
		
		// System.out.println("n : " + n);
		//--==> 에러발생(컴파일 에러)
		//		variable n might not have been initialized
		//-- 지역 변수 n 에 접근하여 그 값을 출력하고자 하는 구문
	}
}/*====================================
  ■■■ 지역변수와 전역변수 ■■■
====================================*/

// // Test072.java 와 비교

public class Test073
{
	// 클래스 영역
	
	// 전역 변수 a 선언
	int a;
	//-- 자바가 자동으로 0으로 초기화 지원
	boolean b;
	char c;
	double d;
	
	public static void main(String[] args)
	{
		// 메소드 영역
		
		//System.out.println("a : " + a);
		//--==> 에러 발생(컴파일 에러)
		//		non-static variable a cannot be referenced from a static context
		
		// Test073 클래스(설계도)를 기반으로 인스턴스(객체) 생성
		Test073 ob = new Test073();
		
		System.out.println("ob.a : " + ob.a);
		//--==> ob.a : 0
		
		System.out.println("ob.b : " + ob.b);
		System.out.println("ob.c : " + ob.c);
		System.out.println("ob.d : " + ob.d);
		//--==> ob.a : 0
		//		ob.b : false
		//		ob.c :
        //		ob.d : 0.0
		
	}
}/*====================================
  ■■■ 클래스와 인스턴스 ■■■
  - 직사각형 클래스 설계 실습
====================================*/

/*
직사각형의 넓이와 둘레를 계산 → 클래스로 표현(설계)

클래스의 정체성 → 직사각형의 객체의 설계도
클래스의 속성   → 가로, 세로, 넓이, 둘레
				   (,부피 ,무게 ,재질, 색상, 질량, 냄새, ...)
클래스의 기능   → 넓이 계산, 둘레 계산, 가로 세로 입력, 결과 출력
				   (, 일부 잘라내기, 가로 변경, 세로 변경, 재질 변경,...)
				
※ 객체를 구성 → 데이터(속성, 상태)  +  기능 (동작, 행위)
		
		↓				↓				     ↓
		
   클래스 설계 →	   변수           +	    메소드
   
   
public class 직사각형
{
	// 데이터(속성, 상태)   → 변수 (순서 의미 없음)
	int 가로, 세로;
	
	// 기능(동작, 행위)		→ 메소드 (순서 의미 없음)
	가로세로 입력()
	{
	}
	
	둘레계산 ()
	{
	}
	
	넓이 계산()
	{
	}
	
	결과 출력()
	{
	}
*/

import java.util.Scanner;

// 직사각형 클래스 설계
// public class Rect
class Rect
{
	// 데이터(속성, 상태)   → 변수 (순서 의미 없음)
	int w, h;					// 가로, 세로
	
	// 기능(동작, 행위)		→ 메소드 (순서 의미 없음)
	void input()						// 가로세로입력()
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("가로 입력 : ");
		//int x = sc.nextInt();
		w = sc.nextInt();
		
		System.out.print("세로 입력 : ");
		h = sc.nextInt();
		
	}
	
	int calLength()					//둘레계산 () → 직사각형의 둘레 연산 수행 → (가로 + 세로) * 2
	{
		// (가로 + 세로) * 2
		//
		// return (가로 + 세로) * 2;
		//return (w + h) * 2;
		
		int result = 0;
		
		result = (w + h) * 2;
		
		return result;
	}
	
	int calArea()					// 넓이 계산() → 직사각형의 넓이 연산 수행 → 가로 * 세로	
	{
		// 주요 변수 선언 및 초기화
		int result = 0;
		
		// 연산 및 처리 → 선언한 변수들에 값 담아내기
		// result = 가로 * 세로;
		result = w * h;
		
		// 결과 처리
		return result;
		
		// return w * h;
	}
	
	void print(int a, int l) // 결과 출력() 매개변수의 데이터타입을 지정할때는 각각 데이터 타입을 지정해줘야한다.
	{
		// 가로 : xxx
		// 세로 : xxx
		// 넓이 : xxxx
		// 둘레 : xxxx
		System.out.println("가로 : " + w);
		System.out.println("세로 : " + h);
		System.out.println("넓이 : " + a);
		System.out.println("둘레 : " + l);
	}
}

// ※ 하나의 자바 파일(.java)에 여러 개의 클래스(class)를 설계할 수 있다.
//	  하지만, 『public class』는 이 파일 내에서 하나만 올 수 있다.
//    파일을 저장할때 의 이름은
//    이 『public class』의 이름으로 지정해야 한다.
//	  일반적으로(실무적으로) 하나의 파일에 하나의 클래스를 설계한다.
//    또한, 여러개의 클래스가 설계된 파일을 컴파일하게 되면
//    내부에 설계된 클래스의 수 만큼 클래스 파일(.class)이 파생된다.

// 외부의 다른 클래스
public class Test074
{
	public static void main(String[] args)
	{
		// Rect 클래스 기반의 인스턴스(객체) 생성
		// Rect 변수명 = new Rect();
		Rect ob = new Rect();
		
		int area;
		int length;
		
		// 입력 메소드 호출
		ob.input();
		
		// 넓이 연산 메소드 호출
		// ob.calArea();
		// int area = ob.calArea();
		area = ob.calArea();
		
		// 둘레 연산 메소드 호출
		// int length = ob.calLength();
		length = ob.calLength();
		
		// 출력 메소드 호출
		ob.print(area,length);
	}
}

// 실행 결과

/*
가로 입력 : 100
세로 입력 : 20
가로 : 100
세로 : 20
넓이 : 2000
둘레 : 240
계속하려면 아무 키나 누르십시오 . . .
*//*====================================
  ■■■ 클래스와 인스턴스 ■■■
====================================*/

// ※ CircleTest.java 파일과 세트!

// Test074.java		→ Test074.class
//					→ Rect.class

// Test075.java		→ Test075.class
// CircleTest.java	→ CircleTest.java

// 원의 넓이와 둘레 구하기
// 원의 넓이와 둘레를 구할 수 있는 클래스를 설계한다.
// (클래스명 : CircleTest)
// Test074.java 파일을 참조하여 설계할 수 있도록 한다.
// 데이터 입력은 BufferedReader 의 readLine() 활용

// 실행 예)
// 반지름 입력 : xxx

//>> 반지름이 xxx인 원의
//>> 넓이 : xxxx.xx
//>> 둘레 : xxxx.xx
// 계속하려면 아무 키나 누르세요...

// package default; 생략된것
// 두 파일이 논리적으로 동일한 패키지에 있을경우 import구문 필요 X

import java.io.IOException;

public class Test075
{
	public static void main(String[] args) throws IOException
	{
		// CircleTest 클래스(설계도) 기반 인스턴스(객체) 생성
		CircleTest ob = new CircleTest();
		
		ob.input();
		
		double num1 = ob.calArea();
		
		double num2 = ob.calLength();
		
		ob.print(num1,num2);
		
		
		
		/*
		CircleTest ct = new CircleTest();
		double area;
		double length;
		
		ct.input();
		
		area = ct.calArea();
		
		length = ct.calLength();
		
		ct.print(area,length);
		*/
	}
}

// 실행 결과

/*
반지름 입력 : 120

>> 반지름이 120 인 원의
>> 넓이 : 45238.92
>> 둘레 : 753.98
계속하려면 아무 키나 누르십시오 . . .
*//*====================================
  ■■■ 클래스와 인스턴스 ■■■
====================================*/

// 사용자로부터 임의의 정수를 입력받아
// 1 부터 입력방ㄷ은 수 까지의 합을 연산하여
// 결과값을 출력하는 프로그램을 구현한다.

// 단 지금까지 처럼 main()메소드에 모든 기능을 적용하는 것이 아니라
// 클래스와 인스턴스 개념을 활용하여 처리할 수 있도록 한다.
//( → Hap 클래스 설계)
// 또한 입력처리 과정에서 BufferedReader 와 readLine()을 활용하며
// 입력데이터가 1보다 작거나 1000보다 큰경우
// 다시 입력받을 수 있는 처리를 포함하여 구현할 수 있도록 한다.

// 실행 예)
// 임의의 정수 입력(1~1000) : 1050
// 임의의 정수 입력(1~1000) : -50
// 임의의 정수 입력(1~1000) : 100
// >> 1 ~100 까지의 합 : 5050
// 계속하려면 아무 키나 누르세요

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;



class Hap
{
	// 주요 변수 선언(사용자의 입력값을 담아낼 변수)
	int su;
	
	// 입력 메소드 정의
	void input() throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		do
		{
			System.out.print("임의의 정수 입력(1~1000) : ");
			su = Integer.parseInt(br.readLine());
		}
		while (su<1 || su>1000);
		
	}
	
	// 연산 처리 메소드 정의
	int calculate()
	{
		int result = 0;
		
		for (int i = 1; i<=su; i++)
		{
			result += i;
		}
		
		return result;
	}
	
	// 결과 출력 메소드 정의
	void print(int sum)
	{
		// >> 1 ~100 까지의 합 : 5050
		System.out.printf(">> 1 ~ %d 까지의 합 : %d\n",su,sum); 
	}
	
	
	
	/* 나의 풀이
	int n;
	
	void input() throws IOException
	{	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		do
		{
			System.out.print("임의의 정수 입력(1~1000) : ");
			n = Integer.parseInt(br.readLine());
		}
		while (n<1 || n>1000);
	}
	
	int cal()
	{
		int i,j = 0;
			
		for (i=1;i<=n;i++)
		{
			j += i;
	
		}
		
		return j;
	}
	
	void print(int a)
	{
		System.out.printf(">> 1 ~ %d 까지의 합 : %d\n", n, a);
	}
	*/
}


// 외부의 다른 클래스
public class Test076
{
	public static void main(String[] args) throws IOException
	{
		// Hap 의 인스턴스(객체) 생성
		// Hap ob = new Hap();
		/* Hap 서로 다른 객체
		new Hap().input();
		new Hap().calculate();
		*/
		
		/* 서로 다른 객체
		Hap ob1 = new Hap();
		ob1.input();
		
		Hap ob2 = new Hap();
		ob2.calculate();
		*/
		
		// Hap 인스턴스(객체) 생성
		Hap ob = new Hap();
		//  --
		// 참조변수
		
		// 생성된 인스턴스를 통해 입력 메소드 호출
		// ----------------------
		//     참조변수 활용
		ob.input();
		
		// 생성된 인스턴스를 통해 연산 메소드 호출
		int s = ob.calculate();
		
		// 생성된 인스턴스를 통해 출력 메소드 호출
		ob.print(s);
		// ob.print(ob.calculate());
	
		/* 나의 풀이
		Hap h = new Hap();
		int a;
		
		h.input();
		
		a = h.cal();
		
		h.print(a);
		*/
	}
}

// 실행 결과

/*
임의의 정수 입력(1~1000) : 1050
임의의 정수 입력(1~1000) : -70
임의의 정수 입력(1~1000) : 100
>> 1 ~ 100 까지의 합 : 5050
계속하려면 아무 키나 누르십시오 . . .
*//*====================================
  ■■■ 클래스와 인스턴스 ■■■
====================================*/

// 사용자로부터 임의의 두 정수와 연산자를 입력받아
// 해당 연산을 수행하는 프로그램을 구현한다.
// 단, 클래스와 인스턴스의 개념을 활용하여 작성할 수 있도록 한다.
// (→ Calculate 클래스 설계)
// 나눗셈 연산은 편의상 정수 형태로 처리한다.

// 실행 예)
// 임의의 두 정수 입력(공백 구분) : 10 5
// 임의의 연산자 입력(+ - * /)	  : +
// >> 10 + 5 = 15
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;
import java.io.IOException;

class Calculate
{
	// 주요 변수 선언(→ Calculate 객체의 속성 구성)
	int su1, su2;		//-- 사용자로부터 입력받은 두 정수를 담아낼 변수
	char op;			//-- 사용자로부터 입력받은 연산자를 담아낼 변수
	
	// 메소드 정의(기능 : 입력)
	void input() throws IOException
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("임의의 두 정수 입력(공백 구분) : ");
		su1 = sc.nextInt();
		su2 = sc.nextInt();
		
		System.out.print("임의의 연산자 입력 : ");
		op = (char)System.in.read();
	}
	
	// 메소드 정의(기능 : 연산) → 나눗셈 연산도 정수 기반으로 처리
	// → 반환 자료형 int
	int cal()
	{
		int result = 0;
		
		switch (op)
		{	
			case '+' : result = su1 + su2; break;
			case '-' : result = su1 - su2; break;
			case '*' : result = su1 * su2; break;
			case '/' : result = su1 / su2; break;
		
			default : result = -1;
		}
		
		return result;
	}
	
	
	// 메소드 정의(기능 : 출력)
	void print(int s)
	{
		// >> 10 + 5 = 15
		System.out.printf(">> %d %c %d = %d\n", su1, op, su2, s);
	}
	
	
	/* 나의 풀이
	int num1, num2;
	char op;
	
	void input() throws IOException
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("임의의 두 정수 입력(공백 구분) : ");
		num1 = sc.nextInt();
		num2 = sc.nextInt();
		
		System.out.print("임의의 연산자 입력 : ");
		op = (char)System.in.read();
	}
	
	int cal()
	{
		int result = 0;
	*/	
		/*
		if (op == '+')
			result = num1 + num2; 
		else if (op == '-')
			result = num1 - num2; 
		else if (op == '*' )
			result = num1 * num2;
		else if (op == '/')
			result = num1 / num2;
		*/
	/*	
		switch (op)
		{
			case '+' : result = num1 + num2; break;
			case '-' : result = num1 - num2; break;
			case '*' : result = num1 * num2; break;
			case '/' : result = num1 / num2; break;
		
		}
		
		return result;
	}
	
	void print(int s)
	{
		System.out.printf(">> %d %c %d = %d\n",num1,op,num2,s);
	}
	*/
}


public class Test077
{
	public static void main(String[] args) throws IOException
	{
		// Calculate() 클래스(설계도) 기반 인스턴스(객체) 생성
		Calculate ob = new Calculate();
		
		// Calculate ob = new Calculate;		메모리에 적재
		//						  +
		//					  Calculate();		호출, Calculate(); → 생성자
								
		
		// 생성한 인스턴스를 통해 입력 메소드 호출
		ob.input();
		
		// 생성한 인스턴스를 통해 연산 메소드 호출
		int r = ob.cal();
		
		// 생성한 인스턴스를 통해 출력 메소드 호출
		ob.print(r);
		
		/* 나의 풀이
		Calculate ca = new Calculate();
		int res;
		
		ca.input();
		
		res = ca.cal();
		
		ca.print(res);
		*/
	}
}

// 실행 결과

/*
임의의 두 정수 입력(공백 구분) : 123 123
임의의 연산자 입력 : *
>> 123 * 123 = 15129
계속하려면 아무 키나 누르십시오 . . .
*//*==============================
■■■ 클래스와 인스턴스 ■■■
- 생성자(Constructor)
===============================*/

/*
○ 생성자(Constructor)의 역할

	1. 인스턴스 생성 → 메모리 할당
	2. 초기화
	
○ 생성자의 특징
	
	1. 생성자는 메소드이지만, 일반 메소드처럼 호출될 수 없으며,
	   반환 자료형을 가질 수 없다.
	   (『void』조차 가질수 없으며, 값을 반환할 수도 없다.)
	2. 생성자는 클래스와 동일한 이름을 가져야한다.
		(대소문자 명확한 구분)
	3. 생성자는 객체를 생성하는 과정에서 『new 생성자();』 의 형태로 호출된다.
		(인스턴스 생성 과정과에서 단 한번만 호출)
		→ final 변수(상수화된 변수) 초기화 가능
*/
class NumberTest
{
	int num;
	
	//check
	// ※ 클래스에 사용자 정의 생성자를 정의하지 않았다면
	// 컴파일 과정에서 디폴트 생성자가 자동으로 삽입된다.
	
	// 디폴트(default) 생성자
	/*
	NumberTest()
	{
	}
	*/
	
	// 사용자 정의 생성자
	NumberTest()
	{
		num = 10;
		System.out.println("생성자 호출~!!!");
	}
	
	int getNum()
	{
		return num;
	}
}


public class Test078
{
	public static void main(String[] args)
	{
		// NumberTest 클래스 (설계도) 기반의 인스턴스(객체)생성
		NumberTest nt1 = new NumberTest();
		//-- 인스턴스가 생성되는 시점에서
		//   이와 동시에 선택의 여지 없이 생성자 호출이 이루어진다.
		//								  -----------
		//								  NumberTest();
		//--==>> 생성자 호출~!!!
		
		/*
		NumberTest nt1 = new NumberTest;
								+
							 NumberTest();
		*/
		
		// nt1.NumberTest();
		//--==>> 에러 발생(컴파일 에러)
		//		 cannot find symbol
		
		int n = nt1.getNum();
		System.out.println(n);
		//--==>> 10
		
		System.out.println(nt1.getNum());
		//--==>> 10
		
		System.out.println(nt1.num);
		//--==>> 10
		
		nt1.num = 200;
		
		System.out.println(nt1.getNum());
		//--==>> 200
		
		System.out.println(nt1.num);
		//--==>> 200
		
		NumberTest nt2 = new NumberTest();
		//--==>> 생성자 호출~!!!
		
		System.out.println(nt2.num);
		//--==>> 10
		
		int testNum = nt2.getNum();
		System.out.println(testNum);
		//--==>> 10
		
		System.out.println(nt2.getNum());
		//--==>> 10
	}
}/*==============================
■■■ 클래스와 인스턴스 ■■■
- 생성자(Constructor)
===============================*/



class NumberTest2
{
	int num;
	
	// 디폴트 (default) 생성자 → 자동 삽입
	/*
	NumberTest2()
	{
	}
	*/
	
	// ※ 이경우는
	//	  사용자 정의 생성자가 정의되어 있으므로
	//	  default 생성자가 자동으로 삽입되지 않는다.
	
	// 생성자 → 사용자 정의 생성자
	NumberTest2(int n)
	{
		num = n;
		System.out.println("생성자 호출 시 매개변수 전달 : " + n);
	}
	
	
	int getNum()
	{
		return num;
	}
}
public class Test079
{
	public static void main(String[] args)
	{
		// NumberTest2 ob = new NumberTest2();
		//--==>> 에러발생 (컴파일 에러)
		//-- NumberTest2 클래스에는
		//   사용자 정의 생성자가 존재하고 있는 상황이기 때문에
		//   default 생성자가 자동으로 삽입되지 않으며
		//   사용자가 정의한 생성자는 매개변수를 갖는 형태이기 때문에
		//	 위(line 40) 와 같이 매개변수 없는 생성자를 호출하는 형태의 
		//	 인스턴스 생성 구문은 문제를 발생시키게 된다.
		
		//NumberTest2 인스턴스 생성
		NumberTest2 ob1 = new NumberTest2(10);
		//--==>> 생성자 호출 시 매개변수 전달 : 10
		
		
		// ob1 객체가 갖고있는 num속성에 접근
		System.out.println("ob1.num : " + ob1.num);
		//--==>> ob1.num : 10
		
		// ob1 객체가 갖고있는 getNum()메소드 호출
		System.out.println("ob1.getNum() : " + ob1.getNum());
		//--==>> ob1.getNum() : 10
		
		NumberTest2 ob2 = new NumberTest2(256);
		//--==>> 생성자 호출 시 매개변수 전달 : 256
		
		System.out.println("ob2.num : " + ob2.num);
		System.out.println("ob2.getNum() : "+ ob2.getNum());
		//--==>> ob2.num : 256
		//		 ob2.getNum() : 256
		
		
	}
}/*==============================
■■■ 클래스와 인스턴스 ■■■
- 생성자(Constructor)
===============================*/

public class Test080
{
	int x;
	
	// ※ 생성자의 이름은 항상 예외없이 클래스의 이름과 동일해야 하며,
	//    필요할 경우 인수를 받아들이는 것도 가능하고
	//    같은 이름의 메소드를 정의하는 중복 정의가 가능하지만,
	//    리턴값(반환값)은 가질 수 없다.
	
	// ※ 생성자는 일반 메소드처럼 호출될 수 없고,
	//    『new』 연산자를 이용하여 객체를 생성하기 위해 호출되며,
	//    각 클래스의 인스턴스인 객체를 생성한 후에
	//    생성된 객체의 멤버를 초기화 시키는 작업을 수행하게 되다.
	
	// 생성자
	Test080()
	{
		// ※ 생성자를 정의하는 구문 내부에서 다른 생성자를 호출하는 것은 가능하다.
		//	  (다른 일반적인 메소드처럼...)
		//    단, 생성자 내부에서 가장 먼저 실행되어야 한다.
		
		// 생성자 내부에서 또다른 생성자를 호출하는 구문
		// Test080(100);
		this(100);
		//-- Test080(100);
		
		// x=10;
		this.x = 10;
		//-- Test080.x = 10;
		
		System.out.println("인자 없는 생성자");
		//System.out.println("Test080이 갖고있는 x : " + x);
		System.out.println("Test080이 갖고있는 x : " + this.x);
	}
	
	// ※ 『this』 키워드 → Test080
	
	// 생성자
	Test080(int x)
	{
		// x = num;
		// x = x;			//-- 둘 다 지역변수
		
		this.x = x;
		//-- 논리적인 해석 → Test080.x( → this 키워드가 포함된 클래스의 이름으로 치환)
		
		
		System.out.println("인자가 하나인 생성자");
		System.out.println("Test080이 갖고있는 x : " + this.x);
	}
	
	public static void main(String[] args)
	{
		// Test080 클래스 기반 인스턴스 생성
		Test080 ob1 = new Test080();
		Test080 ob2 = new Test080(100);
		//--==>> 인자가 하나인 생성자
		//       Test080이 갖고있는 x : 100
		//       인자 없는 생성자
		//       Test080이 갖고있는 x : 10
		//       인자가 하나인 생성자
		//       Test080이 갖고있는 x : 100
		
		System.out.println();
		System.out.println("main 에서 ob1.x : " + ob1.x);
		System.out.println("main 에서 ob2.x : " + ob2.x); 
		//--==>> main 에서 ob1.x : 10
		//		 main 에서 ob2.x : 100
		
	}
}/*==============================
■■■ 클래스와 인스턴스 ■■■
- 생성자(Constructor)
===============================*/

public class Test081
{
	int val1;
	double val2;
	
	Test081()
	{
		val1=0;
		val2=0;
		System.out.println("매개변수 없는 생성자...");
	}
	
	// Test081(int x)
	Test081(int val1)
	{
		//val1=x;
		this.val1=val1;
		val2=0;
		System.out.println("int형 데이터를 매개변수로 받는 생성자...");
	}
	
	// Test081(double y)
	Test081(double val2)
	{
		val1=0;
		//val2=y;
		this.val2=val2;
		System.out.println("double형 데이터를 매개변수로 받는 생성자...");
	}
	
	// Test081(int x, double y)
	Test081(int val1, double val2)
	{
		//val1=x;
		//val2=y;
		this.val1=val1;
		this.val2=val2;
		System.out.println("int형과 double형 데이터를 매개변수로 받는 생성자...");
	}
	
	public static void main(String[] args)
	{
		Test081 ob1 = new Test081();
		System.out.println(ob1.val1 + ", " + ob1.val2);
		//--==>> 매개변수 없는 생성자...
		//       0, 0.0
		
		Test081 ob2 = new Test081(4);
		System.out.println(ob2.val1 + ", " + ob2.val2);
		//--==>> int형 데이터를 매개변수로 받는 생성자...
		//		 4, 0.0
		Test081 ob3 = new Test081(7.0);
		System.out.println(ob3.val1 + ", " + ob3.val2);
		//--==>> double형 데이터를 매개변수로 받는 생성자...
		//		 0, 7.0
		
		Test081 ob4 = new Test081(4, 7.0);
		System.out.println(ob4.val1 + ", " + ob4.val2);
		//--==>> int형과 double형 데이터를 매개변수로 받는 생성자...
		//		 4, 7.0
		
	}
}/*====================================================
■■■ 클래스와 인스턴스 ■■■
- 생성자(Constructor)와 초기화 블럭(Initialized Block)
======================================================*/

public class Test082
{
	// 수행할 수 없음
	// 변수 선언 후 대입하는 연산을 수행하기 때문에 
	/*
	int n;
	int m;
	
	n=100;
	m=200;
	*/
	
	// 수행할 수 있음
	// 선언과 동시에 초기화
	/*
	int n=100;
	int m=200;
	*/
	
	int n;
	int m;

	// 초기화 블럭(Initialized Block)
	{
		n=100;
		m=200;
		System.out.println("초기화 블럭 실행...");
	}
	
	// 생성자 → 사용자 정의 생성자
	Test082(int n, int m)
	{
		this.n=n;
		this.m=m;
		System.out.println("매개변수 있는 생성자 실행...");
	}
	
	// 생성자 → 사용자 정의 생성자
	Test082()
	{
		n=10;
		m=20;
		System.out.println("생성자 실행...");
	}
	
	
	// 멤버 출력 메소드 정의
	void write()
	{
		System.out.println("n: " + n + ", m: " + m); 
	}
	
	public static void main(String[] args)
	{
		Test082 ob1 = new Test082();
		//--==>> 초기화 블럭 실행...
		//		 생성자 실행...
		
		ob1.write();
		//--==>> n: 10, m: 20
		
		Test082 ob2 = new Test082(120,2500);
		//--==>> 초기화 블럭 실행...
		//		 매개변수 있는 생성자 실행...
		
		ob2.write();
		//--==>> n: 120, m: 2500
		
		
	}
}
/*====================================================
■■■ 배열 ■■■
- 배열의 선언과 초기화
======================================================*/

/*
○ 배열의 개요

	1. 자바에서의 배열이란 크기와 성격이 같은 일련의 원소들이 모여
	   공동의 집합 구조를 갖는 자료의 집합체를 의미하는 것으로
	   『동질의 성격을 가진 자료들』에 대해
	   개별적으로 자료형(Data Type)을 부여하지 않고
	   하나의 이름을 가지고 일괄적으로 처리할 목적으로 사용된다.
	
	2. 자바에서의 배열은 다음과 같은 순서에 의해 사용된다.
	   배열 선언 → 배열에 메모리 할당 → 배열 요소 접근(배열 요소의 사용)
	
	
○ 형식 및 구조

	int[] num = new int[5];
	num[0] = 100;
	num[1] = 200;
	num[2] = 300;

	
	int[] num1;
	
	double[] num2;
	
	String[] args;
	
	
	
	자료형[] 변수명;
	변수명 = new 자료형[요소크기];
	변수명[인덱스] = 값;
*/

public class Test083
{
	public static void main(String[] args)
	{
		// 배열 선언
		int[] arr;
		
		// 메모리 할당
		arr = new int[10];
		
		// 배열은 다음과 같이 선언과 동시에 
		// 메모리 할당 및 초기화가 가능하다.
		int[] arr2 = new int[10];				//-- 배열선언 + 메모리 할당
		int[] arr3 = {1,2,3,4,5,6,7,8,9,0};		//-- 배열선언 + 메모리 할당 + 초기화
		int arr4[] = {1,2,3,4,5,6,7,8,9,0};
		
		// 배열 요소 접근(사용)
		arr[0] = 1;
		arr[1] = 2;
		arr[2] = 3;
		
		// ※ 값을 할당하지 않은 나머지 배열 공간은
		//	  비어있는 것이 아니라 자동으로 초기화된다.→ 0 (int 배열)
		
		int num = 10;
		System.out.println("num : " + num);
		//--==>> num : 10
		
		System.out.println("arr : " + arr);
		//--==>> arr : [I@6d06d69c			// 해시코드 - 메모리의 주소값이 아니다.   
		//-- 배열을 출력하기 위해 배열 변수를 일반 변수처럼 사용하여
		//	 출력하는 구문으로 작성하게 되면
		//	 배열의 각 방에 들어있는 데이터가 출력되는 것이 아니라
		//	 우리가 알아볼 수 없는 형태의 코드가 출력된다.
		//	 출력되는 값은 메모리의 주소값이 아니다.
		//	 (자바는 메모리 주소값에 사용자가 직접 접근하는 것을 허용하지 않는다.)
		
		System.out.println("arr[0]: " + arr[0]);
		System.out.println("arr[1]: " + arr[1]);
		System.out.println("arr[2]: " + arr[2]);
		//--==>> arr[0]: 1
		//		 arr[1]: 2
		//		 arr[2]: 3
		
		
		System.out.println(arr[0] + " " + arr[1] + " " + arr[2] + " " + arr[3] + " " 
							+ arr[4] + " " + arr[5] + " " + arr[6] + " " + arr[7] + " " 
							+ arr[8] + " " + arr[9]);
		//--==>> 1 2 3 0 0 0 0 0 0 0
		
		// System.out.println(arr[10]);
		//--==>> 에러 발생(런타임 에러)
		//		 ArrayIndexOutOfBoundsException
		
		System.out.println();
		
		// 반복문을 활용하여 배열에 담긴 데이터 전체 출력
		for (int i=0; i<10; i++)
		{
			// 테스트(확인)
			// System.out.println("i : " + i);
			
			// 테스트(확인)
			// System.out.printf("%2d", arr[i]);
			
			// arr 배열의 0번째 방 : 1
			// arr 배열의 1번째 방 : 2
			// arr 배열의 2번째 방 : 3
			//			 :
			// arr 배열의 9번째 방 : 0
			
			System.out.printf("arr 배열의 %d번째 방 : %d\n",i,arr[i]);
		}
		System.out.println();
		
		
	}
}
// 실행 결과

/*
num : 10
arr : [I@6d06d69c
arr[0]: 1
arr[1]: 2
arr[2]: 3
1 2 3 0 0 0 0 0 0 0

arr 배열의 0번째 방 : 1
arr 배열의 1번째 방 : 2
arr 배열의 2번째 방 : 3
arr 배열의 3번째 방 : 0
arr 배열의 4번째 방 : 0
arr 배열의 5번째 방 : 0
arr 배열의 6번째 방 : 0
arr 배열의 7번째 방 : 0
arr 배열의 8번째 방 : 0
arr 배열의 9번째 방 : 0

계속하려면 아무 키나 누르십시오 . . .
*//*====================
■■■ 배열 ■■■
- 배열의 선언과 초기화
======================*/



// 임의의 정수들이 들어있는 배열
// 그 배열의 숫자 데이터들 중
// 짝수인 요소만 골라서 출력하고, 3의 배수인 요소만 골라서 출력하는 
// 프로그램을 구현한다.

// ※ 배열을 구성하는 임의의 정수 → 4 7 9 1 3 2 5 6 8

// 실행 예)
// 배열 요소 전체 출력
// 4 7 9 1 3 2 5 6 8
// 짝수 선택적 출력
// 4 2 6 8
// 3의 배수 선택적 출력
// 9 3 6
// 계속하려면 아무 키나 누르세요...

public class Test084
{
	public static void main(String[] args)
	{
		int i;
		
		// 배열 선언 및 초기화
		// 방법 ①
		/*
		int[] arr = new arr[9];
		arr[0] = 4;
		arr[1] = 7;
		arr[2] = 9;
		arr[3] = 1;
		arr[4] = 3;
		arr[5] = 2;
		arr[6] = 5;
		arr[7] = 6;
		arr[8] = 8;
		*/
		
		// 방법 ②
		int[] arr = {4,7,9,1,3,2,5,6,8};
		
		// System.out.println(arr);
		//--==>> [I@6d06d69c
		
		// ※ 일반적인 변수에 담긴 내용을 출력하는 형식(방법)으로는
		// 배열에 담긴 데이터들을 출력할 수 없다.
		
		/*
		System.out.println("배열 요소 전체 출력");
		for (i=0; i<9; i++)
		{
			System.out.print(arr[i] + " ");
		}
		System.out.println();	// 개행
		//--==>> 배열 요소 전체 출력
		//       4 7 9 1 3 2 5 6 8
		*/
		
		// int[] arrTest = {4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8,4,7,9,1,3,2,5,6,8};
		// arrTest.length
		// System.out.println(arrTest.length);
		//--==>> 216
		
		// System.out.println(arr.length);
		//--==>> 9
		
		// ※ 배열 arr 의 길이(방의 갯수) 확인
		// arr.length
		
		System.out.println("배열 요소 전체 출력");
		for (i=0; i<arr.length; i++)
		{
			System.out.print(arr[i] + " ");
		}
		System.out.println();	// 개행
		//--==>> 배열 요소 전체 출력
		//       4 7 9 1 3 2 5 6 8
		
		System.out.println("짝수 선택적 출력");
		for (i=0; i<arr.length; i++)
		{
			/*
			if (i%2== 0)		//-- i가 짝수라면...			→ 짝수번째 해당하는 요소라면...
			{
				// 출력해라		//-- 방 번호를...				→ 해당 인덱스를...
				// System.out.print(i + " ");
				
				// 출력해라		//-- 방 번호에 해당하는 값을... → 인덱스에 해당하는 값을...
				// System.out.print(arr[i] + " ");
			}
			*/
			
			if (arr[i]%2==0)	//-- i번째 요소의 값이 짝수라면...
			{
				// 출력해라		//-- 방 번호를...				→ 해당 인덱스를...
				// System.out.print(i + " ");
				
				// 출력해라		//-- 방 번호에 해당하는 값을... → 인덱스에 해당하는 값을...
				System.out.print(arr[i] + " ");
			}
		}
		System.out.println();	//개행
		//--==>> 짝수 선택적 출력
		//       4 2 6 8
		
		System.out.println("3의 배수 선택적 출력");
		for (i=0; i<arr.length; i++)
		{
			if (arr[i]%3==0)
				System.out.print(arr[i]+" ");
		}
		System.out.println();	// 개행
		//--==>> 3의 배수 선택적 출력
		//       9 3 6
		
		
		
		
		/*
		int[] arr = {4,7,9,1,3,2,5,6,8};
		
		System.out.println("배열 요소 전체 출력");
		
		for (int i=0; i<9; i++)
			System.out.printf("%2d",arr[i]);
			
		System.out.println();
		
		System.out.println("짝수 선택적 출력");
		
		for (int i=0; i<9; i++)
		{
			if (arr[i] % 2 == 0)
				System.out.printf("%2d",arr[i]);
		}
		System.out.println();
		
		System.out.println("3의 배수 선택적 출력");
		
		for (int i = 0; i<9; i++)
		{
			if (arr[i] % 3 == 0)
				System.out.printf("%2d",arr[i]);
		}
		System.out.println();
		*/
	}
}

// 실행 결과

/*
배열 요소 전체 출력
4 7 9 1 3 2 5 6 8
짝수 선택적 출력
4 2 6 8
3의 배수 선택적 출력
9 3 6
계속하려면 아무 키나 누르십시오 . . .
*/
/*======================
 ■■■ 배열 ■■■
 - 배열의 선언과 초기화 
 - 배열의 기본적 활용
========================*/

// 『char』 자료형 배열을 만들어
// 그 배열의 각 방에 알파벳 대문자를 채우고
// 채워진 그 배열의 전체 요소를 출력하는 프로그램을 구현한다.
// 단, 채우는 구문과 출력하는 구문은 따로 분리하여 처리할 수 있도록 한다.

// 실행 예)
// A B C D E F G ... V W X Y Z
// 계속하려면 아무 키나 누르세요...

public class Test085
{
	public static void main(String[] args)
	{
		// 영문 알파벳 대문자 배열 구성
		// 방법 ①
		char[] arr1;
		arr1 = new char[26];
		
		arr1[0] = 'A';
		arr1[1] = 'B';
		arr1[2] = 'C';
		//   :
		arr1[23] = 'X';
		arr1[24] = 'Y';
		arr1[25] = 'Z';
		
		
		// 방법 ②
		char[] arr2 = {'A', 'B', 'C', 'D', /*...*/'W', 'X', 'Y', 'Z'};
		
		// 방법 ③
		char[] arr3 = new char[26];
		for (int i=0, ch=65; i<arr3.length; i++, ch++)	// i → 0 1 2 3 4 ... 25, ch → 65 66 67 ... 90
			arr3[i] = (char)ch;
		
		// 배열 요소 전체 출력
		for (int i=0; i<arr3.length; i++)
			System.out.print(arr3[i] + " ");
		System.out.println();	//개행
		
		/*
		char[] arr = new char[26];
		char ch = 65;
		
		for (int i=0; i<arr.length; i++)
		{
			arr[i] = ch;
			ch++;
		}
		
		for (int i=0; i<arr.length; i++)
				System.out.print(arr[i] + " ");
		System.out.println();
		*/
	}
}
 
// 실행 결과

/*
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
계속하려면 아무 키나 누르십시오 . . .
*/
/*======================
 ■■■ 배열 ■■■
 - 배열의 선언과 초기화 
 - 배열의 기본적 활용
========================*/

// 사용자로부터 인원수를 입력받고
// 입력받은 인원수만큼의 학생 이름과 전화번호를 입력받고
// 이렇게 입력받은 데이터를 이름 배열과 전화번호 배열로 구성하여
// 결과를 출력할 수 있는 프로그램을 구현한다.

// 실행 예)
// 입력 처리할 학생 수 입력(명, 1~10) : 37
// 입력 처리할 학생 수 입력(명, 1~10) : 0
// 입력 처리할 학생 수 입력(명, 1~10) : 3
// 이름 전화번호 입력[1](공백 구분)	  : xxx 010-1111-1111
// 이름 전화번호 입력[2](공백 구분)	  : xxx 010-2222-2222
// 이름 전화번호 입력[3](공백 구분)	  : xxx 010-3333-3333

//------------------------
// 전체 학생 수 : 3
//------------------------
// 이름		전화번호
// xxx		010-1111-1111
// xxx		010-2222-2222
// xxx		010-3333-3333
//------------------------
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;

public class Test086
{
	public static void main(String[] args)
	{
		// Scanner 인스턴스 생성
		Scanner sc = new Scanner(System.in);
		
		// 사용자가 입력하는 학생 수를 담아낼 변수
		int memberCount = 0;
		
		do
		{
			System.out.print("입력 처리할 학생 수 입력(명, 1~10) : ");
			memberCount = sc.nextInt();
		}
		while (memberCount<1 || memberCount>10);
		
		//테스트(확인)
		// System.out.println("사용자가 입력한 인원 수 : " + memberCount);
		
		// 사용자가 입력한 인원 수 확정
		// 이 인원 수를 토대로
		// 이름 배열과 전화번호 배열을 생성해야 한다.
		
		// 인원 수 만큼의 이름 저장 배열 구성 
		String[] names = new String[memberCount];
		
		// 인원 수 만큼의 전화번호 저장 배열 구성
		// String[] tels = new String[memberCount];
		String[] tels = new String[names.length];
		
		// 인원 수 만큼의 안내 메세지 출력 및 입력값 담아내기
		//for (int i=0; i<memberCount; i++)
		//for (int i=0; i<names.length; i++)
		for (int i=0; i<tels.length; i++)		//-- 입력받은 인원 수 만큼 반복	
		{
			System.out.printf("이름 전화번호 입력[%d](공백 구분)  : ",(i+1));
			
			// 윤영식 010-1111-1111
			//-------
			names[i] = sc.next();
			
			
			// 윤영식 010-1111-1111
			//		  -------------
			tels[i] = sc.next();
		}
		
		// 최종 결과(이름, 전화번호) 출력
		System.out.println();	// 개행
		System.out.println("-------------------------");
		System.out.printf("전체 학생 수 : %d명\n",memberCount);
		// memebrCount == names.length == tels.length
		System.out.println("-------------------------");
		System.out.println("이름       전화번호");
		
		//학생 리스트 반복 출력
		for (int i=0; i<memberCount; i++)
		{
			System.out.printf("%3s %14s\n",names[i],tels[i]);
		}
		System.out.println("-------------------------");
		
		
		
		
		
		
		
		
		/*
		Scanner sc = new Scanner(System.in);
		int n;
		
		
		do
		{
			System.out.print("입력 처리할 학생 수 입력(명, 1~10) : ");
			n = sc.nextInt();
		}
		while (n<1 || n>10);
		
		String[] name = new String[n];
		String[] tel = new String[n];
		
		for (int i=0,j=0; i<n; i++,j++)
		{
			System.out.printf("이름 전화번호 입력[%d](공백 구분) : ",j+1);
			name[j] = sc.next();
			tel[j]	= sc.next();	
		}
		
		System.out.println("------------------------------");
		System.out.printf("전체 학생 수 : %d명\n",n);
		System.out.println("------------------------------");
		System.out.println("이름     전화번호");
		for (int i=0; i<n; i++)
		{
			System.out.println(name[i] + "    " + tel[i]);
		}	
		*/
	}
}
// 실행 결과

/*
입력 처리할 학생 수 입력(명, 1~10) : 3
이름 전화번호 입력[1](공백 구분)  : 윤영식 010-1111-1111
이름 전화번호 입력[2](공백 구분)  : 가나다 010-2222-2222
이름 전화번호 입력[3](공백 구분)  : 라마바 010-3333-3333

-------------------------
전체 학생 수 : 3명
-------------------------
이름         전화번호
윤영식  010-1111-1111
가나다  010-2222-2222
라마바  010-3333-3333
-------------------------
계속하려면 아무 키나 누르십시오 . . .
*//*======================
 ■■■ 배열 ■■■
 - 배열의 선언과 초기화 
 - 배열의 기본적 활용
========================*/

// 사용자로부터 임의의 정수를 임의의 갯수만큼 입력받아
// 입력받은 수 중에서 가장 큰 술를 출력하는 프로그램을 구현한다.
// 단, 배열을 활용하여 구현할 수 있도록 한다.

//실행 예)
// 입력할 데이터의 갯수 :12
// 데이토 입력(공백 구분) : 74 65 98 12 36 67 42 88 50 25 17 46

// >> 전체 출력 : 74 65 98 12 36 67 42 88 50 25 17 46
// >> 가장 큰 수 → 98
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;

public class Test087
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("입력할 데이터의 갯수 : ");
		int size = sc.nextInt();
		
		// 입력받은 수 만큼의 길이를 갖는 배열 생성
		int[] arr = new int[size];
		
		// 사용자에게 안내 메세지 출력
		System.out.print("데이터 입력(공백 구분) : ");		// 10 20 30 40 50
		
		// 입력받아오는 항목의 갯수만큼 반복할 수 있는 코드 구성
		// → 공백으로 구분되어 입력된 데이터를 배열에 담아내기
		//for (int a=0; a<size; a++)
		for (int a=0; a<arr.length; a++)
			arr[a] = sc.nextInt();
		
		// 배열 요소 전체 출력
		System.out.print("\n>> 전체 출력 : ");
		
		int max = arr[0];			//-- 최대값을 담을 변수
		
		//for (int a=0; a<size; a++)
		for (int a=0; a<arr.length; a++)
		{
			//System.out.printf("%3d",arr[a]);
			System.out.print(arr[a] + " ");
			
			// 배열 요소를 출력하는 동안 가장 큰 값 저장
			if (max < arr[a])
				max = arr[a];
		}
		System.out.println();
		
		// 가장 큰 수 출력
		System.out.printf(">> 가장 큰 수 → %d\n",max);
		
		

		/*
		Scanner sc = new Scanner(System.in);
		int numberCount;
		
		System.out.print("입력할 데이터의 갯수 : ");
		numberCount = sc.nextInt();
		
		int[] num = new int[numberCount];
		
		System.out.print("데이터 입력(공백 구분) : ");
		for (int i=0; i<numberCount; i++)
		{
			num[i] = sc.nextInt();	
		}
		
		
		int temp = 0;
		
		for (int i=0; i<numberCount; i++)
		{
			if (num[i]>temp)
			{	
				temp = num[i];
			}
		}
		
		System.out.printf(">> 가장 큰 수 → %d\n",temp);
		*/
	
	}
}
// 실행 결과

/*
입력할 데이터의 갯수 : 10
데이터 입력(공백 구분) : 630 71 910 4 8 16 22 80 99 1000

>> 전체 출력 : 630 71 910 4 8 16 22 80 99 1000
>> 가장 큰 수 → 1000
계속하려면 아무 키나 누르십시오 . . .
*//*======================
 ■■■ 배열 ■■■
 - 배열의 선언과 초기화 
 - 배열의 기본적 활용
========================*/

// 사용자로부터 임의의 학생 수를 입력받고
// 입력받은 학생 수 만큼의 점수(정수형태)를 입력받아
// 전체 학생 점수의 합, 평균, 편차를 구하여
// 결과를 출력하는 프로그램을 구현한다.
// 단, 배열을 활용하여 처리할 수 있도록 한다.

// 실행 예)
// 학생 수 입력 : 5
// 1번 학생의 점수 입력 : 90
// 2번 학생의 점수 입력 : 90
// 3번 학생의 점수 입력 : 90
// 4번 학생의 점수 입력 : 90
// 5번 학생의 점수 입력 : 90

// >> 합 : 370
// >> 평균 : 74.0
// >> 편차
// 90 : -16.0
// 82 : -8.0
// 64 : 10.0
// 36 : 38.0
// 98 : -24.0

import java.util.Scanner;

public class Test088
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("학생 수 입력 : ");
		int count = sc.nextInt();			//-- ex) 5
		
		// 배열의 선언 및 정의(메모리 할당)
		int[] a = new int[count];			//-- new int[5] → 0 ~ 4 가능, 5 사용 불가
		
		int tot = 0;						//-- 누적합 연산을 위한 초기화
		double avg;
		
		// 반복해서 입력받는 과정
		//for (int i =0; i<count; i++)
		for (int i=0; i<a.length; i++)
		{
			System.out.print((i+1) + "번 학생의 점수 입력 : ");
			a[i] = sc.nextInt();
			tot += a[i];					//-- 총점 누적
		}
		
		//tot/ count
		avg = (double)tot / a.length;
		
		System.out.println("\n>> 합 : " + tot);
		System.out.printf(">> 평균 : %.1f\n",avg);
		System.out.println(">> 편차");
		
		/*
		for (int i=0; i<a.length; i++)
		{
			System.out.println(a[i] + " : " + (avg-a[i]));
		}
		*/
		
		// 향상된 for문(forEach 구문)
		/*
		for (타입 변수명 : 자료구조)
		{
			변수명을 이용한 처리;
		}
		*/
		
		/*
		for (int n : a)
		{
			//System.out.ptintln("for 문의 회전 ~!!!");
			//System.out.println(n);
			System.out.println(n + " : " + (avg-n));
		}
		*/
		
		for (int n : a)
		{
			//System.out.println(n + " : " + (avg-n));
			System.out.printf("%d : %.1f\n",n, (avg-n));
		}
		
		
		
		
		/*
		Scanner sc = new Scanner(System.in);
		
		int member;
	
		System.out.print("학생 수 입력 : ");
		member = sc.nextInt();
		
		int[] score = new int[member];
		
		for (int i=0; i<member; i++)
		{
			System.out.printf("%d번째 학생의 점수 입력 : ",(i+1));
			score[i] = sc.nextInt();
		}
		
		int tot=0;
		double avg=0;
		double[] dev = new double[member]; 
		
		for (int i=0; i<member; i++)
		{
			tot += score[i];
		}
		avg = (double)tot / member;
		
		System.out.printf(">> 합 : %d\n",tot);
		System.out.printf(">> 평균 : %.1f\n",avg);
		System.out.println(">> 편차");
		
		for (int i=0; i<member; i++)
		{
			dev[i] = avg - score[i];
			System.out.printf("%d : %.1f\n",score[i],dev[i]);
		}
		*/
	}
}
// 실행 결과

/*
학생 수 입력 : 5
1번 학생의 점수 입력 : 87
2번 학생의 점수 입력 : 65
3번 학생의 점수 입력 : 76
4번 학생의 점수 입력 : 77
5번 학생의 점수 입력 : 98

>> 합 : 403
>> 평균 : 80.6
>> 편차
87 : -6.4
65 : 15.6
76 : 4.6
77 : 3.6
98 : -17.4
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열)
==========================*/

public class Test089
{
	public static void main(String[] args)
	{
		// 배열의 배열 선언과 초기화
		// 방법 ①
		//int[] arr1 = new int[3];
		int[][] arr1 = new int[3][3];
		
		//arr1[0] =1;
		arr1[0][0] = 1;
		arr1[0][1] = 2;
		arr1[0][2] = 3;
		arr1[1][0] = 4;
		arr1[1][1] = 5;
		arr1[1][2] = 6;
		arr1[2][0] = 7;
		arr1[2][1] = 8;
		arr1[2][2] = 9;
		
		// 방법 ②
		//int[] arr2 = {1, 2, 3};
		int[][] arr2 = {{1, 2, 3}, {4 , 5, 6}, {7, 8, 9}};
		
		// 방법 ③
		int[][] arr3 = new int[3][3];
		int n = 1;
		for (int i=0; i<arr3.length; i++)			// 웅~~~~~ 0       1      2
		{
			for (int j=0; j<arr3[i].length; j++)	// 쑝쑝쑝 0 1 2  0 1 2  0 1 2
			{
				//System.out.println("i:" + i + ", " + "j:" + j);
				arr3[i][j] = n;
				n++;
				
				/*
				i:0, j:0
				i:0, j:1
				i:0, j:2
				i:1, j:0
				i:1, j:1
				i:1, j:2
				i:2, j:0
				i:2, j:1
				i:2, j:2
				*/
				
			}
		}
		
		// 배열의 배열(다차원 배열) 요소 전체 출력
		for (int i=0; i<arr3.length; i++)
		{
			for (int j=0; j<arr3[i].length; j++)
			{
				System.out.printf("%2d",arr3[i][j]);
			}
			System.out.println();
		}
		//--==>>  1 2 3
		//        4 5 6
        //		  7 8 9
		
		
		
	}
}
/*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열)
==========================*/

// 다차원 배열(배열의 배열)을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열(5*5)울 규성하고
// 그결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*					//-- 위치 확인
 1  2  3  4  5		// 00 01 02 03 04 
 6  7  8  9 10		// 10 11 12 13 14
11 12 13 14 15		// 20 21 22 23 24
16 17 18 19 20		// 30 31 32 33 34
21 22 23 24 25		// 40 41 42 43 44
계속하려면 아무 키나 누르세요...
*/
public class Test090
{
	public static void main(String[] args)
	{
		// 배열의 배열 선언
		//int[][] arr;
		
		// 배열의 배열 메모리 할당
		//arr = new int[5][5];
		
		// 배열의 배열 선언 + 메모리 할당
		int[][] arr = new int[5][5];
		
		// 주요 변수 선언 및 초기화
		int n = 1;									//-- 1 2 3 4 5 ... 21 22 23 24 25
		
		// 배열의 배열을 반복문의 중첩 구문을 활용하여 데이터 구조화
		for (int i=0; i<arr.length; i++)			//-- 웅 → outer →   0	    1	  2     3     4 
		{
			for (int j=0; j<arr[i].length; j++)		//-- 쑝 → inner → 01234 01234 01234 01234 01234
			{
				// 00 01 02 03 04
				// 10 11 12 13 14
				//		:
				// 40 41 42 43 44
				
				arr[i][j] = n;
				n++;
			}
		}
		
		//-------------------------여기까지 수행하면 배열의 각 방에 값 담아내기 완료
		
		// 전체 요소 출력
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
			{
				System.out.printf("%3d",arr[i][j]);
			}
			System.out.println();
		}
		
		
		/*
		int[][] arr = new int[5][5];
		int n=1;
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
			{
				arr[i][j] = n;
				n++;
				System.out.printf("%3d",arr[i][j]);
			}
			System.out.println();
		}
		*/
	}
}

// 실행 결과

/*
  1  2  3  4  5
  6  7  8  9 10
 11 12 13 14 15
 16 17 18 19 20
 21 22 23 24 25
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열)
==========================*/

// 다차원 배열을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
  1  2  3  4  5
  2  3  4  5  6
  3  4  5  6  7
  4  5  6  7  8
  5  6  7  8  9
계속하려면 아무 키나 누르세요...
*/

public class Test091
{
	public static void main(String[] args)
	{
		// 배열의 배열 선언 및 메모리 할당
		int[][] arr = new int[5][5];
		
		// 주요 변수 선언
		int n;
		
		// 배열 구성
		for (int i=0; i<arr.length; i++)		//-- 웅
		{
			n=i+1;
			for (int j=0; j<arr.length; j++)	//-- 쓩
			{
				//테스트(확인)
				// System.out.print(i + ", " + j + " ");
				// System.out.print("[" + n + "]  ");
				// System.out.print("[" + n++ + "]  ");
				arr[i][j]=n;
				n++;
			}
			// System.out.println();			//-- 확인 과정에서의 개행
		}
		
		// 배열 요소 전체 출력
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr.length; j++)
				System.out.printf("%3d",arr[i][j]);
			System.out.println();
		}
		
		
		
		
		
		
		/*
		int[][] arr = new int[5][5];
		int n = 1;
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
			{
				arr[i][j] = n+i;
				n++;
			}
			n=1;
		}
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
				System.out.printf("%2d",arr[i][j]);
			System.out.println();
		}
		*/
	}
}

// 실행 결과

/*
  1  2  3  4  5
  2  3  4  5  6
  3  4  5  6  7
  4  5  6  7  8
  5  6  7  8  9
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열);
==========================*/

// 다차원 배열을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
  1  2  3  4  5
  5  1  2  3  4
  4  5  1  2  3
  3  4  5  1  2
  2  3  4  5  1 
계속하려면 아무 키나 누르세요...
*/

/*
  1  2  3  4  5		|	1  2  3  4  5 |
  5  1  2  3  4		|	   1  2	 3  4 |  5
  4  5  1  2  3		|		  1  2  3 |  4  5
  3  4  5  1  2		|			 1  2 |  3  4  5
  2  3  4  5  1		|			    1 |  2  3  4  5
  
									 j:5 → 0
					|  00 01 02 03 04 |			      → i:0	
					|     11 12 13 14 | 10		      → i:1	
					|        22 23 24 |	20 21	      → i:2
					|           33 34 |	30 31 32	  → i:3
					|              44 |	40 41 42 43   → i:4
						
*/

public class Test092
{
	public static void main(String[] args)
	{
		// 배열의 배열 선언
		int[][] arr = new int[5][5];
		
		for (int i=0; i<arr.length; i++)		//-- 웅~~~ i → 0     1     2     3     4 
		{
			for (int n=1, j=i; n<=5; n++)		//-- 쑝쑝  n → 12345 12345 12345 12345 12345
			{									//         j → 01234 12345 23456 34567 45678
												//				01234 12340 23401 34012 40123
				arr[i][j] = n;
				j++;
				
				if (j == 5)
					j=0;
				/*
				arr[0][0] = 1;  arr[0][1] = 2;  arr[0][2] = 3;  arr[0][3] = 4;  arr[0][4] = 5;
				arr[1][1] = 1;  arr[1][2] = 2;  arr[1][3] = 3;  arr[1][4] = 4;  arr[1][0] = 5;
				arr[2][2] = 1;  arr[2][3] = 2;  arr[2][4] = 3;  arr[2][0] = 4;  arr[2][1] = 5;
				arr[3][3] = 1;  arr[3][4] = 2;  arr[3][0] = 3;  arr[3][1] = 4;  arr[3][2] = 5;
				arr[4][4] = 1;  arr[4][0] = 2;  arr[4][1] = 3;  arr[4][2] = 4;  arr[4][3] = 5;
				
				arr[0][0] = 1;  arr[0][1] = 2;  arr[0][2] = 3;  arr[0][3] = 4;  arr[0][4] = 5;
				arr[1][0] = 5;  arr[1][1] = 1;  arr[1][2] = 2;  arr[1][3] = 3;  arr[1][4] = 4; 
				arr[2][0] = 4;  arr[2][1] = 5;  arr[2][2] = 1;  arr[2][3] = 2;  arr[2][4] = 3;  
				arr[3][0] = 3;  arr[3][1] = 4;  arr[3][2] = 5;  arr[3][3] = 1;  arr[3][4] = 2;  
				arr[4][0] = 2;  arr[4][1] = 3;  arr[4][2] = 4;  arr[4][3] = 5;  arr[4][4] = 1;  
				*/
			}
		}
		
		// 배열의 배열 전체 요소 출력
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr.length; j++)
				System.out.printf("%3d",arr[i][j]);
			System.out.println();
		}
		
		
		
		
		
		/*
		int[][] arr = new int[5][5];
		int n=1;
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr.length; j++)
			{
				if (i == j)
					n=1;
				
				arr[i][j] = n;
				n++;
			}
			n=5-i;
		}
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr.length; j++)
				System.out.printf("%3d",arr[i][j]);
			System.out.println();
		}
		*/
	}
}

// 실행 결과

/*
  1  2  3  4  5
  5  1  2  3  4
  4  5  1  2  3
  3  4  5  1  2
  2  3  4  5  1
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열);
==========================*/

// 다차원 배열을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
  1  8  9 16 17
  2  7 10 15 18
  3  6 11 14 19
  4  5 12 13 20
계속하려면 아무 키나 누르세요...
*/

/*			   i 짝수						 i 짝수						   i 짝수
			 0  0  0  0	    1  1  1  1	   2  2  2  2     3  3  3  3     4  4  4  4 
웅~~~~~		 i  i  i  i		i  i  i  i	   i  i  i  i     i  i  i  i     i  i  i  i
			 |  |  |  |		|  |  |  |	   |  |  |  |	  |  |  |  |     |  |  |  |
			00 10 20 30    31 21 11 01    02 12 22 32    33 23 13 03    04 14 24 34
			|  |  |  |	   |  |  |  |	  |  |  |  |	 |  |  |  |     |  |  |  |	
쑝쑝쑝쑝	j  j  j  j	   j  j  j  j	  j  j  j  j	 j  j  j  j     j  j  j  j	
0123		0  1  2  3     3  2  1  0	  0  1  2  3	 3  2  1  0     0  1  2  3
(방향성)    ========>>	   <<========	  ========>>	 <<========		========>>

*/
public class Test093
{
	public static void main(String[] args)
	{
		// 다차원 배열 선언 및 메모리 할당
		int[][] arr = new int[4][5];
		
		int n = 0;					// 1 ~ 20
		
		for (int i=0; i<5; i++)		// outer 웅~~~~~  i → 0 1 2 3 4	
		{
			for (int j=0; j<4; j++) // inner 쑝쑝쑝쑝 j → 0 1 2 3	
			{
				n++;
				
				// 테스트(확인)
				// System.out.println("n : " + n);
				//arr[j][i] = n;
				
				if (i%2==0)			// i가 짝수 일때	0			2			4
					arr[j][i] = n;	// j를 0123			00 10 20 30	02 12 22 32 04 14 24 34 
				else				// i가 짝수 아닐 때 1			3
					arr[3-j][i] = n;// j를 3210			31 21 11 01 33 23 13 03  
				
				
				
			}
		}
		
		
		// 배열의 배열 전체 요소 출력
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
				System.out.printf("%3d",arr[i][j]);
			System.out.println();
		}
		
		
		
		
		/*
		int[][] arr = new int[4][5];
		int n=1;
		
		for (int j=0; j<5; j++)
		{
			if (j % 2 == 0)
			{
				for (int i=0; i<arr.length; i++)
				{
					arr[i][j] = n;
					n++; 
				}
			}
			else
				for (int i=arr.length-1; i>=0; i--)
				{
					arr[i][j] = n;
					n++;
				}
		}
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
				System.out.printf("%3d",arr[i][j]);
			System.out.println();
		}
		*/
	}
}

// 실행 결과

/*
  1  8  9 16 17
  2  7 10 15 18
  3  6 11 14 19
  4  5 12 13 20
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열);
==========================*/

// 다차원 배열을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
  E  J  O  T  Y
  D  I  N  S  X
  C  H  M  R  W
  B  G  L  Q  V
  A	 F  K  P  U
계속하려면 아무 키나 누르세요...
*/
//  i  i  i  i  i		 i  i  i  i  i		 i  i  i  i  i		 i  i  i  i  i		 i  i  i  i  i
//	|  |  |  |  |		 |  |  |  |  |		 |  |  |  |  |		 |  |  |  |  |		 |  |  |  |  |	
// 40 30 20 10 00		41 31 21 11 01		42 32 22 12 02		43 33 23 13 03		44 32 24 14 04
// |  |  |  |  |		|  |  |  |  |		|  |  |  |  |		|  |  |  |  |		|  |  |  |  |
// j  j  j  j  j
public class Test094
{
	public static void main(String[] args)
	{
		// 다차원 배열 선언 및 메모리 할당
		char[][] arr = new char[5][5];
		
		char start = 'A';				// 65
		
		for (int i=0; i<5; i++)			// outer → 웅 → i : 0		1	  2		3	  4
		{
			for (int j=0; j<5; j++)		// inner → 쑝 → j : 43210 43210 43210 43210 43210  
			{
				arr[4-j][i] = start++;
			}
		}
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
				System.out.printf("%3c",arr[i][j]);
			System.out.println();
		}
		
		
		/*
		char[][] arr = new char[5][5];
		char ch = 'A';
		
		for (int i=0; i<5; i++)
		{
			for (int j=0; j<5; j++)
			{
				arr[4-j][i] = ch;
				ch++;
			}
		}
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
				System.out.printf("%3c",arr[i][j]);
			System.out.println();
		}
		*/
	}
}

/*
  E  J  O  T  Y
  D  I  N  S  X
  C  H  M  R  W
  B  G  L  Q  V
  A  F  K  P  U
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열);
==========================*/

// 다차원 배열을 활용하여
// 다음과 같은 데이터를 요소로 취하는 배열을 구성하고
// 그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
  1   2   3   4  10
  5   6   7   8  26
  9  10  11  12  42
 13  14  15  16  58
 28	 32  36  40 136
계속하려면 아무 키나 누르세요...
*/

// Hint : 반복문 처리가 필요한 영역 vs. 반복문 처리가 필요하지 않은 영역
/*
	
	※ 반복문의 처리가 필요한 영역		|		※ 반복문의 처리가 필요하지 않은 영역
										|	
					1   2   3   4		|	10
					5   6   7   8		|	26
					9  10  11  12  		|	42
				   13  14  15  16		|	58
										|
				   ---------------------
				   28  32  36  40          136 



*/

public class Test095
{
	public static void main(String[] args)
	{
		int[][] arr = new int[5][5];
		int n=0;
		
		// 테스트 변수
		// int sum=0;
		
		// 배열 요소 구성
		for (int i=0; i<arr.length-1; i++)			// outer → 웅~~ → i : 0 1 2 3
		{
			for (int j=0; j<arr[i].length-1; j++)	// inner → 쑝쑝 → j : 0 1 2 3
			{
				n++;								// n : 1 2 3 4 5 ... 13 14 15 16
				arr[i][j] = n;
				
				// sum += arr[i][j];
				// System.out.printf("%4d",sum);
				
				arr[i][arr[i].length-1] += arr[i][j];
				// arr[0][4] += arr[0][0];
				//			 += arr[0][1];
				//			 += arr[0][2];
				//			 += arr[0][3];
				
				arr[arr.length-1][j] += arr[i][j];
				// arr[4][0] += arr[0][0];
				//			 += arr[1][0];
				//			 += arr[2][0];
				//			 += arr[3][0];
				
				arr[arr.length-1][arr[i].length-1] += arr[i][j];
				// arr[4][4] += arr[0][0];
				//			 += arr[0][1];
				//			 += arr[0][2];
				//					:
				//			 += arr[3][3];
				
				
				
			}
		}
		
		// System.out.println();						// 테스트를 위한 개행
		
		
		// 배열 요소 전체 출력
		for (int i=0; i<arr.length ; i++)
		{
			for (int j=0; j<arr[i].length; j++)
				System.out.printf("%4d",arr[i][j]);
			System.out.println();
		}
		
		
		
		
		
		
		
		
		
		
		
		
		
		
		/*
		int[][] arr = new int[5][5];
		
		int n=1,tot=0;
		
		for (int i=0; i<4; i++)
		{
			for (int j=0; j<4; j++)
			{
				arr[i][j] = n;
				n++;
			}
		}
		
		for (int i=0; i<5; i++)
		{
			for (int j=0; j<5; j++)
			{
				arr[4][j] += arr[4-i][j];
				arr[i][4] += arr[i][4-j];
				arr[4][4]=0;
			}
		}
		
		for (int i=0; i<4; i++)
		{
			tot += arr[i][4];
			arr[4][4] = tot;
		}
		
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
				System.out.printf("%3d",arr[i][j]);
			System.out.println();
		}
		*/
	}
}

/*
   1   2   3   4  10
   5   6   7   8  26
   9  10  11  12  42
  13  14  15  16  58
  28  32  36  40 136
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열)
==========================*/

// ○ 과제
//	  다차원 배열을 활용하여
//	  다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//	  그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
  A
  B C
  D E F
  G H I J
  K L M N O

계속하려면 아무 키나 누르세요... 
*/


public class Test096
{
	public static void main(String[] args)
	{
		char[][] arr = new char[5][5];
		char ch = 'A';
	
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
			{
					if (j>=i+1)
						continue;
					
					arr[i][j] = ch;
					ch++;
			}
		}
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0; j<arr[i].length; j++)
			{
				System.out.printf("%2c",arr[i][j]);
			}
			System.out.println();
		}
	}
}

/*
 A
 B C
 D E F
 G H I J
 K L M N O
계속하려면 아무 키나 누르십시오 . . .
*//*=========================
 ■■■ 배열 ■■■
 - 다차원 배열(배열의 배열)
==========================*/

// ○ 과제
//	  다차원 배열을 활용하여
//	  다음과 같은 데이터를 요소로 취하는 배열을 구성하고
//	  그 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
/*
  A
  C B
  D E F
  J I H G
  K L M N O

계속하려면 아무 키나 누르세요... 
*/


public class Test097
{
	public static void main(String[] args)
	{
		char[][] arr = new char[5][5];
		
		char ch = 'A';
		
		for (int i=0; i<arr.length; i++)
		{
			if (i % 2 == 1)
			{
				for (int j=arr[i].length-1; j>=0; j--)
				{
					if (j>i)
						continue;
			
					arr[i][j]=ch;
					ch++;
				}
			}
			else
			{
				for (int j=0; j<arr[i].length ; j++)
				{
					if (j>=i+1)
						continue;

					arr[i][j]=ch;
					ch++;
				}
			}
		}
		
		for (int i=0; i<arr.length; i++)
		{
			for (int j=0;j<arr[i].length ; j++)
				System.out.printf("%2c",arr[i][j]);
			System.out.println();
		}
		
	}
}
/*=========================================
 ■■■ 배열 ■■■
 - 배열과 난수 처리(※ Random 클래스 활용)
==========================================*/

// 사용자로부터 임의의 정수를 입력받아
// 그 정수의 갯수만큼 난수(1 ~ 100)를 발생시커 배열에 담고
// 배열에 담겨있는 데이터들 중
// 가장 큰 값과 가장 작은 값을 선택하여
// 결과를 출력하는 프로그램을 구현한다.

// ※ 난수 발생 전용 객체 → 『java.util.Random』

// 실행 예)
// 발생시킬 난수의 갯수 입력 : 10
// (내부적으로 무장위 난수 발생... → 50 78 93 61 13 5 46 1 45 22)
// (배열에 담아내기... → int[] arr = {50, 78, 93, 61, 13, 5, 46, 1, 45, 22})
// 가장 큰 값 : 93, 가장 작은 값 : 1
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;
import java.util.Random;

public class Test098
{
	public static void main(String[] args)
	{
		//Scanner 인스턴스 생성
		Scanner sc = new Scanner(System.in);
		
		//주요변수 선언
		int size;				//-- 사용자의 입력값을 담아낼 변수 → 배열의 길이
		
		// 안내 메세지 출력
		System.out.print("발생시킬 난수의 갯수 입력 : ");
		size = sc.nextInt();
		
		// size 배열에 담아낸 수 만크의 방(길이)를 가진 배열 만들기
		// 즉, 배열 선언 및 메모리 할당
		int[] arr = new int[size];
		
		// 무작위 정수(난수)를 발생시키기 위해서는
		// 난수 발생 전용 객체가 필요하다.
		// → 『java.util.Random』
		Random rd = new Random();
		// Random 클래스의 인스턴스 생성
		
		// ※ Random 객체의 『nextInt()』 메소드
		//	  0 ~ 매개변수로 넘겨받은 정수 n → n-1 까지의 수 중
		//	  무작위 정수(난수) 1개를 발생시킨다.
		//	  ex) 
		//    rd.nextInt(10);	 → 0 ~ 9 중 1개 발생
		
		// 테스트(확인)
		// System.out.println("발생한 난수 확인 : " + rd.nextInt(10));
		//--==>> 발생한 난수 확인 : 0
		//		 발생한 난수 확인 : 1
		//		 발생한 난수 확인 : 6
		//		 발생한 난수 확인 : 7
		//		 발생한 난수 확인 : 8
		//		 발생한 난수 확인 : 8
		//		 발생한 난수 확인 : 7
		//		 발생한 난수 확인 : 4
		//-- 0 ~ 9 까지의 범위 내에서 무작위 정수 한 개 발생!!
		
		// for (int i=0; i<arr.length; i++)
		for (int i=0; i<size; i++)
		{
			// 난수 발생
			// rd.nextInt(size);
			//-- (X)
			
			// rd.nextInt(100);
			//-- 0 ~ 99 중 1개 발생
			
			//rd.nextInt(101);
			//-- 0 ~ 100 중 1개 발생
			
			//rd.nextInt(100)+1;
			//-- 1 ~ 100 중 1개 발생
			
			arr[i] = rd.nextInt(100)+1;
			//		 ---------------
			//		     0 ~ 99
			//		 ------------------
			//			   1 ~ 100
			
			
		}
		
		
		
		// 테스트(확인) → 배열 요소 전체 출력
		
		for (int i=0; i<arr.length; i++)
		{
			System.out.print(arr[i] + " ");
		}
		System.out.println();
		//--==>> 발생시킬 난수의 갯수 입력 : 10
		//       32 45 64 7 69 64 70 46 41 76
		//		 발생시킬 난수의 갯수 입력 : 10
		//		 39 85 95 89 93 16 86 79 95 59
		//	     발생시킬 난수의 갯수 입력 : 10
		//		 95 77 51 97 6 65 84 81 92 66
		
		//------------------------------------------여기까지 수행하면 배열 구성 완료!!
		
		// 가장 작은 값, 가장 큰 값 출력!
		
		int max,min;				//-- 최대값, 최소값
		min=max=arr[0];				//-- arr[0]의 값을 max에 대입하고
									//	 max의 값을 다시 min에 대입
									
		for (int i=1; i<arr.length; i++)
		{
			if (max<arr[i])
				max = arr[i];
			
			if (min>arr[i])
				min = arr[i];
		}
		
		// 결과 출력
		System.out.printf("가장 큰 값 : %d, 가장 작은 값 : %d\n",max,min);
		
		
		
		
		/*
		int max= arr[0];
		int min= arr[0];
		
		for (int i=0; i<arr.length; i++)
		{
			if (arr[i]>max)
				max = arr[i];
	
			if (arr[i]<min)
				min = arr[i];
		}
		
		System.out.printf("가장 큰 값 : %d, 가장 작은 값 : %d\n",max,min);
		*/
	}
}

// 실행 결과

/*
발생시킬 난수의 갯수 입력 : 12
20 53 51 69 72 52 68 39 54 94 75 44
가장 큰 값 : 94, 가장 작은 값 : 20
계속하려면 아무 키나 누르십시오 . . .
*/

/*
발생시킬 난수의 갯수 입력 : 20
73 50 2 82 2 86 63 2 28 13 24 61 33 9 30 2 9 39 5 46
가장 큰 값 : 86, 가장 작은 값 : 2
계속하려면 아무 키나 누르십시오 . . .
*//*=========================================
 ■■■ 배열 ■■■
 - 배열과 난수 처리(※ Random 클래스 활용)
==========================================*/

// 사용자로부터 임의의 정수를 입력받아
// 그 정수의 갯수만큼 난수(1 ~ 100)를 발생시커 a 배열에 담고
// 다시 사용자가 입력하는 값을 공백으로 구분하여 b 배열을 구성한 후
// 두 배열의 요소를 합집합의 혙애로 출력하는 프로그램을 구현한다.



// ※ 난수 발생 전용 객체 → 『java.util.Random』

// 실행 예)
// 발생시킬 난수의 갯수 입력 : 5
// (내부적으로 무장위 난수 발생... → 2 3 7 10 11)
// (배열에 담아내기... → int[] a = {2 3 7 10 11})

// 구성할 배열의 길이 입력 : 4
// 임의의 정수로 배열 구성(공백 구분) : 3 6 10 14
// >> 2 3 7 10 11 6 14
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;
import java.util.Random;
public class Test099
{
	public static void main(String[] args)
	{
		// 두 배열의 구성
		int[] a = {2, 3 ,7 ,10, 11};
		int[] b = {3, 6 ,10 ,14};
		
		//집합a(a 배열) 전체 출력
		for (int n=0; n<a.length; n++)
		{
			System.out.print(a[n] + " ");
		}
		
		//집합b(b 배열) 선택적 출력
		/*
		for (int n=0; n<a.length; n++)
		{
			// 사전 확인 과정
			// b배열에서 현재 출력할 요소를 a배열의 각 요소와 비교
			// 같은 값이 발견된다면... 뒷 부분 무시
			
			System.out.print(a[n] + " ");
		}
		*/
		
		
		// 집합b(b 배열) 집합a(a배열)와 중복되는 것을 제거하며 출력
		for (int n=0; n<b.length; n++)		//-- b 배열의 길이만큼 반복
		{
			boolean flag = false;
			
			// a 배열의 각 요소들과 비교하여 확인
			for (int m=0; m<a.length; m++)	//-- a 배열의 길이만큼 반복
			{
				if (b[n] == a[m])
				{
					flag = true;
					break;
				}
			}
			
			// b 배열의 요소를 출력하는 과정에서 중복되는 것을 확인하면 출력하지 않음
			if (flag)
				continue;					//-- (뒷부분 무시하고) 계속해라
			
			System.out.print(b[n] + " ");	//-- 뒷부분
		}
		System.out.println();
		
		
		
		
		
		/*
		Scanner sc = new Scanner(System.in);
		
		int size;
		
		
		System.out.print("발생시킬 난수의 갯수 입력 : ");
		size = sc.nextInt();
		
		Random rd = new Random();
		
		int[] a = new int[size];
		
	
		for (int i=0; i<a.length; i++)
			a[i] = rd.nextInt(100)+1;
		
		for (int i=0; i<a.length; i++)
			System.out.print(a[i] + " ");
		
		
		System.out.print("\n발생시킬 배열의 길이 입력 : ");
		size = sc.nextInt();
	
		int[] b = new int[size];
		int num;
		
		System.out.print("임의의 정수로 배열 구성(공백 구분) : ");

		for (int i=0; i<b.length; i++)
		{
			num = sc.nextInt();
			b[i]=num;
		}

		for (int i=0; i<a.length; i++)
		{
			System.out.printf(a[i] + " ");
		}
		
		
		*/
		
	}
}/*=========================================
 ■■■ 배열 ■■■
 - 배열의 복사
==========================================*/

// Test101.java 파일과 비교!!

// ※ 자바에서 배열 변수의 복사에는 데이터 복사, 주소값 복사 두 가지 형태가 존재한다.

//	  주소값 복사 → 얕은 복사
//	  원본을 수정하면 복사본에 영향을 미치게 되는 복사 방법
//	  (자바의 배열뿐 아니라 모든 참조형 데이터에 해당하는 복사 방법)


//	  데이터 복사 → 깊은 복사
//    실제 요소로 들어있는값에 대한 복사로
//    원본을 수정해도 복사본에 영향을 미치지 않는 복사 방법

// 주소값 복사

public class Test100
{
	public static void main(String[] args)
	{
		int[] nums = {10, 20, 30, 40, 50};		//-- 배열 원본
		int[] copys;							//-- 복사본으로 만들 배열
		
		int temp;								//-- 데이터 임시 저장 변수
												//	 (값 타입 확인 → 배열과 비교)
	    // check
		copys = nums;							//-- 복사
												//   (발생 지점 확인)
												
		temp = nums[0];							//-- temp = 10;
		
		// 원본 배열(nums)의 데이터 수정
		nums[0] = 10000;						//-- {10000, 20, 30, 40, 50}
	 
		// copys 배열의 전체 요소 출력
		for (int i=0; i<copys.length; i++)
		{
			System.out.print(copys[i] + " ");
		}
		System.out.println();
		//--==>> 10000 20 30 40 50
		
		// temp 출력 확인
		System.out.println("temp : " + temp);
		//--==>> temp : 10
	}
}/*=========================================
 ■■■ 배열 ■■■
 - 배열의 복사
==========================================*/

// Test100.java 파일과 비교!!

// ※ 자바에서 배열 변수의 복사에는 데이터 복사, 주소값 복사 두 가지 형태가 존재한다.

//	  주소값 복사 → 얕은 복사
//	  원본을 수정하면 복사본에 영향을 미치게 되는 복사 방법
// (자바의 배열뿐 아니라 모든 참조형 데이터에 해당하는 복사 방법)


//	  데이터 복사 → 깊은 복사
// 실제 요소로 들어있는값에 대한 복사로
// 원본을 수정해도 복사본에 영향을 미치지 않는 복사 방법

// 데이터 복사
// → int형 배열에 대한 깊은 복사를 처리하는
//	  메소드를 정의하는 형태로 실습 진행

public class Test101
{
	public static void main(String[] args)
	{
		int[] nums = {10, 20, 30, 40, 50};		//-- 배열 원본
		
		int[] copys1 = nums;					//-- 얕은 의미의 배열 복사 수행
												//   (주소값 복사)
												
		int[] copys2 = copyArray(nums);			//-- 깊은 의미의 배열 복사 수행
												//   (사용자 정의 메소드 호출)
		
		int[] copys3 = (int[])nums.clone();		//-- 깊은 의미의 배열 복사 수행
												//	 (자바 제공)
												
		// check
		// 원본 배열의 요소 수정 발생
		nums[1] = 2000;
		
		// nums 배열 확인
		for (int i=0; i<nums.length; i++)
			System.out.printf("%5d",nums[i]);
		System.out.println();
		//--==>>    10 2000   30   40   50
		
		// copys1 배열 확인
		for (int i=0; i<copys1.length; i++)
			System.out.printf("%5d",copys1[i]);
		System.out.println();
		//--==>>    10 2000   30   40   50
		
		// copys2 배열 확인
		for (int i=0; i<copys2.length; i++)
			System.out.printf("%5d",copys2[i]);
		System.out.println();
		//--==>>    10   20   30   40   50			// check
		
		// copys3 배열 확인
		for (int i=0; i<copys3.length; i++)
			System.out.printf("%5d",copys3[i]);
		System.out.println();
		//--==>>    10   20   30   40   50			// check
		
		
	}
	
	// 매개변수 int배열 타입을 넘겨받아
	// 이 배열을 복사한 후
	// 복사한 배열을 반환하는 기능을 가진 메소드 정의
	public static int[] copyArray(int[] os)
	{
		// 매개변수로 넘겨받은 배열(os)
		// 즉, 원본 배열 만큼의 배열방 (메모리 공간)을 확보한
		// 복사할 배열 생성
		int[] result = new int[os.length];
		
		// 원본 배열(os)에 담겨있는 각각의 요소들을 복사할 배열(result)에 담아내기
		// result = os;		//-- (X)
		//for (int i=0; i<os.length; i++)
		for (int i=0; i<result.length; i++)
		{
			result[i] = os[i];
 		}
		
		// 복사한 배열(result) 반환
		return result;
		
		
	}
}/*==============================================================================
 ■■■ 클래스와 인스턴스 ■■■
 - 정보은닉과 접근제어지시자
 (접근 지시자, 접근 제어자, 접근 지정자, 접근 제한자, 접근제어와 관련한 예약어)
================================================================================*/

import java.util.Scanner;

class CircleTest2
{
	// CircleTest2의 멤버 변수, 인스턴스 변수, 전역 변수
	// int num;
	
	// ↓
	
	// 정보은닉(Information Hiding)
	// 인스턴스 변수와 『private』이라는 접근제어지시자의 선언은
	// 클래스 내부에서만 접근 및 참조가 가능하게 하겠다는 의미
	// int형 전역 변수 → 자동 0 으로 초기화 지원
	private int num;
	
	
	/*
	// getter / setter 구성
	public int getNum()
	{
		//return num;
		return this.num;
	}
	
	public void setNum(int num)
	{
		this.num = num;
	}
	*/
	
	
	void input()
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("반지름 입력 : ");
		num = sc.nextInt();
	}
	
	double calArea()
	{
		return num * num * 3.141592;
	}
	
	void write(double area)
	{
		System.out.println("반지름 : " + num);
		System.out.println("넓이 : " + area);
	}
}

public class Test102
{
	public static void main(String[] args)
	{
		// CircleTest2 인스턴스 생성
		CircleTest2 ob1 = new CircleTest2();
		
		// ob1.num = 20000;
		// System.out.println("원의 반지름 확인 : " + ob1.num);
		
		// ※ 현재로써는 유일하게
		// CircleTest2의 num에 데이터를 전달할 수 있는 방법
		ob1.input();
		//--==>> 반지름 입력 : 250
		//		→ 『ob1.num = 250;』
		
		double result = ob1.calArea();
		
		ob1.write(result);
		//--==>> 반지름 입력 : 250
		//		 반지름 : 250
		//		 넓이 : 196349.5
		//		 계속하려면 아무 키나 누르십시오 . . .
		
	}
}
/*================================
 ■■■ 클래스와 인스턴스 ■■■
 - 클래스 설계
 - 배열의 활용
 - 정보은닉과 접근 제어지시자
==================================*/

// 사용자로부터 임의의 년, 월, 일을 입력받아
// 해당 날짜의 요일을 출력하는 프로그램을 구현한다.
// 단, 달력 클래스(Calender)는 사용하지 않는다.
// 또한 클래스의 개념을 활용하여 작성할 수 있도록한다.	(→ WeekDay 클래스 설계)
// 그리고 배열의 개념도 적용시켜 작성할 수 있도록 한다.
// 접근제어지시자의 개념도 확인하여 작성할 수 있도록 한다.
// 최종적으로...
// WeekDay 클래스 설계를 통해
// Test103 클래스의 main() 메소드가 정상적으로 작동하여
// 프로그램 실행될 수 있도록 한다.

// 실행 예)
// 년 월 일 입력(공백 구분) : 2024 10 18
// >> 2024년 10월 18일 → 금요일
// 계속하려면 아무 키나 누르세요...

// ※ Hint
//		- 1년 1월 1일 → "월요일"
//		- 1년이 항상 365일은 아니다.
//		- 2월의 마지막 날짜가 29일 → 윤년
//		- 2월의 마지막 날짜가 28일 → 평년
//		- 윤년의 판별 조건
//		→ 년도가 4의 배수이면서 100의 배수가 아니거나,
//			400의 배수이면 윤년, 그 이외의 년도는 평년.

import java.util.Scanner;

class WeekDay
{
	// 속성 구성 → 주요 변수 선언
	private int y,m,d;						//-- 사용자가 입력한 연, 월, 일을 담아낼 변수
	
	// 기능 구성 → 메소드 정의 : 연, 월, 일 입력받기
	public void input()
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("년 월 일 입력(공백 구분) : ");	// 2024 10 18
		y = sc.nextInt();
		m = sc.nextInt();
		d = sc.nextInt();
		
		// ... 
			
	}
	
	// 기능 구성 → 메소드 정의 : 요일 산출하기
	//private week()
	//public void week()
	public String week()
	{
		// 각 월의 마지막 날짜(각 월이 가지는 최대값)를 배열 형태로 구성
		int[] months ={31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; 
		
		// 테스트(확인)
		// System.out.println(months.length);
		
		// 각 요일의 이름을 배열 형태로 구성
		String[] weekNames = {"일","월", "화", "수", "목", "금", "토"};
		
		// 날 수를 누적 연산할 변수
		int nalsu;
		
		// 윤년에 따른 2월의 날 수 계산
		// 사용자의 입력 년도가 윤년이라면... 2월의 마지막 날짜를 29일로 구성
		// 사용자의 입력 년도가 평년이라면... 2월의 마지막 날짜를 28일로 구성
		if (y%4==0 && y%100!=100 || y%400==0)		//-- 사용자의 입력 년도가 윤년이라면...
		{
			// 2월의 마지막 날짜를 29일로 구성
			months[1] = 29;
		}
		else										//-- 사용자의 입력 년도가 평년이라면...
		{
			// 2월의 마지막 날짜를 28일로 구성
			months[1] = 28;
		}
		
		
		// ① 1년 1월 1일 부터... 입력년도의 이전 년도 12월 31일 까지의 날 수 계산
		nalsu = (y-1)*365 + (y-1)/4 - (y-1)/100 + (y-1)/400;
		//      ---------
		//     1년 기분주기 --------
		//					4년마다+1 ---------
		//							100년마다+1(X) ---------
		//										   400년마다+1
		
		// 테스트(확인)
		//System.out.println("날 수 연산 결과 : " + nalsu);
		//--==>> 년 월 일 입력(공백 구분) : 2024 10 18
		//		 날 수 연산 결과 : 738885
		//						   ------ → 1년1월1일 ~ 2023년12월31일까지의 날 수		
		
		
		// ② 입력받은 월의 이전 월 까지의 날 수 계산후
		//	  이 결과를 1번 결과에 더하는 연산
		for (int i=0; i<(m-1); i++)
		{
			nalsu += months[i];
		}
		
		// 테스트(확인)
		//System.out.println("날 수 연산 결과 : " + nalsu);
		//--==>> 년 월 일 입력(공백 구분) : 2024 2 5
		//		 날 수 연산 결과 : 738916
		//						   ------ → 1년1월1일 ~ 2024년1월31일까지의 날 수	
		//--==>> 년 월 일 입력(공백 구분) : 2024 10 18
		//		 날 수 연산 결과 : 739159
		//						   ------ → 1년1월1일 ~ 2024년9월30일까지의 날 수
		
		
		// ③ 입력받은 일의 날짜만큼 날 수 계산 후
		//	  이 결과를 2번 결과에 더하는 연산(누적합)
		nalsu += d;
		
		// 테스트(확인)
		// 
		//System.out.println("날 수 연산 결과 : " + nalsu);
		//--==>> 년 월 일 입력(공백 구분) : 2024 10 18
		//		 날 수 연산 결과 : 739177
		//						   ------ → 1년1월1일 ~ 2024년10월18일까지의 날 수
		//------------------------------------------여기까지 수행하면 날 수 연산 끝!!
		
		// 얻어낸 날 수를 기반으로 무슨 요일인지 확인하기 위한 연산
		int w = nalsu % 7;
		//-- 전체날수 % 7 == 0 → 일요일
		//   전체날수 % 7 == 1 → 월요일
		//				  :
		
		// 테스트(확인)
		//System.out.println("w : " + w);
		//--==>> 년 월 일 입력(공백 구분) : 2024 10 18
		//		 w : 5
		//			 - → 전체날수 % 7 == 5 → 금요일
		
		//--==>> 년 월 일 입력(공백 구분) : 2024 10 21
		//		 w : 1
		//			 - → 전체날수 % 7 == 1 → 월요일
		
		// 최종 결과값 반환
		return weekNames[w];			// return "월";
	}
	
	// 기능 구성 → 메소드 정의 : 결과 출력하기
	public void print(String day)
	{
		//>> 2024년 10월 18일 → 금요일
		System.out.printf(">> %d년 %d월 %d일 → %s요일\n",y,m,d,day);
	}
	
	
	/*
	private int year, month, day;
	private int sum;
	
	private String[] weekday = {"월요일", "화요일", "수요일", "목요일", "금요일", "토요일", "일요일"};
	
	void input()
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("년 월 일 입력(공백 구분) : ");
		year = sc.nextInt();
		month = sc.nextInt();
		day = sc.nextInt();
	}
	
	void getSum()																// 총 일수를 구하는 연산
	{
		for (int i=1; i<year; i++)												// 입력한 년도를 제외한 전년도까지의 일수 누적합
		{
			if ((i % 4 == 0 && i % 100 != 0) || (i % 400 == 0))					// 윤년일 경우 366일
			{
				sum += 366;
			}
			else																// 평년일 경우 365일
			{
				sum += 365;
			}
		}
		
		for (int i=1; i<month; i++)												// 입력한 년도의 월들의 누적합 (단, 입력한 월을 제외한 전월까지의 누적합)
		{
			if (i==1 || i==3 || i==5 || i==7 || i==8 || i==10 || i==12)			// 1,3,5,7,8,10,12월은 31일 누적
			{
				sum += 31;
			}
			else if (i==4 || i==6 || i==9 || i==11)								// 4,6,9,11월은 30일 누적
			{
				sum += 30;
			}
			else if (i==2)														// 2월이 윤달이 경우 29일 누적, 평달이 경우 28일 누적
			{
				if ((i % 4 == 0 && i % 100 != 0) || (i % 400 == 0))
				{
					sum += 29;
				}
				else
				{
					sum += 28;
				}
			}
		}
		sum += day;																// 입력한 월에서의 입력한 일까지의 누적합
	}
	
	
	String getDay()
	{
		String d = weekday[sum%7];												// 일수의 총 누적합을 7로 나누어 월요일 ~ 일요일 대입
		return d;
		
	}
	
	void print(String d)														// 결과 출력
	{
		System.out.printf("%d년 %d월 %d일 → %s\n",year,month,day,d);
	}
	*/
}


public class Test103
{
	public static void main(String[] args)
	{
		// WeekDay 클래스 인스턴스 생성
		WeekDay ob = new WeekDay();
		
		
		// 입력 메소드 호출
		ob.input();
		
		
		
		// 요일 산출 메소드 호출(테스트)
		//ob.week();
		
		// 요일 산출 메소드 호출
		String result = ob.week();
		
		// 최종 결과 출력 메소드 호출
		ob.print(result);
		
		/*
		WeekDay wd = new WeekDay();
		
		wd.input();
		
		wd.getSum();
		
		String d = wd.getDay();
		
		wd.print(d);
		*/
		
	}
}

// 실행 결과

/*
년 월 일 입력(공백 구분) : 2024 10 28
>> 2024년 10월 28일 → 월요일
계속하려면 아무 키나 누르십시오 . . .
*/

/*
년 월 일 입력(공백 구분) : 2025 4 22
>> 2025년 4월 22일 → 화요일
계속하려면 아무 키나 누르십시오 . . .
*/

/*
년 월 일 입력(공백 구분) : 1992 4 5
>> 1992년 4월 5일 → 일요일
계속하려면 아무 키나 누르십시오 . . .
*//*========================================================
 ■■■ 클래스와 인스턴스 ■■■
 - static 변수(클래스 변수)와 static 메소드(클래스 메소드)
=========================================================*/

// ※ 공유 
// ※ 탄생 시점

// ※ 실습 편의상 접근제어지시자 생략

public class Test104{
	
	//※ 클래스 변수 또는 클래스 메소드는
	//	 클래스 정보가 로딩되는 순간 메모리 할당이 이루어지며
	//	 클래스 이름 또는 객체(인스턴스)를 통해 접근할 수 있다.
	//	 즉, 『new』 연산지를 통해 메모리를 할당받지 않아도
	//	 사용이 가능하다는 것이다.
	
	static int a = 10;		//-- static 변수(클래스 변수, class 변수, 정적 변수)
	
	int b = 20;				//-- non-static 변수(인스턴스 변수, instance 변수)
	
	void write()			//-- non-static 메소드(인스턴스 메소드, instance 메소드)
	{
		System.out.println("클래스 변수   a : " + a);
		System.out.println("인스턴스 변수 b : " + b);
	}
	
	static void print()		//-- static 메소드(클래스 메소드, class 메소드, 정적 메소드)
	{
		System.out.println("클래스 변수 a : " + a);
		//System.out.println("인스턴스 변수 b : " + b);
		//--==>> 에러 발생(컴파일 에러)
		//		 non-static variable b cannot be referenced from a static context
		
	}
	
	
	public static void main(String[] args){
		
		System.out.println("main() → 클래스 변수 a : " + Test104.a);
		//--	클래스 변수에 접근하기 위해서는
		//		『클래스.변수명』 의 형태로 클래스의 이름을 통해
		//		접근하는 것이 가능하다.
		//--==>> main() → 클래스 변수 a : 10
		
		System.out.println("main() → 클래스 변수 a : " + a);
		//-- 같은 클래스 내부에 존재하기 때문에
		//	 클래스의 이름을 생략하는 것이 가능하다.
		//--==>> main() → 클래스 변수 a : 10
		
		Test104.print();
		//--==>> 클래스 변수       a : 10
		
		print();
		//--==>> 클래스 변수       a : 10
		//-- 클래스 메소드에서 클래스 메소드의 호출은 가능하며,
		//	『클래스명.메소드명()』 의 형태로 접근하여 호출하는 것이 가능하다.
		//	또한 지금은 같은 클래스 내부에 존재하기 때문에
		//	클래스의 이름을 생략한 경우에 해당한다.
		
		//System.out.println("main() → 인스턴스 변수 b : " + b);
		//--==>> 에러 발생(컴파일 에러)
		//		 non-static variable b cannot be referenced from a static context
		
		//System.out.println("main() → 인스턴스 변수 b : " Test104.b);
		//--==>> 에러 발생(컴파일 에러)
		//		 non-static variable b cannot be referenced from a static context
		
		//write();
		//--==>> 에러 발생(컴파일 에러)
		//		  non-static method write() cannot be referenced from a static context
		
		//Test104.write();
		//--==>> 에러 발생(컴파일 에러)
		//		 non-static method write() cannot be referenced from a static context
		
		// Test104 클래스의 인스턴스 생성
		Test104 ob = new Test104();
		
		//System.out.println("main() → 인스턴스 변수 b : " + b);
		//--==>> 에러 발생(컴파일 에러)
		//		 non-static variable b cannot be referenced from a static context
		
		//System.out.println("main() → 인스턴스 변수 b : " + ob.b);
		//--==>> main() → 인스턴스 변수 b : 20
		
		// write();
		//--==>> 에러 발생(컴파일 에러)
		//		 non-static method write() cannot be referenced from a static context
		
		// 생성된 인스턴스를 통해 인스턴스 메소드 접근(호출)
		ob.write();
		//--==>> 클래스 변수       a : 10
		//		 인스턴스 변수 b : 20
		
		
		//생성된 인스턴스를 통해 클래스 변수 접근
		System.out.println("main() → 클래스 변수 a : " + ob.a);
		//--==>> main() → 클래스 변수 a : 10
		
		//생성된 인스턴스를 통해 클래스 메소드 접근(호출)
		ob.print();
		//--==>> 클래스 변수       a : 10
		
		
		// ※ 클래스 변수나 클래스 메소드는
		//	  『생성된인스턴스명.변수명』
		//	  『생성된인스턴스명.메소드명()』
		//	  의 형태로도 접근(호출)이 가능하지만
		//	  『클래스명.변수명』
		//	  『클래스명.메소드명()』
		//	  의 형태로 접근(호출)하는 것이 일반적이다.
		
		
		System.out.println("main() → 클래스 변수 a");
		System.out.println("a : " + a);
		System.out.println("a : " + ob.a);
		System.out.println("a : " + Test104.a);
		//--==>> main() → 클래스 변수 a
		//		 a : 10
		//		 a : 10
		//		 a : 10
		
		System.out.println();		//개행
		
		System.out.println("main() → 클래스메소드 print()");
		print();
		ob.print();
		Test104.print();
		//--==>> main() → 클래스메소드 print()
		//		 클래스 변수       a : 10
		//		 클래스 변수       a : 10
		//		 클래스 변수       a : 10
		
		System.out.println();
		
		
		// Test104 클래스의 인스턴스 생성
		Test104 ob2 = new Test104();
		
		ob2.a = 10000;
		ob2.b = 20000;
		
		System.out.println("ob2 확인-----------------");
		ob2.write();
		//--==>> ob2 확인-----------------
		//		 클래스 변수   a : 10000
		//		 인스턴스 변수 b : 20000
		
		System.out.println("ob 확인------------------");
		ob.write();
		//--==>> ob 확인------------------
		//		 클래스 변수   a : 10000
		//		 인스턴스 변수 b : 20
		
		
	}
}
/*========================================================
 ■■■ 클래스와 인스턴스 ■■■
 - 클래스와 인스턴스 활용
=========================================================*/

// 학생별로 국어점수, 영어점수, 수학점수를 입력받아
// 총점 평균을 계산하는 프로그램을 구현한다.
// 단, 클래스의 개념을 활용하여 작성할 수 있도록한다.
// 또한 이과정에서 배열을 적극적으로 활용할 수 있도록한다.
// 클래스의 설계는 다음의 가이드 라인에 따라 진행할 수 있도록한다.

// [가이드라인]
// 프로그램을 구성하는 클래스
// 1. Record 클래스
//		- 속성만 존재하는 클래스로 설계할 것!!-----------------	check

// 2. Sungjuk 클래스
//		- 인원수를 입력받아, 입력받은 인원수 만큼
//		  이름, 국어점수, 영어점수, 수학점수를 입력받고
//		  총점과 평균을 산출하는 클래스로 설계할 것!!
//		  속성: 인원 수, Record 타입의 배열  ------------------	check
//		  기능: 인원 수 입력, 상세 데이터 입력, 총점 및 평균 연산, 결과 출력

// 3. Test105 클래스
//	    - main() 메소드가 존재하는 외부 클래스로 설계 할 것 !!

// 실행 예)
// 인원 수 입력(1~100) : 102
// 인원 수 입력(1~100) : -20
// 인원 수 입력(1~100) : 3

// 1번째 학생의 이름 입력 : xxx
// 국어 점수 : 90
// 영어 점수 : 80
// 수학 점수 : 70
// 2번째 학생의 이름 입력 : xxx
// 국어 점수 : 92
// 영어 점수 : 82
// 수학 점수 : 72
// 3번째 학생의 이름 입력 : xxx
// 국어 점수 : 82
// 영어 점수 : 72
// 수학 점수 : 62

// xxx 90 80 70	  240  xx.xx	2
// xxx 92 82 72	  xxx  xx.xx	1
// xxx 82 72 62	  xxx  xx.xx	3
// 계속하려면 아무 키나 누르세요...

public class Test105
{
	public static void main(String[] args)
	{
		// 테스트(확인)
		//Record ob = new Record();
		//System.out.println("ob.tot : " + ob.tot);
		//--==>> ob.tot : 0
		
		Sungjuk sj = new Sungjuk();
		
		sj.set();
		
		sj.input();
		
		// sj.ranking();
		
		sj.print();
		
		
		
		/* 나의 풀이
		Sungjuk sj = new Sungjuk();
		
		sj.input();
		
		
		sj.getTot();
		
		sj.getAvg();
		
		sj.print();
		*/
	}
}

// 실행 결과

/*
인원 수 입력(1~100) : 3
1번째 학생의 이름 입력 : 윤영식
국어 점수 : 90
영어 점수 : 80
수학 점수 : 70
2번째 학생의 이름 입력 : 가나다
국어 점수 : 92
영어 점수 : 82
수학 점수 : 72
3번째 학생의 이름 입력 : 라마바
국어 점수 : 88
영어 점수 : 77
수학 점수 : 66

  윤영식  90  80  70  240   80.00
  가나다  92  82  72  246   82.00
  라마바  88  77  66  231   77.00
계속하려면 아무 키나 누르십시오 . . .
*/

// 석차 산출 기능 추가 후...
// 실행 결과

/*
인원 수 입력(1~100) : 3
1번째 학생의 이름 입력 : 문제정
국어 점수 : 90
영어 점수 : 80
수학 점수 : 70
2번째 학생의 이름 입력 : 엄서연
국어 점수 : 92
영어 점수 : 82
수학 점수 : 72
3번째 학생의 이름 입력 : 박제훈
국어 점수 : 88
영어 점수 : 77
수학 점수 : 66

  문제정  90  80  70  240   80.00    2
  엄서연  92  82  72  246   82.00    1
  박제훈  88  77  66  231   77.00    3
계속하려면 아무 키나 누르십시오 . . .
*//*========================================================
 ■■■ 클래스와 인스턴스 ■■■
 - 클래스와 인스턴스 활용
=========================================================*/

// 1~3 사이의 난수를 발생기켜서
// 가위, 바위, 보 게임 프로그램을 구현한다.
// 단, 클래스의 개념을 활용하여 처리할 수 있도록 한다.
// 또한, 배열을 활용하여 처리할 수 있도록 하낟.
// 최종적으로 RpsGame 클래스를 완성할 수 있도록 한다.

// ※ 구현 과정에서의 기준 데이터 → 1:가위, 2:바위, 3:보

// 실행 예)
// 1:가위, 2:바위, 3:보 중 입력(1~3) : 4
// 1:가위, 2:바위, 3:보 중 입력(1~3) : -2
// 1:가위, 2:바위, 3:보 중 입력(1~3) : 2

// - 유저 : 바위
// - 컴퓨터 : 보

// >> 승부 최종 결과 : 컴퓨터가 이겼습니다~!!!
// cf) >> 승부 최종 결과 : 무승부 상황입니다~!!!
//	   >> 승부 최종 결과 : 당신이 이겼습니다~!!!
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;
import java.util.Random;


class RpsGame
{
	private int user;
	private int com;
	
	// 컴퓨터의 가위바위보
	private void runCom()
	{
		Random rd = new Random();
		com = rd.nextInt(3)+1;			// 0 1 2 → (+1) → 1 2 3
	}
	
	// 사용자의 가위바위보
	public void input()
	{
		// 유저가 가위바위보를 하기 전에... 컴퓨터(주최측) 먼저 가위바위보
		runCom();
		
		Scanner sc = new Scanner(System.in);
		
		do
		{
			System.out.print("1:가위, 2:바위, 3:보 중 입력(1~3) : ");
			user = sc.nextInt();
		}
		while (user<1 || user>3);		
	}
	
	// 중간 결과 출력
	public void middleCalc()
	{
		String[] str = {"가위", "바위", "보"};
		
		System.out.println();	// 개행
		System.out.println("- 유저   : " + str[user-1]);
		System.out.println("- 컴퓨터 : " + str[com-1]);
	}
	
	// 승부에 대한 최종 결과 연산
	public String resultCalc()
	{
		/*
		String result = "무승부 상황입니다~!!!";
		
		// (유저=="가위" && 컴=="보") || (유저=="바위" && 컴=="가위") || (유저=="보" && 컴=="바위") 
		// "당신이 승리했습니다~!!!"
		// (유저=="가위" && 컴=="바위") || (유저=="바위" && 컴=="보") || (유저=="보" && 컴=="가위")
		// "컴퓨터가 승리했습니다~!!!"
		
		if ((user==1 && com==3) || (user==2 && com==1) || (user==3 && com==2))
		{
			result = "당신이 승리했습니다~!!!";
		}
		else if ((user==1 && com==2) || (user==2 && com==3) || (user==3 && com==1))
		{
			result = "컴퓨터가 승리했습니다~!!!";
		}
		*/
		
		String result = "당신이 승리했습니다~!!!";
		
		if (user==com)
		{
			result = "무승부 상황 입니다~!!!";
		}
		else if (user%3==(com+2)%3)
		{
			result = "컴퓨터가 승리했습니다~!!!";
		}
		
		
		
		return result;
	}
	
	
	// 결과 출력
	public void print(String str)
	{
		// >> 승부 최종 결과 : 컴퓨터가 승리했습니다~!!!
		System.out.printf("\n>> 승부 최종 결과 : %s\n",str);
		
	}
	
	
	
	
	
	
	
	
	/*
	int num;
	int[] a = {1, 2, 3};
	int com;
	String user,com2;
	
	void input()
	{
		Scanner sc = new Scanner(System.in);
		
		do
		{
			System.out.print("1:가위, 2:바위, 3:보 중 입력(1~3) : ");
			num = sc.nextInt();
		}
		while (num<1 || num>3);
		
		if (num == 1)
		{
			user = "가위";
		}
		else if (num == 2)
		{
			user = "바위";
		}
		else if (num == 3)
		{
			user = "보";
		}
		
	}
	
	
	
	void ran()
	{
		Random rd = new Random();
		
		com = rd.nextInt(3)+1;	
		
		if (com==1)
		{
			com2 = "가위";
		}
		else if (com==2)
		{
			com2 = "바위";
		}
		else if (com==3)
		{
			com2 = "보";
		}
	}
	

	void print()
	{
		System.out.println();
		
		System.out.printf("- 유저	: %s\n",user);
		System.out.printf("- 컴퓨터 : %s\n",com2);
		
		if ((user=="가위" && com2=="보") || (user=="바위" && com2=="가위") || (user=="보" && com2=="바위"))
		{
			System.out.println("\n>> 승부 최종 결과 : 당신이 승리 했습니다~!!!");
		}
		else if ((user=="가위" && com2=="바위") || (user=="바위" && com2=="보") || (user=="보" && com2=="가위"))
		{
			System.out.println("\n>> 승부 최종 결과 : 컴퓨터가 승리 했습니다~!!!");
		}
		else
			System.out.println("\n>> 승부 최종 결과 : 무승부 상황입니다~!!!");
	}
	*/
	
	
	
}

public class Test106
{
	public static void main(String[] args)
	{
		RpsGame ob = new RpsGame();
		
		ob.input();
		
		ob.middleCalc();
		
		String result = ob.resultCalc();
		
		ob.print(result);
	}
}

// 실행 결과

/*
1:가위, 2:바위, 3:보 중 입력(1~3) : 3

- 유저   : 보
- 컴퓨터 : 가위

>> 승부 최종 결과 : 컴퓨터가 승리했습니다~!!!
계속하려면 아무 키나 누르십시오 . . .
*/

/*
1:가위, 2:바위, 3:보 중 입력(1~3) : 1

- 유저   : 가위
- 컴퓨터 : 가위

>> 승부 최종 결과 : 무승부 상황입니다~!!!
계속하려면 아무 키나 누르십시오 . . .
*/

/*
1:가위, 2:바위, 3:보 중 입력(1~3) : 2

- 유저   : 바위
- 컴퓨터 : 보

>> 승부 최종 결과 : 컴퓨터가 승리했습니다~!!!
계속하려면 아무 키나 누르십시오 . . .
*//*=====================================
 ■■■ 클래스와 인스턴스 ■■■
 - 메소드 중복 정의(Method Overloading)
======================================*/

/*
○ 메소드 오버로딩(Method Overloading)의 개요

	메소드 오버로딩이란 메소드가 처리하는 기능은 같고
	메소드 괄호 속에서 오는 인수(인자, 매개변수, 파라미터)의 갯수가 다르거나
	자료형(Data Type)이 다른 경우
	메소드의 이름을 동일한 이름으로 부여하여 메소드를 정의할 수 있도록
	문법적으로 허용하게 되는데
	이를 메소드 오버로딩(Method Overloading)이라고 한다.
*/


public class Test107
{
	public static void main(String[] args)
	{
		/*
		Test107 ob = new Test107();
		
		ob.drawLine();
		*/
		
		/*
		Test107.drawLine();
		*/
		
		drawLine();
		//--==>> --------------------
		
		drawLine('=');
		//--==>> ====================
		
		drawLine('<');
		//--==>> <<<<<<<<<<<<<<<<<<<<
		
		drawLine('+',40);
		//--==>> ++++++++++++++++++++++++++++++++++++++++
		
		drawLine('/',30);
		//--==>> //////////////////////////////
		
		
	}
	
	
	// 선을 그리는 메소드 정의
	public static void drawLine()
	{
		System.out.println("--------------------");
	}
	
	// 선을 그리는 메소드 정의 → 선의 형태를 바꾸어 그리는 메소드
	// public static void drawLine()
	public static void drawLine(char c)
	{
		//System.out.println("====================");
		for (int i=0; i<20; i++)
		{
			System.out.print(c);
		}
		System.out.println();
	}
	
	// 선을 그리는 메소드 정의 → 선의 형태와 길이 바꾸어 그리는 메소드
	public static void drawLine(char c, int n)
	{
		//System.out.println("++++++++++++++++++++++++++++++++++");
		for (int i=0; i<n; i++)
		{
			System.out.print(c);
		}
			System.out.println();
		
		
	}
	
}/*====================================================================
 ■■■ 클래스와 인스턴스 ■■■
 - 메소드 중복 정의(Method Overloading)이 가능한 형태와 불가능한 형태
=====================================================================*/


public class Test108
{
	public static void main(String[] args)
	{
		print();
		print(10);
		
		print(3.14);
		
		double result = print(3.14);		
	}
	
	public static void print() {}
	
	//public static void print() {}								//--(X)
	
	public static void print(int i) {}
	
	//public static void print(int j) {}						//--(X)
	
	public static void print(char c) {}							//-- 자동 형 변환 규칙 check~!!!
	
	public static void print(int i, int j) {}
	
	public static void print(double d) {}						//-- 자동 형 변환 규칙 check~!!!
	
	//public static void print(double e) {return 10.0;}			//-- 정의 불가
	
	//public static double print(double e) {return 10.0;}		//--(X)
	
	

	
	
}/*========================================
 ■■■ 만년 달력 ■■■
 - 다음과 같은 기능의 프로그램을 구현한다.
==========================================*/

// 실행 예)
// 『연도』를 입력하세요 : -23
// 『연도』를 입력하세요 : 0
// 『연도』를 입력하세요 : 2024
// 『월』을 입력하세요 : 13
// 『월』을 입력하세요 : -5
// 『월』을 입력하세요 : 10

/*
	   [ 2024년 10월 ]
	
  일  월  화  수  목  금  토 
=============================
	       1   2   3   4   5
   6   7   8   9  10  11  12
  13  14  15  16  17  18  19
  20  21  22  23  24  25  26
  27  28  29  30  31
========================
계속하려면 아무 키나 누르세요...
*/

import java.util.Scanner;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;



/* 나의 풀이
class Calender
{
	private int y,m,d;
	int[] months = {31, 0, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
	
	public void input()
	{
		Scanner sc = new Scanner(System.in);
		
		do
		{
			System.out.print("『연도』를 입력하세요 : ");
			y = sc.nextInt();
		}
		while (y<1 || y>10000);
		
		do
		{
			System.out.print("『월』을 입력하세요 : ");
			m = sc.nextInt();
		}
		while (m<1 || m>12);		
	}
	
	public int calc()
	{
		int[] days = new int[7];
		
		if (y%4 == 0 && y%100 != 0 || y%400==0)
		{
			months[1] = 29;
		}
		else
			months[1] = 28;
		
		int nalsu;
		
		nalsu = (y-1)*365 + (y-1)/4 - (y-1)/100 + (y-1)/400;
		
		for (int i=0; i<m-1; i++)
		{
			nalsu += months[i];
		}
		
		int w = nalsu % 7;
		
		return w;
	}
	
	int[][] arr = new int[6][7];
	
	int n=1;
	
	public void print(int w)
	{
		System.out.printf("\n       [ %d년 %d월 ]\n",y,m);
		System.out.println("  일  월  화  수  목  금  토");
		System.out.println("=============================");
		
		for (int i=0; i<arr.length; i++)
		{
			if (w==0)
			{
				for (int j=0; j<arr[i].length; j++)
				{
					if (n > months[m-1])
						break;
				
					arr[i][j] = n;
					n++;
	
					System.out.printf("%4d",arr[i][j]);
				}
				System.out.println();
			}
			else if (w>0)
			{
				for (int j=0; j<=w; j++)
				{
					System.out.print("    ");
				}
				
				for (int j=w+1; j<arr[i].length; j++)
				{
					if (n>months[m-1])
						break;
			
					arr[i][j] = n;
					n++;
					
					System.out.printf("%4d",arr[i][j]);
				}
				w=0;
				System.out.println();
			}
		
		}
		
		System.out.println("=============================");
	}
	
	
}
*/










public class Test109
{
	public static void main(String[] args) throws IOException
	{
		// BufferedReader 인스턴스 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		//배열 선언 및 초기화
		//-- 각 달이 담고있는 마지막 날짜(매 월의 최대 날짜)
		int[] days = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
		// 배열 인덱스 0  1   2   3    4   5   6   7   8   9  10  11
		// 월		   1  2   3   4    5   6   7   8   9   10 11  12
		
		//테스트(확인)
		//System.out.println(days.length);
		//--==>> 12
		
		// 주요 변수 선언
		int nalsu, y, m, w;		//-- 날 수, 연, 월, 요일
		
		
		do
		{
			System.out.print("『연도』를 입력하세요 : ");
			y = Integer.parseInt(br.readLine());
		}
		while (y<1);
		//-- 입력받은 연도가 1보다 작을 경우 다시 입력받을 수 있도록 처리
		
		
		do
		{
			System.out.print("『월』를 입력하세요 : ");
			m = Integer.parseInt(br.readLine());
		}
		while (m<1 || m>12);
		
		//-- 입력받은 월이 1보다 작거나 12보다 크면 다시 입력받을 수 있도록 처리
		
		
		
		//----------------------여기까지 수행하면 유효한 연도와 월을 사용자로부터 입력받은 상태
		
		// 입력받은 연도에 해당하는 2워르이 마지막 날 계산
		if ((y%4==0 && y%100!=0) || y%400==0)		// 윤년이라면...
		{
			// 2월의 마지막 날(→ days[1])을 29일로 설정
			// 현재 기본값은 28일로 설정해 둔 상태
			days[1]=29;
		}
		//else 구문
		// 현재 days 배열의 1번째 요소(2월)가 28일로 구성되어 있는 상태이기 때문에
		// 생략 가능한 구문이 된다.
		
		// ①
		// 1년 1월 1일 ~ 입력받은 연도의 이전 년도 12월 31일까지의 날 수 계산
		//				 -------------------------
		//						(y-1)
		nalsu = (y-1)*365 + (y-1)/4 - (y-1)/100 + (y-1)/400;
		
		// ②
		// 입력받은 연도(해당 연도) 1월 1일 ~ 입력한 월의 이전 월까지의 날 수 계산하여 ①에 더해나가기
		//									  -------------------
		//											(m-1)
		for (int i=0; i<(m-1); i++)
		{
			nalsu += days[i]; 
		}
		
		// ③
		// 입력받은 월의 1일을 날 수 누적 연산
		nalsu += 1;			// ++nalsu;
		
		
		
		//----------------------여기까지 수행하면 모든 날 수에 대한 종합적인 연산 처리 완료
		
		
		// 요일 확인
		//-- 입력받은 연, 입력받은 월의 1일이 무슨요일인지 확인하기 위한 연산
		w = nalsu % 7;
		// w → 0 → 일요일
		// w → 1 → 월요일
		// w → 2 → 화요일
		//		:
		
		// 테스트(확인)
		//System.out.println("w : " + w);
		//--==>> 『연도』를 입력하세요 : 2024
		//		 『월』를 입력하세요 : 10
		//        w : 2	--------------------------------> 2024년 10월 1일 → 화요일	
		//--==>> 『연도』를 입력하세요 : 2025
		//	     『월』를 입력하세요 : 4
		//        w : 2	-------------------------------->
		
		
		//----------------------여기까지 수행하면 입력 연도 입력 월의 1일이 무슨 요일인지 확인 완료~!!!
		
		
		// 출력(달력 그리기)
		
		System.out.println();			// 개행
		System.out.printf("\t[ %d년 %d월 ]\n",y,m);
		System.out.println();
		System.out.println("  일  월  화  수  목  금  토");
		System.out.println("============================");
		
		// 특정 요일부터 1일 시작되며 그려질 수 있도록 공백 발생(지정)
		for (int i=1; i<=w; i++)
		{
			System.out.print("    ");		// 공백 4칸 발생
		}
		
		// 테스트(확인)
		//System.out.printf("%4d",1);
		//-- 1이 출력되는 위치 확인
		
		// 해당 월(입력한 월)의 날짜만큼 출력될 수 있도록 반복문 구성
		for (int i=1; i<=days[m-1]; i++)
		{
			//System.out.printf("%4d", 1);
			System.out.printf("%4d", i);
			
			w++;
			//-- 반복문을 통해 날짜를 하루씩 처리하눈 만큼
			//	 요일도 그만큼씩 함께 증가할 수 있도록 처리
			
			// 특정 상황에서의 개행
			// 일요일 구성(출력)하려는 경우...
			// (즉, 이번에 출력하고자 하는 날짜가 일요일인 경우)
			if (w%7==0)
			{
				// 개행
				System.out.println();
				
			}
			
		}
		// 달의 마지막 날짜가 출력 형식을 모두 채웠을 경우
		// (즉, 토요일까지 라인 전체가 출력되었을 경우)
		// 이미 반복문 내에서 일여일 개행이 이루어졌기 때문에 
		// 이 경우에는 추가 개행을 하지 않도록 처리
		
		if (w%7!=0)
		{
			System.out.println();			// 개행
		}
			
		System.out.println("============================");
		
		/*나의 풀이
		Calender ob = new Calender();
		
		ob.input();
		
		int result = ob.calc();
		
		ob.print(result);
		*/
	}
}

// 실행 결과

/*
『연도』를 입력하세요 : 2025
『월』를 입력하세요 : 5

        [ 2025년 5월 ]

  일  월  화  수  목  금  토
============================
                   1   2   3
   4   5   6   7   8   9  10
  11  12  13  14  15  16  17
  18  19  20  21  22  23  24
  25  26  27  28  29  30  31
============================
계속하려면 아무 키나 누르십시오 . . .
*/

/*
『연도』를 입력하세요 : 2024
『월』를 입력하세요 : 10

        [ 2024년 10월 ]

  일  월  화  수  목  금  토
============================
           1   2   3   4   5
   6   7   8   9  10  11  12
  13  14  15  16  17  18  19
  20  21  22  23  24  25  26
  27  28  29  30  31
============================
계속하려면 아무 키나 누르십시오 . . .
*/

/*
『연도』를 입력하세요 : 1992
『월』를 입력하세요 : 4

        [ 1992년 4월 ]

  일  월  화  수  목  금  토
============================
               1   2   3   4
   5   6   7   8   9  10  11
  12  13  14  15  16  17  18
  19  20  21  22  23  24  25
  26  27  28  29  30
============================
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 주민등록번호 유효성 검사 ■■■
==========================================*/

/*
○ 주민등록번호 검증 공식

   ① 마지막 자리를 제외한 앞자리 수를 규칙에 맞게 곱한다.
   
	  123456-1234567 (주민번호)
	  ******-****** -----------------------각 자릿수에 곱하기
	  234567 892345  (각 자리에 곱해질 수)
   
   ② 규칙에 맞게 곱셈 연산을 수행한 결과를 모두 더한다.
   
   ex) 750615-1862133
	   ****** ******
	   234567 892345
	   ---------------
	   → 14 + 15 + 0 + 30 + 6 + 35 + 8 + 72 + 12 + 6 + 4 +15
	   
	      == 217
   
   ③ 더해진 결과값을 11로 나누어 『나머지』를 취한다.
	     19
	  --------	
   11|  217
        11
	  --------
	    107
		 99
	  --------
	      8 → 나머지(ㅇ)
		  
   ④ 11에서 나머지 8을 뺀 결과값을 구한다.
   
      11 - 8 → 3
	  
	  ※ ③ 을 처리하는 과정에서 나머지가 0인 경우는 ④ 의 연산 결과 11 - 0 = 11
								 나머지가 1인 경우는 ④ 의 연산 결과 11 - 1 = 10
								 
								 이를 다시 10으로 나누어 나머지를 취한다.
								 
   ⑤ ④ 에서 처리한 연산 결과가 주민번호를 구성하는 마지막 숫자와 일치하는지의 여부를 비교하여 확인한다.
   
	  일치   → 유효한 주민번호
	  불일치 → 유효하지 않은 주민번호
*/

// 실행 예)
// 주민번호입력(xxxxxx-xxxxxxx) : 123456-12345678 (→ 입력 갯수 초과 상황)
// >> 입력 오류~!!!
// 계속하려면 아무 키나 누르세요...

// 주민번호입력(xxxxxx-xxxxxxx) : 1234 (→ 입력 갯수 미달 상황)
// >> 입력 오류~!!!
// 계속하려면 아무 키나 누르세요...

// 주민번호입력(xxxxxx-xxxxxxx) : 750615-1252085 (→ 유효한 주민번호)
// >> 정확한 주민번호~!!
// 계속하려면 아무 키나 누르세요...

// 주민번호입력(xxxxxx-xxxxxxx) : 750615-1252086 (→ 잘못된 주민번호)
// >> 잘못된 주민번호~!!
// 계속하려면 아무 키나 누르세요...

// ※ 문제 해결을 위한 추가 팁~!!!

// 배열.length					→ 배열의 길이(배열방의 갯수) 반환
// 문자열.length				→ 문자열의 길이 반환

// 문자열.substring()			→ 문자열 추출
// 문자열.substring(m,n)		→ 문자열 m번째 위치에서 n-1번째 위치까지 추출(인덱스 0부터)
// 문자열.substring(m)			→ 문자열 m번째 위치에서 문자열의 끝까지 추출(인덱스 0부터)

import java.util.Scanner;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;



public class Test110
{
	public static void main(String[] args) throws IOException
	{
		/*
		// BufferedReader 인스턴스 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		// 입력받는 주민번호(문자열 형태)를 담아둘 변수 선언
		String str;
		
		// 공식에 따라 주민번호의 각 자릿수에 곱하게 될 수 → 배열 형태로 구성
		//			 7 5 0 6 1 5 - 1 8 6 2 1 3 3
		//			 * * * * * *   * * * * * * 
		int[] chk = {2,3,4,5,6,7,0,8,9,2,3,4,5};
		//						---
		//						check!!
		
		// 누적곱 -- (X)
		// 누적합 -- (O)
		// 곱셈 연산 후 누적합 → (각 자릿수에 맞는 곱셈의 결과를 더해나가라...)
		// ---------    ====== 0으로 초기화
		//int tot = 1;
		int tot = 0;
		
		
		System.out.print("주민번호입력(xxxxxx-xxxxxxx) : ");		// "750615-1862133" → 14자리
		//Integer.parseInt(br.readLine());
		str = br.readLine();
		
		if (str.length() != 14)
		{
			System.out.println(">> 입력 오류~!!!");
			return;			//--메소드 종료 → main() 메소드 종료 → 프로그램 종료
		}
		
		//테스트(확인)
		//System.out.println(">> 입력값의 자릿수가 적합한 상황");
		
		// 각 자릿수에 곱셈 연산이 진행되는 동안 누적합 산출
		//for (int i=0; i<str.length-1; i++)
		for (int i=0; i<13; i++)	//-- i → 0 1 2 3 4 5 6 7 8 9 10 11 12	
		{
			//테스트(확인)
			//System.out.print(i + " ");
			//--==>> 0 1 2 3 4 5 6 7 8 9 10 11 12
			
			// i가 6일 때에는 뒷부분 무시하고 계속해라~!!!
			if (i==6)
				continue;			//-- (뒷부분 무시하고) 계속해라
			
			//tot += chk[0] * Integer.parseInt(str.substring(0,1));
			//tot += chk[1] * Integer.parseInt(str.substring(1,2));
			//tot += chk[2] * Integer.parseInt(str.substring(2,3));
			//tot += chk[3] * Integer.parseInt(str.substring(3,4));
			//						:	
			//tot += chk[12] * Integer.parseInt(str.substring(12,13));
			tot += chk[i] * Integer.parseInt(str.substring(i,(i+1)));		//-- 뒷부분
			
			
		}
		// 테스트(확인)
		//System.out.println("tot : " + tot);
		//--==>> 주민번호입력(xxxxxx-xxxxxxx) : 750615-1862133 
		//		 tot : 217
		
		
		//------------------여기까지 수행하면 ①과 ②를 모두 끝낸 상황이며
		//					규칙에 맞게 곱셈 연산을 수행한 결과를 모두 더한 값은
		//					변수 tot에 담겨있는 상황이 된다.
		
		//int su1 = tot % 11;
		//int su2 = 11 - su1;
		
		int su = 11 - tot % 11;
		
		//------------------여기까지 수행하면 ③과 ④를 모두 끝낸 상황이며
		//					변수 su 에 대한 연산 결과가 두 자리로 나올 경우
		//					주민번호 마지막 자리의 숫자와 비교를 수행할 수 없는 상황
		
		su = su % 10;		// su %= 10;
		
		//if (su == 주민번호마지막자리숫자)
		//if (su == str마지막자리숫자)
		//if (su == str.substring(13,14)의 숫자)
		//if (su == str.substring(13)의 숫자)
		if (su == Integer.parseInt(str.substring(13)))
		{
			System.out.println(">> 정확한 주민번호~!!!");
		}
		else
		{
			System.out.println(">> 잘못된 주민번호~!!!");
		}
		*/
		
		
		
		/* 나의 풀이
		Scanner sc = new Scanner(System.in);
		
		String id;
		int[] a = {2, 3, 4, 5, 6, 7};
		int[] b = {8, 9, 2, 3, 4, 5};
		int res = 0;
		int sum=0;
		
		System.out.print("주민번호입력(xxxxxx-xxxxxxx) : ");
		id = sc.next();
		
		if (id.length() < 14 || id.length() > 14 )
		{
			System.out.println(">> 입력 오류~!!!");
		}
		
	
		for (int i=0; i<6; i++)
		{
			sum += a[i] * Integer.parseInt(id.substring(i,(i+1)));
			sum += b[i] * Integer.parseInt(id.substring(7,(i+8)));
		}
		
		res = sum % 11;
		res = 11 - res;
		
		if (res>9)
		{
			res = res % 10;
		}
		
		if (res == Integer.parseInt(id.substring(13)))
		{
			System.out.println(">> 정확한 주민번호~!!");
		}
		else
			System.out.println(">> 잘못된 주민번호~!!");
		*/
		
		
		
		//테스트
		/*
		String strTemp = "윤영식";
		System.out.println(strTemp.length());
		//--==>> 3
		
		strTemp = "동해물과 백두산이";
		System.out.println(strTemp.length());
		//--==>> 9
		
		strTemp = "study-hard";
		System.out.println(strTemp.length());
		//--==>> 10
		*/
		
		/*
		String strTemp = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
		System.out.println(strTemp.substring(13,17));	// 13 ~ 16
		//--==>> NOPQ
		
		//System.out.println(strTemp.substring(13,30));
		//--==>> 에러 발생(런타임 에러) 
		//		 StringIndexOutOfBoundsException
		
		System.out.println(strTemp.substring(13,26));
		//--==>> NOPQRSTUVWXYZ
		
		System.out.println(strTemp.substring(13));
		//--==>> NOPQRSTUVWXYZ
		
		System.out.println(strTemp.length());
		//--==>> 26
		
		System.out.println(strTemp.substring(13, strTemp.length()));
		//--==>> NOPQRSTUVWXYZ
		*/
		
	
		
	}
}

// 실행 결과

/*
주민번호입력(xxxxxx-xxxxxxx) : 750615-1862133
>> 정확한 주민번호~!!!
계속하려면 아무 키나 누르십시오 . . .
*/

/*
주민번호입력(xxxxxx-xxxxxxx) : 1234
>> 입력 오류~!!!
계속하려면 아무 키나 누르십시오 . . .
*/

/*
주민번호입력(xxxxxx-xxxxxxx) : 123154687482311312
>> 입력 오류~!!!
계속하려면 아무 키나 누르십시오 . . .
*/

/*
주민번호입력(xxxxxx-xxxxxxx) : 750615-1862138
>> 잘못된 주민번호~!!!
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 정렬(Sort) 알고리즘 ■■■
==========================================*/

/*
○ 정렬
	: 데이터를 특정한 규칙(기준)에 맞게 순서대로 나열(오름차순, 내림차순)
	
○ 정렬의 목적
	: 데이터 처리 과정의 편의성이나 가독성을 높이기 위함
	→ 보기 좋게... 찾아보기 쉽게... (검색하기 위함)
	
○ 정렬의 종류
	: 선택 정렬, 버블 정렬, 삽입 정렬, 힙 정렬, 퀵 정렬, 쉘 정렬, ...
	
*/

// 선택 정렬(Selection Sort)

//실행 예)
// Source Data : 52 42 12 62 60
// Sorted Data : 12 42 52 60 62
// 계속하려면 아무 키나 누르세요...

public class Test111
{
	public static void main(String[] args)
	{
		int[] a = {52, 42, 12, 62, 60};
		
		/*
		42, 52, 12, 62, 60
		==	--
		
		12, 52, 42, 62, 60
		==		--
		
		12, 52, 42, 62, 60
		==		    --
		
		12, 52, 42, 62, 60
		==				--
		
		----------------------------------------------- 1 회전 (웅~~~~)
		
		12, 42, 52, 62, 60
			==	--

		12, 42, 52, 62, 60
			==		--
		
		12, 42, 52, 62, 60
			==			--
		
		----------------------------------------------- 2 회전 (웅~~~~)
		
		12, 42, 52, 62, 60
				==	--
		
		12, 42, 52, 62, 60
				==		--		
		
		----------------------------------------------- 3 회전 (웅~~~~)
		
		12, 42, 52, 60, 62
					==	--
		
		----------------------------------------------- 4 회전 (웅~~~~)
		*/
		
		
		int i,j;
		
		// 배열 a 전체 요소 출력
		System.out.print("Source Data : ");
		
		// 향상된 for문(foreach 구문)
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		//--==>> Source Data : 52 42 12 62 60
		
		// 배열 a 전체 요소 출력
		System.out.print("Sorted Data : ");
		
		// Selection Sort
		for (i=0; i<a.length-1; i++)
		{
			for (j=i+1; j<a.length; j++)
			{
				//크기 비교
				//if (a[i] < a[j])			// 비교 기준이 비교대상보다 작다면...(내림차순 정렬)
				if (a[i] > a[j])			// 비교 기준이 비교대상보다 크다면...(오림차순 정렬)
				{
					//자리 바꿈
					a[i]=a[i]^a[j];
					a[j]=a[j]^a[i];
					a[i]=a[i]^a[j];
				}
			}
		}
		
		// 향상된 for문(foreach 구문)
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		
		
		/*
		// 배열 a 전체 요소 출력
		System.out.print("Source Data : ");
		
		
		for (i=0; i<a.length; i++)
		{
			System.out.print(a[i] + " ");
		}
		System.out.println();
		//--==>> Source Data : 52 42 12 62 60
		

		// 향상된 for문(foreach 구문)
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		
		// 배열 a 전체 요소 출력
		System.out.print("Sorted Data : ");
		
		for (i=0; i<a.length; i++)
			System.out.print(a[i] + " ");
		System.out.println();
		
		// 향상된 for문(foreach 구문)
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		*/
		
		
		/*
		System.out.print("Source Data :");
			
		for (int i=0; i<a.length; i++)
		{
			System.out.printf("%3d",a[i]);
		}
		System.out.println();
		
		int temp = 0;
		
		for (int i = 0; i<a.length-1; i++)
		{
			for (int j = i+1; j<a.length; j++)
			{
				if (a[i]>a[j])
				{
					temp = a[i];
					a[i] = a[j];
					a[j] = temp;
				}
			}
		}
		
		System.out.print("Sorted Data :");
		
		for (int i=0; i<a.length; i++)
		{
			System.out.printf("%3d",a[i]);
		}
		System.out.println();
		*/
	}
}

// 실행 결과

/*
Source Data : 52 42 12 62 60
Sorted Data : 12 42 52 60 62
계속하려면 아무 키나 누르십시오 . . .
*/import java.util.Vector;

public class Test1115{
	public static void main(String[] args){
		
		Vector<String> vt = new Vector<>();
	}
}

/*========================================
  ■■■ 정렬(Sort) 알고리즘 ■■■
==========================================*/

/*
○ 정렬
	: 데이터를 특정한 규칙(기준)에 맞게 순서대로 나열(오름차순, 내림차순)
	
○ 정렬의 목적
	: 데이터 처리 과정의 편의성이나 가독성을 높이기 위함
	→ 보기 좋게... 찾아보기 쉽게... (검색하기 위함)
	
○ 정렬의 종류
	: 선택 정렬, 버블 정렬, 삽입 정렬, 힙 정렬, 퀵 정렬, 쉘 정렬, ...
	
*/

// 버블 정렬(거품 정렬, Bubble Sort)

//실행 예)
// Source Data : 52 42 12 62 60
// Sorted Data : 12 42 52 60 62
// 계속하려면 아무 키나 누르세요...

public class Test112
{
	public static void main(String[] args)
	{
		int[] a = {52, 42, 12, 62, 60};
		
		/*
		42, 52, 12, 62, 60
		==	--
		
		42, 12, 52, 62, 60
			==	--
		
		42, 12, 52, 62, 60
				==	--
		
		42, 12, 52, 60, 62
					==	--
		
		----------------------------------------------- 1 회전 (웅~~~~)
		
		12, 42, 52, 60, 62
		==	--
		
		12, 42, 52, 60, 62
			==	--
		
		12, 42, 52, 60, 62
				==	--
		
		----------------------------------------------- 2 회전 (웅~~~~)
		
		12, 42, 52, 60, 62
		==	--
		
		12, 42, 52, 60, 62
			==	--
		
		----------------------------------------------- 3 회전 (웅~~~~)
		
		12, 42, 52, 60, 62
		==	--
		
		----------------------------------------------- 4 회전 (웅~~~~)
		*/
		
		int i,j;
		
		// 배열 a 전체 요소 출력
		System.out.print("Source Data : ");
		
		// 향상된 for문(foreach 구문)
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		
		// Bubble Sort
		for (i=1; i<a.length; i++)						// i → 1	 2	 3	4 → 뒤에서 비교 대상을 하나씩 줄여나가는 역할
		{												//		|    |   |  |
			for (j=0; j<a.length-i; j++)				// j → 0123 012 01 0 → 비교 기준 인덱스
			{											//      1234 123 12 1 → 비교 대상 인덱스(비교기준 + 1)
				//if (a[j] < a[j+1])					// 비교 기준이 비교 대상보다 작다면... (내림차순 정렬)
 				if (a[j] > a[j+1])						// 비교 기준이 비교 대상보다 크다면... (오름차순 정렬)
				{										
					// 자리 바꿈
					a[j]=a[j]^a[j+1];
					a[j+1]=a[j+1]^a[j];
					a[j]=a[j]^a[j+1];
					
				}
			}	
			
		}
		
		
		// 배열 a 전체 요소 출력
		System.out.print("Sorted Data : ");
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		
		
		
		/*
		int i,j,k;
		int[] a = {52, 42, 12, 62, 60};
		
		System.out.print("Source Data : ");
		
		for (i=0; i<a.length; i++)
			System.out.print(a[i] + " ");
		System.out.println();
		
		System.out.print("Sorted Data : ");
		
		for (i=0; i<a.length; i++)
		{
			for (j=0; j<a.length-i-1; j++)
			{
				if (a[j]>a[j+1])
				{
					int temp = a[j];
					a[j]=a[j+1];
					a[j+1]=temp;
				}
				

			}
				
		}
		
		for (i=0; i<a.length; i++)
			System.out.print(a[i] + " ");
		System.out.println();
		*/
	}
}

// 실행 결과

/*
Source Data : 52 42 12 62 60
Sorted Data : 12 42 52 60 62
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 정렬(Sort) 알고리즘 ■■■
==========================================*/

// 향상된 버블 정렬(Bubble Sort)

// ※ 앞에서 본 Selection Sort(Test111.java)나 Bubble Sort(Test112.java)의 성능은 같다.
//	  (→ 성능의 추정 근거 : 반복을 수행한 횟수)
//	  하지만, 향상된 Bubble Sort는 대상 데이터의 구조에 따라
//	  일반 Bubble Sort 나 Selection Sort 에 비해 성능이 좋을 수 있다.

// 향상된 버블 정렬(Bubble Sort)

//실행 예)
// Source Data : 62 12 20 22 30
// Sorted Data : 12 20 22 30 62
// 계속하려면 아무 키나 누르세요...

public class Test113
{
	public static void main(String[] args)
	{
		int[] a = {62, 12, 20, 22, 30};
		
		/*
		12, 62, 20, 22, 30
		==	--
		
		12, 20, 62, 22, 30
			==	--
		
		12, 20, 22, 62, 30
				==	--
		
		12, 20, 22, 30, 62
					==	--	
					
		----------------------------------------------- 1 회전 (웅~~~~)		true
														스왑 발생 → true → 다음 회전 실행 ○
		12, 20, 22, 30, 62
		==	--
		
		12, 20, 22, 30, 62
			==	--
		
		12, 20, 22, 30, 62
				==	--
				
		----------------------------------------------- 2 회전 (웅~~~~)		false
														스왑 발생 → false → 다음 회전 진행 X
		*/
		
		// 배열 a 전체 요소 출력
		System.out.print("Source Data : ");
		
		// 향상된 for문(foreach 구문)
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		
		// 향상된 Bubble Sort 구현
		int pass = 0;
		boolean flag;
		
		do
		{
			flag = false;						//-- 이번 회전에서 자리 바꿈(스왑)이 발생하지 않을 것이다...
			pass++;
			
			for (int i=0; i<a.length-pass; i++)
			{
				//테스트(확인)
				//System.out.print("쑝");
				
				
				//if (a[i] < a[i+1])		// 비교 기준이 비교 대상 보다 작다면... (내림차순 정렬)
				if (a[i] > a[i+1])			// 비교 기준이 비교 대상 보다 크다면... (오름차순 정렬)
				{
					// 자리 바꿈
					a[i]=a[i]^a[i+1];
					a[i+1]=a[i+1]^a[i];
					a[i]=a[i]^a[i+1];
					// 자리 바꿈 발생 시 flag = true;
					flag = true;
					//-- 단 한 번이라도 스왑(자리 바꿈)이 발생하게 되면
					//	 flag 변수는 true로 변경~!!!
				}
			}
			//System.out.println();
			
		}
		while (flag);		//flag == true
		//-- flag 변수가 false 라는 것은
		//	 회전이 구분적으로 발생하는 동안 스왑이 일어나지 않은 경우로
		//	 더 이상의 반복문 수행은 무의미한 것으로 판단 가능~!!!
		
		// 배열 a 전체 요소 출력
		System.out.print("Sorted Data : ");
		
		// 향상된 for문(foreach 구문)
		for (int n: a)
			System.out.print(n + " ");
		System.out.println();
		
		/*
		int i,j;
		int count=0;
		System.out.print("Source Data : ");
		
		for (i=0; i<a.length; i++)
			System.out.print(a[i] + " ");
		System.out.println();
		
		
		for (i=1; i<a.length; i++)
		{
			boolean flag = false;
			
			for (j=0; j<a.length-i; j++)
			{
				if (a[j] > a[j+1])
				{
					a[j]=a[j]^a[j+1];
					a[j+1]=a[j+1]^a[j];
					a[j]=a[j]^a[j+1];
					
					flag = true;
				}
			}
			
			if (!flag)
			{
				//flag = false;
				break;
			}
			
		}
		
		System.out.print("Sorted Data : ");
		
		for (i=0; i<a.length; i++)
			System.out.print(a[i] + " ");
		System.out.println();
		*/
		
		
	}
}

// 실행 결과

/*
Source Data : 62 12 20 22 30
Sorted Data : 12 20 22 30 62
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 정렬(Sort) 알고리즘 ■■■
==========================================*/

// ○ 과제
//	  사용자로부터 여러 학생의 성적 데이터를 입력받아
//	  점수가 높은 학생부터 낮은 순으로 등수를 부여하여
//	  결과를 출력하는 프로그램을 구현한다.
//	  단, 배열과 정렬 알고리즘을 활용하여 작성할 수 있도록 한다.


// 실행 예)
// 인원 수 입력 : 5
// 이름, 점수 입력(1, 공백 구분) : 안석창 90
// 이름, 점수 입력(2, 공백 구분) : 김민승 80
// 이름, 점수 입력(3, 공백 구분) : 김정현 85
// 이름, 점수 입력(4, 공백 구분) : 박지우 75
// 이름, 점수 입력(5, 공백 구분) : 공찬민 95

//---------------
// 1등 공찬민 95
// 2등 안석창 90
// 3등 김정현 85
// 4등 김민승 80
// 5등 박지우 75
//---------------
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;

public class Test114
{
	public static void main(String[] args)
	{
		Scanner sc = new Scanner(System.in);
		
		int inwon;
		
		System.out.print("인원 수 입력 : ");
		inwon = sc.nextInt();
		
		String[] name = new String[inwon];
		int[] score = new int[inwon];
		
		for (int i= 0; i<inwon; i++)
		{
			System.out.printf("이름, 점수 입력(%d, 공백 구분) : ",(i+1));
			name[i] = sc.next();
			score[i] = sc.nextInt();
		}
		
		
		
		for (int i=0; i < inwon-1; i++)
		{
			for (int j=(i+1); j < inwon; j++)
			{
				if (score[i] < score[j])
				{
					score[i] = score[i]^score[j];
					score[j] = score[j]^score[i];
					score[i] = score[i]^score[j];
					
					String temp = name[i];
					name[i] = name[j];
					name[j] = temp;
				}
			}
		}
		
		System.out.println();
		System.out.println("------------------------------");
		
		for (int i=0; i<inwon; i++)
		{
			System.out.printf("%d등 %s %d\n",(i+1),name[i],score[i]);
		}
		System.out.println("------------------------------");
		
		
	}
}
/*===========================
  ■■■ 클래스 고급 ■■■
  - 상속(Inheritance)
============================*/

/*
○ 상속(Inheritance)이란	- 단순히 코드의 재사용, 코드의 재활용을 의미하는 것은 아니다.
							- 무언가를 만들기 위한 가이드라인으로 보는게 더 적절할 수 있다.
					
	새로 설계(생성)하고자 하는 클래스가
	이미 설계되어 있는 다른 클래스의 기능과 중복되는 경우
	이미 설계된 클래스의 일부분이나 전체 구조를 공유할 수 있도록 하는 기능을 의미한다.
	
	즉, 상속은 객체를 좀 더 쉽게 만들 수 있는
	고수준의 재사용성(reuseability)을 확보하고 객체 간의 관계를 구성함으로써
	객체 지향의 또 다른 특징인 『다형성』의 문법적 토대가 된다.
	
	상속은 기존 프로그램의 클래스 내용을 공유함으로써
	중복된 코드들을 재작성할 필요 없이
	반복적이고 세부적인 작업을 처리하지 않기 때문에
	프로그램을 작성하는 시간을 절약할 수있고
	유지보수를 편리하게 할 수 있으며
	프로그램의 길이마저도 짧아지게 된다
	
	또한, 이미 작성된 프로그램들은 앞서 테스트되었기 때문에
	오류를 줄일 수 있어 현재 작성 중인 프로그램에만 전념할 수 있다.
	
※ 주의할 점
	
	자바는 『다.중.상.속』을 지원하지 않기 때문에
	두 개 이상의 클래스로부터 상속받을 수 없다.
	
	즉, 자바는 『단.일.상.속』만 지원한다.
	
*/
 
// 부모 클래스 == 상위 클래스 == 슈퍼(super) 클래스 == 물려주는 클래스 == 상속하는 클래스
class SuperTest115
{
	protected double area;
	
	// 생성자
	SuperTest115()
	{
		System.out.println("Super Class...");
	}
	
	void write(String title)
	{
		System.out.println(title + " - " + area);
	}
}



// 자식 클래스 == 하위 클래스 == 서브(sub) 클래스 == 물려받는 클래스 == 상속받는 클래스
public class Test115 extends SuperTest115
{
	/*
	
	protected double area;							// 부모로부터 물려받은 area 속성
	
	// check~!!!
	// ※ 생성자는 상속 대상에서 제외된다~!!!
		
	void write(String title)						// 부모로부터 물려받은 write() 메소드
	{
		System.out.println(title + " - " + area);
	}
	}
	*/
	
	// 사용자 정의 생성자를 별도로 정의하지 않았음...
	// 
	// 자동으로 삽입되는 default 생성자~!!!
	/*
	public Test115()
	{
		super();
	}
	*/
	//				↓
	// 사용자 정의 생성자
	public Test115()
	{
		//System.out.println("Sub Class...");
		
		// 텅 비어있다~!!!						//--(Ⅹ)
		//
		// 부모 클래스의 생성자 호출 구문~!!!	//--(○)
		// SuperTest115();
		//this();
		// → Test115();
		//super();
		// → SuperTest115(); 클래스가 extends 하고 있는 클래스 
		
		// ※ 생성자 내부에서 또다른 생성자를 호출하는 문법
		//	  - 가능하다. 단, 생성자 내부에서 가장 먼저 실행되어야 한다.
		
		System.out.println("Sub Class...");
		
		
	}
	
	public void actionCircle()
	{
		int r = 10;
		//area = r * r * 3.141592;
		//this.area = r * r * 3.141592;
		super.area = r * r * 3.141592;
		
		write("원");
	}
	
	public void actionRect()
	{
		int w=20, h=5;
		area = w*h;
		
		write("사각형");
	}
	
	
	public static void main(String[] args)
	{
		// Test115(자식) 기반 인스턴스 생성
		Test115 ob = new Test115();
		//--==>> Super Class...
		//		 Sub Class...
		
		ob.actionCircle();
		//--==>> 원 - 314.1592
		
		ob.actionRect();
		//--==>> 사각형 - 100.0
		
	}	
}

// 실행 결과

/*
Super Class...
Sub Class...
원 - 314.1592
사각형 - 100.0
계속하려면 아무 키나 누르십시오 . . .
*//*===========================
  ■■■ 클래스 고급 ■■■
  - 상속(Inheritance)
============================*/

/*
※ 『super』

	static 으로 선언되지 않은 메소드에서 사용되며
	현재 클래스가 상속받는 상위 클래스의 객체를 가리킨다.
	super는 상위 클래스의 생성자를 호출하거나
	상위 클래스의 멤버 변수또는 메소드를 호출할 때 사용할 수 있다.
	
	하위 클래스의 생성자에서 상위 클래스의 생성자를 호출할 때에는
	하위 클래스의 생성자 정의 구문에서 맨 처음에만 위치할 수 있다
	
※ 생성자와 클래스 상속간의 관계

	하위 클래스는 상위 클래스의 멤버를 상속받지만,
	생성자는 상속대상에서 제외된다.
	그리고 하위 클래스의 생성자가 호출될 때
	자동으로 상위 클래스의 생성자를 호출하게 된다.
	(해당 구문이 존재하지 않을 경우 자동 삽입)
	이 때, 상위 클래스의 생성자는 
	인수가 없는 생성자 (default 생성자 형태)가 호출된다.
	
	상위 클래스 및 하위 클래스(즉, 상속 관계에 있는 클래스)를 설계하는 과정에서
	상위 클래스의 생성자를 정의하지(작성하지)않거나
	인수가 없는 생성자만을 정의한(작성한) 경우
	명시적으로 하위 클래스에서 상위 클래스의 생성자를 호출하지 않아도
	아무런 문제가 발생하지 않지만,
	상위 클래스에 인자가 있는 생성자만 존재하는 경우
	주의해야한다.
	
	예를 들어... 다음에서...
	
	class Aclass
	{
		Aclass(int n)
		{
		}
	
	}
	
	class Bclass extends Aclass
	{
		Bclass()
		{
			// super();
		}
	}
	
	하위 클래스인 Bclass의 생성자에서
	명시적으로 Aclass 의 생성자를 호출하지 않으면
	자동으로 인자없는 생성자를 호출한다.
	하지만 Aclass에느 인자가 있는 생성자만 존재하고
	인자가 없는 생성자는 존재하지 않기 때문에 에러 발생한다.
	따라서 Bclass 생성자의 선두에
	다음처럼 명시적으로 상위 클래스의 생성자 호출 구문을 작성해야 한다.
	
	class Aclass
	{
		Aclass(int n)
		{
		}
	}
	
	class Bclass extends Aclass
	{
		Bclass()
		{
			super(10);
			...
			...
		}
	}
	
※ 상속 시 주의할 사항
	
	상위 클래스에서 선언된 멤버 변수의 이름과
	하위 클래스에서 선언된 멤버 변수의 이름이 같으면
	상위 클래스의 멤버 변수는 무시된다.
	이 때, 상위 클래스의 멤버 변수를 사용하기 위해서는
	『super』키워드를 이용한다.
	
	동일한 이름의 멤버 변수나 동일한 이름의 메소드가 
	한 클래스 안에 선언되거나 정의되는 경우 기본적으로 에러 발생한다.
	단, 메소드의 경우에는 매개변수의 갯수나 타입이 다른 경우
	에러 발생하지 않고 이들을 서로 다른 메소드로 취급하는 문법이 지원된다.
	→ 메소드 오버로딩
*/



// Rect116 클래스와 Circle116 클래스의 부모 클래스
class SuperTest116
{
	
	protected double area;								//-- protected 는 상속을 염두해두고 사용했다고 생각하면 된다.
	private String title;
	
	public SuperTest116()
	{
		System.out.println("SuperTest116... 인자 없는 생성자");
	}
	
	public SuperTest116(String title)
	{
		this.title = title;
		System.out.println("SuperTest116... 문자열을 인자로 받는 생성자");
	}
	
	public void write()
	{
		System.out.println(title + " - " + area); 
	}
	
}

// SuperTest116 클래스를 상속받는 자식 클래스(단일 상속)
class Rect116 extends SuperTest116 //, SuperTest115 
{
	/*
	protected double area;
	
	// ※ private 멤버는 접근 자체가 불가능~!!! → 상속 불가
	//private String title;
	
	// ※ 생성자는 상속 대상에서 제외~!!!
	//public SuperTest116()
	//{
	//	System.out.println("SuperTest116... 인자 없는 생성자");
	//}
	
	// ※ 생성자는 상속 대상에서 제외~!!!
	//public SuperTest116(String title)
	//{
	//	this.title = title;
	//	System.out.println("SuperTest116...  문자열을 인자로 받는 생성자");
	//}
	
	public void write()
	{
		System.out.println(title + " - " + area); 
	}
	*/
	
	private int w, h;
	
	// 자식 클래스의 사용자 정의 생성자
	public Rect116()
	{
		// 부모 클래스의 생성자 호출 구문 자동 삽입
		// super();			// SuperTest116();
	}
	
	
	public void calc(int w, int h)
	{
		this.w = w;
		this.h = h;
		area = (double)this.w + this.h;
		write();
	}
	
	// 자바야~ 나 이거 물려받은거 의도적으로 튜닝한거다.
	@Override						//-- 어노테이션(annotation) - metadata - JDK 1.5 / 일종의 주석 - 컴파일 과정까지 남겨두는 주석
	public void write()
	{
		System.out.println("w : " + w + ",h : " + h);
		System.out.println("사각형 - " + area);
	}
	
	// ※ 메소드 재정의 (메소드 오버라이딩, Method Overriding)
	//
	//	  상위 클래스를 상속받은 하위클래스에서
	//	  상위 클래스에 정의된 메소드를 다시 정의하는 것으로(재정의)
	//	  객체 지향 프로그래밍의 특징인 다형성을 나타낸다.
	//	  재정의(Overriding)는 반드시 상속 관계에 있어야 하며,
	//	  메소드 이름, 리턴 타입, 매개변수의 갯수나 타입이 
	//	  모두 완전히 일치해야 한다.
		
}

// SuperTest116 클래스를 상속받는 자식 클래스(단일 상속)
class Circle116 extends SuperTest116
{
	/*
	protected double area;
	
	// ※ private 멤버는 접근 자체가 불가능~!!! → 상속 불가
	//private String title;
	
	// ※ 생성자는 상속 대상에서 제외~!!!
	//public SuperTest116()
	//{
	//	System.out.println("SuperTest116... 인자 없는 생성자");
	//}
	
	// ※ 생성자는 상속 대상에서 제외~!!!
	//public SuperTest116(String title)
	//{
	//	this.title = title;
	//	System.out.println("SuperTest116...  문자열을 인자로 받는 생성자");
	//}
	
	public void write()
	{
		System.out.println(title + " - " + area); 
	}
	*/
	
	// 자식 클래스의 사용자 정의 생성자
	public Circle116(String title)
	{
		// 부모 클래스의 생성자 호출 구문 자동 삽입
		// super();			// SuperTest116();
		
		super(title);
	}
	
	public void calc(int r)
	{
		area = r * r * 3.141592;
		write();
	}
	

}


// main() 메소드를 포함하는 외부의 다른 클래스
public class Test116
{
	public static void main(String[] args)
	{
		// Rect116 클래스(자식 클래스) 기반 인스턴스 생성
		Rect116 ob1 = new Rect116();
		//--==>> SuperTest116... 인자 없는 생성자
		
		// Circle116 클래스(자식 클래스) 기반 인스턴스 생성
		//Circle116 ob2 = new Circle116();
		//--==>> 에러 발생(컴파일 에러)
		//		 constructor Circle116 in class Circle116 cannot be applied to given types;
		//-- 현재 Circle116 클래스에는 매개변수를 필요로하는 사용자 정의 생성자가 만들어져 있으며
		//   이로인해 default 생성자가 자동으로 삽입되지 않는 상태
		
		//Circle116 클래스(자식 클래스) 기반 인스턴스 생성
		Circle116 ob2 = new Circle116("원");
		//--==>> SuperTest116... 인자 없는 생성자
		
		// line219 삽입 후...
		//--==>> SuperTest116... 문자열을 인자로 받는 생성자
		
		ob1.calc(10,5);
		//--==>> w : 10,h : 5
		//		 사각형 - 15.0
		
		ob2.calc(20);
		//--==>> 원 - 1256.6368
		
	}	

}


/*
====================================================================================================
상위 클래스		| 하위 클래스			| 결과
----------------------------------------------------------------------------------------------------
생성자를		| 생성자 정의 안함		| → 가능하다.
정의하지		| 인수가 없는 생성자	| → 가능하다.
않음			| 인수가 있는 생성자	| → 가능하다.
----------------------------------------------------------------------------------------------------
인수가			| 생성자 정의 안함		| → 가능하다.
없는			| 인수가 없는 생성자	| → 가능하다.	
생성자만 정의	| 인수가 있는 생성자	| → 가능하다.
----------------------------------------------------------------------------------------------------
인수가			| 생성자 정의 안함		| → 에러 발생.	
있는			| 인수가 없는 생성자	| → 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생.
생성자만 정의	| 인수가 있는 생성자	| → 상위 클래스의 해당 생성자를 호출하지 않으면 에러 발생.
====================================================================================================
*//*===========================
  ■■■ 클래스 고급 ■■■
  - 상속(Inheritance)
============================*/

// 다음과 같은 프로그램을 구현한다.
// 단, 상속의 개념을 적용하여 작성할 수 있도록 한다.

// 실행 예)
// 임의의 두 정수 입력(공백 구분) : 20 15
// 연산자 입력(+ - * /) : -
// >> 20 - 15 = 5
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

class Aclass
{
	protected int x, y;
	protected char op;
	
	Aclass()
	{
	}
	
	void write(double result)
	{
		System.out.printf(">> %d %c %d = %.2f\n",x,op,y,result);
	}
	
}


// Aclass 를 상속받는 클래스로 설계
class Bclass extends Aclass 
{
	/*
	protected int x, y;
	protected char op;
	
	void write(double result)
	{
		System.out.printf(">> %d %c %d = %.2f\n",x,op,y,result);
	}
	*/
	
	Bclass()
	{
		// super();
	}
	
	boolean input() throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("임의의 두 정수 입력(공백 구분) : ");		// "20 15"
		String temp = br.readLine();
		
		// ※ 문자열.split("구분자");   //-- 구분자를 이용해서 문자열을 토막낸다.
		//	  문자열.split("\\s");		//-- 구분자 → 공백
		//	  ex) "10 20 30 40 50".split("\\s");
		//		  → 반환 → {"10", "20", "30", "40", "50"}
		//
		//	  ex) "010-2349-8680".split("-")
		//		  → 반환 → {"010", "2349", "8680"}
		
		String[] strArr = temp.split("\\s");
		
		if (strArr.length != 2)
		{
			return false;		// false값 반환 + 메소드 종료
		}
		//-- false를 반환하며 input() 메소드 종료
		//	 즉, 이 조건을 만족하여 if 을 수행하게 될경우...
		//	 아래 수행해야 할 코드가 남아있더라도
		//	 결과값(false)를 반환하며 메소드는 종료된다.
		
		x = Integer.parseInt(strArr[0]);
		y = Integer.parseInt(strArr[1]);
		
		System.out.print("연산자 입력(+ - * /) : ");
		op = (char)System.in.read();
		
		/*
		if (op != '+' && op != '-' && op != '*' && op != '/')	// 유효하지 않은 연산자일 경우
		{
			return false;										// false 를 반환하며 메소드 종료
		}
		
		return true;
		*/
		
		if (op=='+' || op=='-' || op=='*' || op=='/' )													// 유효한 연산자일 경우
		{
			return true;										// true를 반환하며 메소드 종료
		}
		return false;
	
	}// close input
	
	
	double calc()
	{
		double result = 0;
		
		switch (op)
		{
			case '+' : result = x + y; break;
			case '-' : result = x - y; break;
			case '*' : result = x * y; break;
			case '/' : result = (double)x / y; //break;
		}
		
		return result;
	}
	
	
	
	
	/* 나의 풀이
	void input() throws IOException
	{
		Scanner sc = new Scanner(System.in);
		
		System.out.print("임의의 두 정수 입력(공백 구분) : ");
		x = sc.nextInt();
		y = sc.nextInt();
		
		System.out.print("연산자 입력(+ - * /) : ");
		op = (char)System.in.read();
	}
	
	double calc()
	{
		double result = 0.0;
		
		switch(op)
		{
			case '+': result = x + y; break;
			case '-': result = x - y; break;
			case '*': result = x * y; break;
			case '/': result = x / y; break;
		}
		return result;	
	}
	*/
}

// main() 메소드를 포함하고 있는 외부의 다른 클래스
public class Test117
{
	public static void main(String[] args) throws IOException
	{
		// Bclass(하위 클래스) 인스턴스 생성
		Bclass ob = new Bclass();
		
		//ob.input();
		
		if (!ob.input())
		{
			System.out.println("Error...");
			return;
		}
		
		double result = ob.calc();
		
		ob.write(result);
		
		
		
		/* 나의 풀이
		Bclass ob = new Bclass();
		
		ob.input();
		
		double result = ob.calc();
		
		ob.write(result);
		*/
	}
}

// 실행 결과

/*
임의의 두 정수 입력(공백 구분) : 250 32
연산자 입력(+ - * /) : /
>> 250 / 32 = 7.81
계속하려면 아무 키나 누르십시오 . . .
*/

/*===========================
  ■■■ 클래스 고급 ■■■
  - 상속(Inheritance)
============================*/

/*
※ 메소드 오버라이딩(Method Overriding)의 특징

	- 메소드 이름, 리턴 타입, 파라미터 수나 타입이 완전히 일치해야 한다.
	- 반드시 상속관계가 있어야한다.
	- 재정의된 하위 클래스의 메소드 접근제어지시자는
	  상위 클래스의 메소드 접근제어지시자보다 범위가 크거나 같아야 한다.
	  예를 들어 상위 클래스 메소드의 접근제어지시자가 『protected』인 경우
	  하위 클래스가 이 메소드를 오버라이딩(Overriding)하는 경우
	  접근제어지시자는 『public』 또는 『protected』이어야 한다.
	- 『static』, 『final』, 『private』 메소드는 오버라이딩(Overriding)할 수 없다.
	- Exception의 추가가 불가능하다.
	  즉, 상위 메소드가 가지고 있는 기존 예외 사항에
	  새로운 Exception을 추가하는 것은 불가능하다는 것이다.
*/

// 부모 클래스(상위 클래스, super class)
class SuperTest118
{
	private int a = 5;
	protected int b = 10;
	public int c = 20;
	
	public void write()
	{
		System.out.println("Super write() 메소드 : " + a + " : " + b + " : " + c);
	}
}

// 자식 클래스(하위 클래스, sub class)
class SubTest118 extends SuperTest118
{
	/*
	protected int b = 10;
	public int c = 20;
	
	public void write()
	{
		System.out.println("Super write() 메소드 : " + a + " : " + b + " : " + c);
	}
	*/
	
	protected int b = 100;
	
	public void print()
	{
		//System.out.println("Sub write() 메소드 : " + a + " : " + b + " : " + c);
		//--==>> 에러 발생(컴파일 에러)
		//-- 슈퍼 클래스에서 선언된 변수 a 에는 접근할 수 없다.
		//   → private 변수이기 때문에...
		
		System.out.println("Sub print() 메소드 : " + b + " : " + c);
		
		System.out.println("Sub print() 메소드 : " + b);
		System.out.println("Sub print() 메소드 : " + this.b);	//SubTest118.b
		System.out.println("Sub print() 메소드 : " + super.b);	//SuperTest118.b
		//--==>> Sub print() 메소드 : 100
		//		 Sub print() 메소드 : 100
		//		 Sub print() 메소드 : 10
		//-- 변수 b 는 접근 방법에 따라 다른 b 로 접근 및 출력이 이루어진다.
		//	 슈퍼 클래스에서 선언된 b, 서브 클래스에서 선언된 b
		
		System.out.println("Sub print() 메소드 : " + c);
		System.out.println("Sub print() 메소드 : " + this.c);	//SubTest118.c
		System.out.println("Sub print() 메소드 : " + super.c);	//SuperTest118.c
		//--==>> Sub print() 메소드 : 20
		//		 Sub print() 메소드 : 20
		//		 Sub print() 메소드 : 20
		//-- 변수 c는 접근하는데 아무런 제약과 제한이 없다.
		//	 슈퍼 클래스에서 선언한 c
		
	}//close print()
	
	@Override
	public void write()
	{
		//System.out.println("Super write() 메소드 : " + a + " : " + b + " : " + c);
		//--==>> 에러 발생(컴파일 에러)
		//-- 슈퍼 클래스에서 선언된 변수 a 에는 접근할 수 없다. (print() 메소드와 같은 상황...)
		//   → private 변수이기 때문에...
		
		System.out.println("Super write() 메소드 : " + b + " : " + c);
	}
}

// main() 메소드를 포함하는 외부의 다른 클래스
public class Test118
{
	public static void main(String[] args)
	{
		// 하위 클래스(SubTest118) 인스턴스 생성
		SubTest118 ob = new SubTest118();
		
		ob.print();
		//--==>> Sub print() 메소드 : 100 : 20
		
		ob.write();
		//--==>> Super write() 메소드 : 5 : 10 : 20
		
		// 하위 클래스(SubTest118)에서 재정의 후 호출
		//--==>> 에러 발생(컴파일 에러)
		
		// a 접근 구문을 제거한 후 호출
		//--==>> Super write() 메소드 : 100 : 20
		
		System.out.println("------------------------------------구분선");
		
		System.out.println(ob.b);
		//--==>> 100
		
		//System.out.println(((부모)ob).b);
		System.out.println(((SuperTest118)ob).b);
		//--==>> 10
		// ※ 슈퍼 부름
		
		System.out.println(ob.c);
		//--==>> 20
		
		System.out.println(((SuperTest118)ob).c);
		//--==>> 20
		
		ob.write();
		//--==>> Super write() 메소드 : 100 : 20
		
		((SuperTest118)ob).write();
		//--==>> Super write() 메소드 : 100 : 20
		
		// check
		// ※ 메소드와 변수를 꼭~!!! 구분하여 정리할 것~!!! → 메소드는 슈퍼 부름 X
		// 외부의 다른 클래스에서 하위 클래스의 인스턴스를 생성하면 부모의 속성과 자식의 속성은 각각 따로 메모리에 할당된다.
		// 부모와 자식의 메소드는 합쳐져서 메모리에 할당된다. → 덮어써짐
		
	}
}

// 실행 결과

/*
Sub print() 메소드 : 100 : 20
Sub print() 메소드 : 100
Sub print() 메소드 : 100
Sub print() 메소드 : 10
Sub print() 메소드 : 20
Sub print() 메소드 : 20
Sub print() 메소드 : 20
Super write() 메소드 : 100 : 20
------------------------------------구분선
100
10
20
20
Super write() 메소드 : 100 : 20
Super write() 메소드 : 100 : 20
계속하려면 아무 키나 누르십시오 . . .
*//*===========================
  ■■■ 클래스 고급 ■■■
  - 추상 클래스(abstract)
============================*/

/*
○ 추상 클래스(abstract)는

	선언만 있고 정의가 없는 하나 이상의 메소드(추상 메소드)를 갖는 클래스로
	하위 클래스(자식 클래스)에서 오버라이딩(Overriding)할 것으로 예상되는 메소드에 대해
	메모리 낭비 없이 미리 호출 계획을 세워두기 위해 만든다.
	
○ 형식 및 구조
	
	[접근제어지시자] abstract class 클래스명
	
		[접근제어지시자] abstract 자료형 메소드명([매개변수],...);
		
○ 특징

	클래스가 적어도 하나 이상의 추상 메소드를 포함할 때
	그 클래스는 클래스 앞에 『abstract』 키워드를 붙여
	추상 클래스로 명시해야하며,
	추상 클래스로 선언한 경우에는
	불완전한 형태의 클래스이므로 객체를 생성할 수 없다.
	추상 메소드가 존재하지 않는 추상 클래스마저도
	객체를 생성할 수 없는 것이다.

	즉, 추상 클래스는 독립적으로 존재할 수 없기 때문에
	상속을 위해서만 존재하며,
	추상 클래스를 상속받은 하위 클래스에서는
	반드시 추상 메소드를 오버라이딩(Overriding)해야 한다.

※ 『abstract』 키워드는 
	클래스와 메소드에서만 사용할 수 있으며
	멤버 변수나 로컬 변수에서는 사용할 수 없다.
*/

// Source Data : 7 10 3 28 7
// Sorted Data : 3 7 7 10 28
// 계속하려면 아무 키나 누르세요...



// 클래스
//class SuperSortInt119
//	↓
// 추상 클래스
abstract class SuperSortInt119
{
	private int[] value;
	
	protected void sort(int[] value)
	{
		this.value = value;
		sorting();
	}
	
	// 추상 메소드
	protected abstract void sorting();
	//{
	//	......;
	//}
	
	protected int dataLength()
	{
		return value.length;
	}
	
	// 『final』키워드로 인해
	// 이 클래스(SuperSortInt119)를 상속받는 클래스에서
	// 이 메소드를 재정의(Method Overriding)할 수 없다.
	protected final int compare(int i, int j)
	{
		int x = value[i];
		int y = value[j];
			
		if (x==y)
			return 0;
		else if (x>y)
			return 1;
		else 
			return -1;
	}
	
	// 『final』키워드로 인해
	// 이 클래스(SuperSortInt119)를 상속받는 클래스에서
	// 이 메소드를 재정의(Method Overriding)할 수 없다.
	protected final void swap(int i, int j)
	{
		int temp = value[i];
		value[i] = value[j];
		value[j] = temp;
	}
	
}// close class SuperSortInt119

// 클래스
// class Test119
//	↓
// 추상 클래스(SuperSortInt119)를 상속받은 클래스 → 일단은 추상 클래스
//abstract class Test119 extends SuperSortInt119
//	↓
// 추상 메소드(sorting())를 Overriding  → 일반 정상 클래스 
class Test119 extends SuperSortInt119
{
	/*
	protected void sort(int[] value)
	{
		this.value = value;
		sorting();
	}
	
	protected abstract void sorting();
	
	protected int dataLength()
	{
		return value.length;
	}
	
	protected final int copmpare(int i, int j)
	{
		int x = value[i];
		int y = value[j];
			
		if (x==y)
			return 0;
		else if (x>y)
			return 1;
		else 
			return -1;
	}
	
	protected final void swap(int i, int j)
	{
		int temp = value[i];
		value[i] = value[j];
		value[j] = temp;
	}
	*/
	
	int i,j;			//-- 루프 변수
	
	static int[] data = {7, 10, 3, 28, 7};
	
	
	//protected abstract void sorting();
	@Override
	protected void sorting()
	{
		// Selection Sort
		for (i=0; i<dataLength()-1; i++)
		{
			for (j=i+1; j<dataLength(); j++)
			{
				//크기 비교
				if (compare(i, j) > 0)
				{
					// 자리 바꿈
					swap(i, j);
				}
				
				/* 나의 풀이
				if (data[i] > data[j])
				{
					data[i] = data[i]^data[j];
					data[j] = data[j]^data[i];
					data[i] = data[i]^data[j];
				}
				*/
			}
		}
	}
	
	// main() 메소드
	public static void main(String[] args)
	{
		//SuperSortInt119 ob = new SuperSortInt119();
		
		//SubSortInt119 ob = new SubSortInt119();
		
		
		
		System.out.print("Source Data  : ");
		for (int n: data)
			System.out.print(n + " ");
		System.out.println();
		
		Test119 ob = new Test119();
		
		ob.sort(data);
		
		System.out.print("Sorted Data  : ");
		for (int n: data)
			System.out.print(n + " ");
		System.out.println();
	}
	
	
	
}

// 실행 결과

/*
Source Data  : 7 10 3 28 7
Sorted Data  : 3 7 7 10 28
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 클래스 고급 ■■■
  - 상속 관계에 있는 클래스들 간의 캐스팅
	(업 캐스팅, 다운 캐스팅)
=========================================*/

// super class, 부모 클래스, 상위 클래스
class SuperTest120
{
	public int a = 10, b=20;
	
	public void write()
	{
		System.out.println("슈퍼 클래스 write() 메소드...");
	}
	
	public int hap()
	{
		return a + b;
	}
	
}


// sub class, 자식 클래스, 하위 클래스
class SubTest120 extends SuperTest120
{
	/*
	public int a = 10, b=20;
	
	public void write()
	{
		System.out.println("슈퍼 클래스 write() 메소드...");
	}
	
	//public in hap()
	//{
	//	return a + b;
	//}
	*/
	
	public int b=100, c=200;
	
	public void print()
	{
		System.out.println("서브 클래스 print() 메소드...");
	}
	
	@Override
	public int hap()
	{
		return a + b + c;
	}
}



// main() 메소드를 포함하고 있는 외부의 다른 클래스
public class Test120
{
	public static void main(String[] args)
	{
		// 하위 클래스(SubTest120) 기반 인스턴스 생성
		SubTest120 ob1 = new SubTest120();					// 자식뿐만 아니라 부모도 메모리에 할당
		
		System.out.println("ob1.b : " + ob1.b);
		//--==>> ob1.b : 100
		
		// ○ 업 캐스팅
		//SuperTest120 ob2;
		SuperTest120 ob2 = ob1;
		//-- 『SuperTest120 ob2 = (SuperTest120)ob1;』과 동일한 코드
		
		/*
		학생 정현이 = new 학생();
		
		포유류 사람 = 정현이;
		//-- 『포유류 사람 = (포유류)정현이;』과 동일한 코드
		
		※ 학생도 포유류
		
		class 포유류		학생 extends 포유류
		{					{
		}					}
		
		
		*/
		
		
		System.out.println("ob1.b : " + ((SuperTest120)ob1).b);
		//--==>> ob1.b : 20
		
		System.out.println("ob2.b : " + ob2.b);
		//--==>> ob2.b : 20
		//-- 변수는 개체별로 따로 할당되기 때문에
		//   변수 b 는 ob2 의 변수이다.
		
		System.out.println("합    : " + ob2.hap());
		//--==>> 합    : 310
		//-- hap() 메소드는 오버라이딩(Overriding)되어 있고
		//	 ob2는 ob1을 업 캐스팅한 상태의 객체이므로
		//	 『SuperTest120』 에서 hap() 메소드를 호출하는 것이 아니라
		//	 『SubTest120』 에서 재정의한 hap() 메소드를 호출하게 된다.
		//	 즉, 메소드느 업캐스팅이 되더라도
		//	 재정의(덮어쓰기)한 이상... 원래의 기능을 되돌릴 수 없다.
	
		ob2.write();
		//--==>> 슈퍼 클래스 write() 메소드...
		
		//ob2.print();
		//--==>> 에러 발생(컴파일 에러)
		//		 cannot find symbol
		
		
		// ○ 다운 캐스팅
		((SubTest120)ob2).print();
		//--==>> 서브 클래스 print() 메소드...
		
		
		// ※ 추가 관찰 --------------------------------------------------------------
		//	  다운 캐스팅의 가능 여부
		
		// 상위 클래스(SuperTest120) 기반 인스턴스 생성
		SuperTest120 ob3 = new SuperTest120();				// 부모만 메모리에 할당
		
		SubTest120 ob4;
		
		//System.out.println("ob3.c : " + ob3.c);
		//--==>> 에러 발생(컴파일 에러)
		//		 cannot find symbol
		//-- 상위 객체는 하위 객체의 멤버에 접근하는 것이 불가능하다.
		//   (사실 상위 객체 입장에서는 어떤 하위 객체가 존재하는지도 알 수 없음)
		
		//ob4 = ob3;
		//--==>> 에러 발생(컴파일 에러)
		//-- 상위 객체는 하위 객체에 담을 수(참조할 수) 없다.
		
		
		ob4 = (SubTest120)ob3;
		//--==>> 에러 발생(런타임 에러)
		//		 java.lang.ClassCastException
		//-- 작성된 구문의 문법적인 구조만 봤을 때
		//   다운 캐스팅이 이루어지는 상황이다.
		//   하지만, 정상적인 캐스팅이 이루어지지 않는다.
		//   현재 SubTest120객체에 대한 메모리 할당이 이루어지지 않은 상태이기 때문에
		//   다운 캐스팅은 불가능한 것이다.
		
	}
}


/*
○ 업 캐스팅, 다운 캐스팅이 정상적으로 이루어지는 경우---------------------------------
	
	1. 하위 객체 생성;			// check!!
	2. 상위 = 하위;				// 업 캐스팅. 정상.
	3. 하위 = 상위;				// 에러 발생.
	4. 하위 = (하위)상위;		// 다운 캐스팅. 정상.
	
	
○ 다운 캐스팅이 정상적으로 이루어지지 않는 경우---------------------------------------

	1. 상위 객체 생성;			// check!!
	2. 하위 = 상위;				// 에러 발생.
	3. 하위 = (하위)상위;		// 다운 캐스팅. 런타임 에러 발생.
	
	
※ 업 캐스팅은 항상 가능. 다운 캐스팅은 경우에 따라 가능.
*//*========================================
  ■■■ 클래스 고급 ■■■
  - 인터페이스(Interface)
=========================================*/

/*
○ 인터페이스(Interface)란 - 모두 추상 메소드여야 한다.

	완전히 미완성된 채로 남겨져
	인터페이스 안에 존재하는 그 어떤 메소드도
	몸체(정의부)가 없기 때문에 사실상 실행 부분이 존재하지 않는다.
	클래스를 위한 템플릿으로써의 기능을 수행하는
	추상 클래스의 한 종류이다.
	
○ 인터페이스는 클래스와 달리 다중 상속이 가능하며
   인터페이스 자체도 상속된다.
   기존의 C++ 언어 등에서 지원되는 다중 상속이
   사용 과정에서 많은 문제점을 노출 시켰기 때문에
   자바에서는 다주 상속의 개념을 인터페이스라는 개념으로 변형하여
   인터페이스를 통해 다중 상속을 구현하는 방법을 지원한다.

○ 인터페이스는 상수와 추상 메소드만 가질 수 있으며
   인터페이스 안의 메소드들은 접근제어지시자를 명시하지 않아도
   『public』으로 설정되어 클래스에서 구현(implement)함으로써
   바로 접근이 이루어질 수 있다.

○ 특징
	- 추상 클래스의 일종으로 선언만 있고 정의가 없다.
	- final변수는 가질 수 있다. (상수의 개념)
	- 인터페이스는 『public static final』 상수만 만들 수 있다.
	- 인터페이스를 구현하기 위해서는 『extends』 대신에
	  『implements』를 이용한다.
	- 하나 이상의 인터페이스를 implements할 수 있다.
	- 인터페이스를 implements 한 클래스는 
	  인터페이스의 모든 메소드를 Overriding해야한다.
	- 인터페이스가 다른 인터페이스를 상속받을수 있으며
	  이때 『extends』 키워드를 사용한다.
	  또한 클래스와 달리 인터페이스는 다중 상속이 가능하다.

*/


// 인터페이스
interface Demo
{
	public static final double PI = 3.141592;
	
	// 인터페이스의 멤버 변수는
	// 『static final』을 별도로 명시하지 않아도
	// 자동으로 『static final』인 상태
	
	public int a = 10;
	
	// 인터페이스의 메소드는 선언만 가능(정의 불가)
	// 자동으로 『abstract』인 상태
	//public abstract void print();
	public void print();
	//{
	//	System.out.println("PI : " + PI);
	//}
	
}

// 클래스
//class DemoImpl
//class DemoImpl extends Demo	//--(X)
//class DemoImpl implements Demo
//			↓
// 추상 클래스 → 인터페이스(Demo)를 구현하는 추상 클래스
//abstract class DemoImpl implements Demo
//			↓
// 클래스 - 인터페이스(Demo)를 구현하는 클래스(→print()메소드 재정의)
class DemoImpl implements Demo
{
	public void write()
	{
		System.out.println("클래스에 정의된 메소드...");
	}
	
	@Override
	public void print()
	{
		System.out.println("인터페이스 메소드 재정의...");
	}
	
}


// main() 메소드를 포함하는 외부의 다른 클래스
public class Test121
{
	public static void main(String[] args)
	{
		//Demo ob = new Demo();			//-- 생성 불가!!
		//-- 인터페이스는 인스턴스를 생성할 수 없음
		
		//DemoImpl ob = new DemoImpl();
		//-- 인터페이스를 implements 만 한 상태에서는 불가
		//	 print()메소드를 재정의 해서 abstract를 떼어낸 후 가능
		
		
		//DemoImpl obTemp = new DemoImpl();
		//Demo ob = (Demo)obTemp;
		//Demo ob = obTemp;
		
		// ○ 업 캐스팅
		// 인터페이스 객체는 상위 객체
		Demo ob = new DemoImpl();
		ob.print();
		//--==>> 인터페이스 메소드 재정의...
		
		//ob.write();
		//--==>> 에러 발생(컴파일 에러)
		//	     cannot find symbol
		
		// ○ 다운 캐스팅
		((DemoImpl)ob).write();
		//--==>> 클래스에 정의된 메소드...
		
		
		System.out.println(Demo.PI);		//-- static 이기 때문에...
		//--==>> 3.141592
		
		System.out.println(Demo.a);			//-- static 이기 때문에...
		//--==>> 10
		
		//Demo.a=30;						//-- final 이기 때문에...
		//--==>> 에러 발생(컴파일 에러)
	
	}
}/*==========================
  ■■■ 클래스 고급 ■■■
  - 인터페이스(Interface)
============================*/


// 인터페이스
interface ADemo
{
	public void write();
}

// 인터페이스
interface BDemo
{
	public void print();
}

// 클래스
//class DemoImpl
//		↓
//class DemoImpl extends ADemo, BDemo	//-- (X)
//class DemoImpl implements ADemo, BDemo
//		↓	
//추상 클래스 - 두 인터페이스(ADemo, BDemo)를 구현하는 추상 클래스
//abstract class DemoImpl implements ADemo, BDemo
//		↓
// 클래스 - 두 인터페이스(ADemo, BDemo)를 구현하는 클래스(두 인터페이스의 모든 메소드를 Overriding)
class DemoImpl implements ADemo, BDemo
{
	// JDK 1.5(5.0)에서는 인터페이스 메소드를
	// 오버라이딩(Overriding) 할때
	//『@Override』 어노테이션(annotation)을 사용할 수 없다.
	// JDK 1.6(6.0) 이후부터 적용 가능한 문법이다.
	// 단, 상속 받은 클래스의 메소드를 오버라이딩(Overriding)할 때에는
	// JDK 1.5(5.0)에서도 『@Override』어노테이션(annotation) 사용이 가능하다.
	
	@Override
	public void write()
	{
		System.out.println("ADemo 인터페이스 메소드 write()...");
	}
	
	@Override
	public void print()
	{
		System.out.println("BDemo 인터페이스 메소드 print()...");
	}
}

// main() 메소드를 포함하는 외부의 다른 클래스
public class Test122
{
	public static void main(String[] args)
	{
		//ADemo ob1 = new ADemo();		//-- 인터페이스 → 인스턴스 생성 불가
		//BDemo ob2 = new BDemo();		//-- 인터페이스 → 인스턴스 생성 불가
		
		//ADemo,BDemo 인터페이스를 구현한 추상 클래스 → 인스턴스 생성 불가
		//DemoImpl ob1 = new DemoImpl();
		
		// ADemo, BDemo 인터페이스를 구현한 클래스
		// (내부 모든 메소드 Overriding 완료 후)
		DemoImpl ob1 = new DemoImpl();
		
		ob1.write();
		//--==>> ADemo 인터페이스 메소드 write()...
		
		ob1.print();
		//--==>> BDemo 인터페이스 메소드 print()...
		
		
		//ADemo ob2 = new ADemo();
		//BDemo ob3 = new BDemo();
		
		
		// ○ 업 캐스팅
		ADemo ob2 = new DemoImpl();
		BDemo ob3 = new DemoImpl();
	
		//ob2.print();				
		//--==>> 에러 발생(컴파일 에러)
		//		 cannot find symbol
	
		//ob3.write();
		//--==>> 에러 발생(컴파일 에러)
		//		 cannot find symbol
		
		ob2.write();
		//--==>> ADemo 인터페이스 메소드 write()...
		
		ob3.print();
		//--==>> BDemo 인터페이스 메소드 print()...
		
		((BDemo)ob2).print();
		//--==>> BDemo 인터페이스 메소드 print()...
		
		((ADemo)ob3).write();
		//--==>> ADemo 인터페이스 메소드 write()...
		
		
		// ※ DemoImpl 클래스가 두 인터페이스(ADemo, BDemo)를 모두 구현했기 때문에
		//	  이와 같은 처리가 가능하다.
		//	  만약, DemoImpl 클래스가 두 인터페이스들 중 한 인터페이스만 구현했다면
		//	  이 구문은 런타임 에러가 발생하는 구문이 된다.
		
		// ○ 다운 캐스팅
		((DemoImpl)ob3).write();
		//--==>> ADemo 인터페이스 메소드 write()...
	}
}/*========================================
  ■■■ 클래스 고급 ■■■
  - 인터페이스(Interface)
=========================================*/

// 인터페이스
interface Demo
{
	public void write();
	public void print();
}


// 클래스
//class DemoImpl
//		↓
// 추상 클래스 - 인터페이스(Demo)를 구현하는 추상 클래스
abstract class DemoImpl implements Demo
{
	@Override
	public void write()
	{
		System.out.println("write() 메소드 재정의...");
	}
	
	// public void print();
}

// 클래스
//class DemoImplSub
//		↓
// 추상 클래스 - 추상 클래스(DemoImpl)을 상속받는 추상 클래스
//abstract class DemoImplSub extends DemoImpl
//		↓
// 클래스 - 추상 클래스(DemoImpl)를 상속받는 클래스
class DemoImplSub extends DemoImpl
{
	/*
	@Override
	public void write()
	{
		System.out.println("write() 메소드 재정의...");
	}
	*/
	
	@Override
	public void print()
	{
		System.out.println("print() 메소드 재정의...");
	}
	
}

// main() 메소드를 포함하는 외부의 다른 클래스
public class Test123
{
	public static void main(String[] args)
	{
		//Demo ob = new Demo();
		//-- 인스턴스 생성 불가 → 인터페이스
		
		//DemoImpl ob2 = new DemoImpl();
		//-- 인스턴스 생성 불가 → 추상 클래스
		
		DemoImplSub ob3 = new DemoImplSub();
		
		ob3.write();
		//--==>> write() 메소드 재정의...
		
		ob3.print();
		//--==>> print() 메소드 재정의...
	
	}
}/*========================================
  ■■■ 클래스 고급 ■■■
  - 인터페이스(Interface)
=========================================*/

/*
○ 『extends』 vs 『implements』

   클래스 extends 클래스
   클래스 extends 추상 클래스
   
   인터페이스 extends 인터페이스
   인터페이스 extends 인터페이스

   추상클래스 implements 인터페이스
   추상클래스 implements 인터페이스, 인터페이스
   
   클래스 implements 인터페이스
   클래스 implements 인터페이스, 인터페이스
   
   
※ 인터페이스는 클래스와 달리 다중 상속이 가능하며, 
	인터페이스 자체도 상속된다.
	
※ 인터페이스의 멤버 변수인 데이터는
	접근제어지시자를 별도로 명시하지 않더라도 기본상수(primitive constraint)인
	public static final의 변경자로 설정된다.
	클래스에서 인터페이스를 추가하여(implements)사용할 경우
	인터페이스안에서 선언된 모든 메소드를 구현해 주어야하며
	인터페이스를 구현하는 크랠스는
	인터페이스의 상위 인터페이스가 제공하는 추상 메소드를 포함한
	모든 메소드를 구현하지 않을 경우 
	추상(abstract) 클래스로 선언해야 한다.
	
※ 형식
	
	- 인터페이스는 메소드를 선언만 하고 정의는 없다.
	- 인터페이스를 implements 할 경우 반드시 하위 클래스는
	  인터페이스의 모든 메소드를 오버라이딩(Overriding)해야한다.
	- 인터페이스는 자동적으로 다음과 같이 처리된다.
	  멤버 변수 : public static final
	  메소드    : public abstract
	- 다중 상속은 콤마(『,』)로 구분되며
	  여러개의 인터페이스를 상속할 수 있다.
	- 인터페이스끼리 상속할경우 『extends』 키워드를 사용한다.
 
 ※ 인터페이스의 선언
 
	인터페이스는 클래스의 내부 구현을 제외한 참조형만 선언한 것이므로
	메소드를 선언만 하고 정의는 할 수없다.
	또한 클래스에서의 변수는 값이 변할수 있지만
	인터페이스에서의 변수는 상수처럼 값이 변할 수 없기 때문에
	선언 시에 미리 값을 할당해 놓아야 한다.
	
※ 인터페이스의 구현

	인터페이스는 클래스를 위한 템플릿이기 때문에
	사용 가능한 인터페이스가 되기 위해서는
	자바 프로그램에서 인터페이스를 구현해 주어야 하는데 
	이러한 기능을 수행하는 것이 『implements』 예약어이다.
	
※ 클래스는 동시에 두 개 이상의 인터페이스를
	implements 할 수 있다.
*/

// 인터페이스
interface ADemo
{
	public void write();
}

// 인터페이스
interface BDemo
{
	public void print();
}

// 인터페이스
//interface CDemo
//		↓
// 인터페이스 - 두 인터페이스(ADemo, BDemo)를 상속받은 인터페이스
interface CDemo extends ADemo, BDemo
{
	// public void write();
	// public void print();
	public void test();
}


// 클래스
//class DemoImpl
//		↓
// 추상 클래스 - 두 인터페이스(ADemo, BDemo)를 상속받은 인터페이스(CDemo)를 구현한 클래스
// abstract class DemoImpl implements CDemo
//
// 클래스 - 두 인터페이스(ADemo, BDemo)를 상속받은 인터페이스(CDemo)를 구현한 후
//			상속받은 모든 메소드를 재정의한 클래스
class DemoImpl implements CDemo		
{
	// public void test();
	
	@Override
	public void test()
	{
		System.out.println("test()...");
	}
	
	// public void write();
	// public void print();
	
	@Override
	public void write()
	{
		System.out.println("write()...");
	}
	
	@Override
	public void print()
	{
		System.out.println("print()...");
	}
}



// main() 메소드를 포함하는 외부의 다른 클래스
public class Test124
{
	public static void main(String[] args)
	{
		// 두 인터페이스를 상속받은 인터페이스를 구현하고
		// 해당 인터페이스의 메소드 뿐 아니라
		// 상속받은 인터페이스의 모든 메소드를 재정의한
		// 클래스 기반 인스턴스 생성
		DemoImpl ob = new DemoImpl();
		
		ob.test();
		ob.write();
		ob.print();
		
		
	}
}

// 실행 결과

/*
test()...
write()...
print()...
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 클래스 고급 ■■■
  - 인터페이스(Interface)
=========================================*/

// 성적 처리 프로그램을 구현한다.
// 단, 인터페이스를 활용할 수 있도록 한다.

// 실행 예)
// 인원 수 입력(1~10) : 11
// 인원 수 입력(1~10) : 0
// 인원 수 입력(1~10) : 2

// 1번째 학생의 학번 이름 입력(공백 구분) : 2410123 곽유진
// 국어 영어 수학 점수 입력   (공백 구분) : 90 100 85
// 1번째 학생의 학번 이름 입력(공백 구분) : 2410225 정승민
// 국어 영어 수학 점수 입력	  (공백 구분) : 95 80 95

// 2410123 곽유진	90 100 85		xxx		xx.xx
//					수  수 우
// 2410225 정승민	95  80 95		xxx		xx.xx
//					수  우 수
// 계속하려면 아무 키나 누르세요...

// 90 ~ 100 : 수
// 80 ~ 89  : 우
// 70 ~ 79  : 미
// 60 ~ 69  : 양
// 나머지   : 가




import java.util.Scanner;

// 속성만 존재하는 클래스 → 자료형 활용
class Record
{
	private String hak, name;			//-- 학번, 이름
	//int kor, eng, mat;				//-- 국어, 영어, 수학 점수
	private int[] score = new int[3];	
	private int tot;					//-- 총점
	private double avg;					//-- 평균

	public String getHak()
	{
		//return hak;
		return this.hak;
	}
	
	public void setHak(String hak)
	{
		this.hak = hak;
	}
	
	public String getName()
	{
		return this.name;
	}
	
	public void setName(String name)
	{
		this.name = name;
	}
	
	public int[] getScore()
	{
		return this.score;
	}
	
	public void setScore(int[] score)
	{
		this.score = score;
	}
	
	public int getTot()
	{
		return this.tot;
	}
	
	public void setTot(int tot)
	{
		this.tot = tot;
	}
	
	public double getAvg()
	{
		return this.avg;
	}
	
	public void setAvg(double avg)
	{
		this.avg = avg;
	}

}

// 인터페이스 → 가이드라인 활용
interface Sungjuk
{
	public void set();			//-- 인원 세팅
	public void input();		//-- 데이터 입력
	public void print();		//-- 데이터 출력
}


// 문제 해결 과정에서 설계해야 할 클래스 → Sungjuk 인터페이스를 구현하는 클래스
//class SungjukImpl
//abstract class SungjukImpl implements Sungjuk	
class SungjukImpl implements Sungjuk
{
	// 주요 속성 구성
	private int inwon;			//-- 인원 수(사용자가 입력하게 될 값)
	private Record[] rec;
	//-- Record 클래스를 기반으로 생성되는 개체를
	//	 담을 수 있는 배열의 이름을 rec 라고 하겠다.
	
	@Override
	public void set()
	{
		Scanner sc = new Scanner(System.in);
		
		do
		{
			System.out.print("인원 수 입력(1~10) : ");
			inwon = sc.nextInt();
		}
		while (inwon<1 || inwon>10);
		
		// 인원 수 만큼의 배열방 구성
		rec = new Record[inwon];
		
		
	}
	
	@Override
	public void input()
	{
		Scanner sc = new Scanner(System.in);
		
		for (int i = 0; i<inwon; i++)
		{
			// 학생 객체(인스턴스 생성) → Record 객체
			rec[i] = new Record();
			
			System.out.println();	// 개행
			
			System.out.printf("%d번째 학생의 학번 이름 입력(공백 구분) : ", (i+1));
			// 241023 윤영식
			
			//rec[i].hak = sc.next();
			rec[i].setHak(sc.next());
			//rec[i].name = sc.next();
			rec[i].setName(sc.next());
			
			System.out.print("국어 영어 수학 점수 입력   (공백 구분) : ");
			// 90 80 70
			
			int[] temp = new int[rec[i].getScore().length];
			int total = 0;
			
			
			//for (int j=0; j<3; j++)
			//for (int j=0; j<rec[i].score.length; j++)
			for (int j=0; j<temp.length; j++)
			{
				//rec[i].score[j] = sc.nextInt();
				temp[j] = sc.nextInt();
				total += temp[j];	
			}
			
			rec[i].setScore(temp);
			rec[i].setTot(total);
			//rec[i].setAvg(total/3.0);
			rec[i].setAvg(total/(double)temp.length);
			
		}	
	}
	
	
	@Override
	public void print()
	{
		System.out.println();	
		for (int i=0; i<inwon; i++)		// 학생 수 만큼 반복~!!!
		{
			// 학생 한 명 분 출력
			System.out.printf("%8s %5s",rec[i].getHak(),rec[i].getName());
			
			for (int scoreTemp : rec[i].getScore())
				System.out.printf("%6d",scoreTemp);
			
			System.out.printf("%7d",rec[i].getTot());
			System.out.printf("%8.2f\n\t\t",rec[i].getAvg());
			
			for (int scoreTemp : rec[i].getScore())
				System.out.printf("%5s",panjung(scoreTemp));
			System.out.println();
		}
	}
	
	// 내부적으로 등급에 대한 판정을 수행할 메소드
	private String panjung(int score)
	{
		String result = "가";
		
		if (score>=90)
			result = "수";
		else if (score>=80)
			result = "우";
		else if (score>=70)
			result = "미";
		else if (score>=60)
			result = "양";
	
		return result;
	}
	
	
	
	/* 나의 풀이
	Scanner sc = new Scanner(System.in);
	
	private int inwon;
	private Record[] rec;
	
	@Override
	public void set()
	{
		do
		{
			System.out.print("인원 수 입력(1~10) : ");
			inwon = sc.nextInt();
		}
		while (inwon<1 || inwon>10);
		
		rec = new Record[inwon];
	}
	
	
	@Override
	public void input()
	{
		for (int i=0; i<inwon; i++)
		{
			rec[i] = new Record();
			
			System.out.printf("%d번째 학생의 학번 이름 입력 (공백 구분) : ",(i+1));
			rec[i].hak = sc.next();
			rec[i].name = sc.next();
			System.out.print("국어 영어 수학 점수 입력    (공백 구분) : ");
			
			for (int j=0; j<3; j++)
			{
				
				rec[i].score[j] = sc.nextInt();
				
				rec[i].tot += rec[i].score[j];
				rec[i].avg = (double)rec[i].tot / 3;
			}	
		}		
	}
	
	
	// 내부적으로 등급에 대한 판정을 수행할 메소드
	
	private String panjung(int score)
	{
		String grade = "수";
		
		for (int i=0; i<inwon; i++)
		{
			for (int j =0; j<3; j++)
			{
				if (score>=90 && score<=100)
				{
					grade = "수";
				}
				else if (score>=80 && score<90)
				{
					grade = "우";
				}
				else if (score>=70 && score<80)
				{
					grade = "미";
				}
				else if (score>=60 && score<70)
				{
					grade = "양";
				}
				else
					grade = "가";
			}
			
			
		}
		return grade;
	}
	

	
	@Override
	public void print()
	{
		

		for (int i =0; i<inwon; i++)
		{
			System.out.printf("%s %s",rec[i].hak,rec[i].name);
			for (int j=0; j<3; j++)
			{
				System.out.printf("%3d",rec[i].score[j]);
			
			}
			System.out.printf("%5d %.2f\n",rec[i].tot,rec[i].avg);
			System.out.printf("\t  %s %s %s\n",panjung(rec[i].score[0]),panjung(rec[i].score[1]),panjung(rec[i].score[2]));
			
		}
		
		
	}
	*/
	
}

// main() 메소드를 포함하는 외부의 다른 클래스
public class test125
{
	public static void main(String[] args)
	{
		//check!!!
		//Sungjuk은 인터페이스
		Sungjuk ob;
		
		// 문제 해결 과정에서 작성해야 할 ob 구성 및 객체 생성
		// ob = new Sungjuk();
		ob = new SungjukImpl();
		
		ob.set();
		ob.input();
		ob.print();
	}
}

// 실행 결과

/*
인원 수 입력(1~10) : 3

1번째 학생의 학번 이름 입력(공백 구분) : 2410123 곽유진
국어 영어 수학 점수 입력   (공백 구분) : 90 80 70

2번째 학생의 학번 이름 입력(공백 구분) : 2410225 정승민
국어 영어 수학 점수 입력   (공백 구분) : 95 85 75

3번째 학생의 학번 이름 입력(공백 구분) : 2410284 김믿음

국어 영어 수학 점수 입력   (공백 구분) : 100 30 60

 2410123   곽유진    90    80    70    240   80.00
                    수    우    미
 2410225   정승민    95    85    75    255   85.00
                    수    우    미
 2410284   김믿음   100    30    60    190   63.33
                    수    가    양
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 클래스 고급 ■■■
  - 중첩 클래스
=========================================*/

/*
○ 중첩 클래스

	중첩 클래스란 클래스 안에 다른 클래스가 설계되어 있는 형태로
	클래스 내부에서만 사용할 보조 클래스가 필요한 경우
	클래스를 중첩하여 프로그램의 구조를 보다 더 간다하고 알아보기 쉽도록
	만들 수 있는데, 이러한 클래스를 중첩 클래스라 한다.
	이는, 특정 클래스를 자신의 클래스 내부적인 용도로만 사용할 목적으로 쓰이는데
	특정 클래스를 마치 자신의 멤버 변수나 메소드 처럼 사용할 수 있게 한다.
	
○ 중첩 클래스의 종류(4가지)

	1. static 중첩 클래스(중첩 내부 클래스)
		→ 클래스 내부에... 『public static class 클래스명』
		
		중첩 클래스를 감싸는 외부 클래스의 『{}』안에
		static을 붙인 새로운 클래스를 설계하는 것으로
		모든 접근 제어 지시자를 사용할 수 있다.
		static 중첩 클래스가 포함하고 있는 메소드에서는 
		외부 클래스의 인스턴스 변수나 인스턴스 메소드에는 접근할 수 없고
		(외부 클래스의 객체를 생성하지 않은 상태)
		클래스 변수와 클래스 메소드만 접근할 수 있다.
		
		- 프로그램의 구조를 더 간단하고 알아보기 쉽게 구성할 수 있다.
		- static 으로 선언된 내부 클래스이다.
		- 중첩 클래스의 객체는 중첩 클래스를 포함하고 있는
		  외부 클래스의 객체와 동등하다.
		- 외부 클래스의 클래스 변수와 클래스 메소드는
		  바로 접근하여 사용하는 것이 가능하다.
		- 중첩 클래스와 중첩 클래스를 포함하고 있는 외부 클래스의
		  인스턴스 변수와 인스턴스 메소드는
		  객체를 생성하여 서로 접근하는 것이 가능하다.
		- 중첩 클래스를 외부에서 단독으로 사용하는 것이 가능하다.
		
	2. 내부 클래스 (inner class)
		→ 클래스 내부에... 『public class 클래스명』
		
		- static 중첩 클래스와 마찬가지로 프로그램의 구조를 보다 더 간단하고
		  알아보기 쉽도록 한 것이다.
		- 외부 클래스의 메소드에서 내부 멤버 킄래스를 사용하기 위해서는
		  반드시 내부 멤버 클래스 객체를 생성해 주어야 한다.
		- 외부 클래스의 멤버 변수와 메소드를
		  객체 생성 없이 바로 사용하는 것이 가능하다.
		- 내부 멤버 클래스는 외부에서 단독으로 객체를 생성하여 사용할 수 없다.
		  즉, 내부 멤버 클래스는 외부 클래스의 인스턴스 생성이
		  선행되어야 한다는 것이다.
		- static 으로 선언한 변수 또는 메소드를 가질 수 없다.
		
	3. 지역 클래스(로컬 클래스, local class)
		→ 메소드 내부에... 『class 클래스명』
						  또는 『static class 클래스명』
		
		- 클래스의 메소드 안에서 클래스를 정의하는 것으로
		  내부 멤버 클래스와 유사한 성격을 가지고 있긴 하지만
		  접근제어지시자는 붙일 수 없다.
		
	4. 무명 클래스(익명 클래스, anonymous class)
		→ 이름 없는 클래스
		
		- 클래스또는 인터페이스에 대한 객체를 생성하면서
		  바로 클래스 또는 인터페이스를 정의하는 클래스.
		- 정의하는 부분과 생성하는 부분이 하나로 묶여져
		  new 수식이 있는 곳에서 바로 클래스 또는 인터페이스를
		  정의하는 것을 의미한다.
*/

// outer 클래스
class Test
{
	static int a = 10;								// static 
	int b = 20;
	
	// inner 클래스
	public static class StaticNested				// static
	{
		int c = 30;
		
		void write()
		{
			System.out.println("write()...");
			System.out.println("a : " + a);
			//System.out.println("b : " + b);
			//--==>> 에러 발생(컴파일 에러)
			//		 non-static variable b cannot be referenced from a static context
			
			System.out.println("c : " + c);
		}
	}
	
	void print()
	{
		// StaticNested(inner 클래스) 인스턴스 생성
		StaticNested sn = new StaticNested();
		sn.write();
	}
}



// main() 클래스를 포함하는 외부의 다른 클래스
public class Test126
{
	public static void main(String[] args)
	{
		// 외부에서... Test 기반 인스턴스 생성
		Test ob1 = new Test();
		ob1.print();
		//--==>> write()...
		//		 a : 10
		//		 c : 30
		
		// 외부에서... StaticNested 기반 인스턴스 생성
		//StaticNested ob2 = new StaticNested();
		//--==>> 에러 발생(컴파일 에러)
		//		  cannot find symbol
		
		
		// ※ 중첩 내부 클래스는 외부에서 단독으로 객체를 생성할 수 있다.
		//	  단, 위와 같은 방법으로는 객체를 생성할 수 없고
		//	  클래스 변수 접근이나 클래스 메소드 호출하는 것과 같은 방식을 통해
		//	  접근하여 인스턴스를 생성할 수 있도록 처리해야 한다.
	
		// Test.a
	
		Test.StaticNested ob2 = new Test.StaticNested();
		
		ob2.write();
		//--==>> write()...
		//		 a : 10
		//		 c : 30
		
	}
}/*========================================
  ■■■ 클래스 고급 ■■■
  - 중첩 클래스
=========================================*/

// outer 클래스
class Test2
{
	static int a = 10;
	int b =20;
	
	void write()			//-- 첫 번째 write() 메소드
	{
		System.out.println("첫 번째 write()...");
		final int c = 30;
		int d= 40;
		
		d++;
		
		// inner 클래스
		// 메소드 안에 존재하는 또다른 클래스(로컬 클래스, local class, 지역 클래스)
		class LocalTest
		{
			void write()	//-- 두 번째 write() 메소드
			{
				System.out.println("두 번째 write()...");
				System.out.println("a : " + a);
				System.out.println("b : " + b);
				System.out.println("c : " + c);
				//System.out.println("d : " + d);	
				//--==>> 에러 발생(컴파일 에러)
				//		 local variables referenced from an inner class must be final or effectively final
			
			}
		}
		
		d++;
		
		// LocalTest(inner) 인스턴스 생성
		LocalTest lt = new LocalTest();
		lt.write();			//-- 두 번째 write() 메소드 호출
		
		d++;
	}
	
}


public class Test127
{
	public static void main(String[] args)
	{
		// Test2(outer) 인스턴스 생성
		Test2 ob = new Test2();
		ob.write();				//-- 첫 번째 write() 메소드 호출
	}
}

// 실행 결과

/*
첫 번째 write()...
두 번째 write()...
a : 10
b : 20
c : 30
계속하려면 아무 키나 누르십시오 . . .
*//*========================================
  ■■■ 클래스 고급 ■■■
  - 중첩 클래스
=========================================*/

// outer 클래스
class InnerOuterTest
{
	static int a= 10;
	int b=20;
	
	// inner 클래스
	class InnerNested
	{
		int c = 30;
		
		void write()			//-- inner의 write() 메소드
		{
			System.out.println("inner의 write()...");
			System.out.println("a : " + a);
			System.out.println("b : " + b);
			System.out.println("c : " + c);
		}
	}
		
	void write()			//-- outer의 write() 메소드
	{
		System.out.println("outer의 write()...");
		
		InnerNested ob1 = new InnerNested();
		ob1.write();		//-- inner의 write() 메소드 호출
	}
	
}

// main() 메소드를 포함하는 외부의 다른 클래스
public class Test128
{
	public static void main(String[] args)
	{
		//InnerOuterTest(outer) 인스턴스 생성
		InnerOuterTest ob2 = new InnerOuterTest();
		ob2.write();		// outer의 write() 메소드 호출
		//--==>> outer의 write()...
		//		 inner의 write()...
		//		 a : 10
		//		 b : 20
		//		 c : 30
	
	
		// InnerNested(inner) 인스턴스 생성
		//InnerNested ob3 = new InnerNested();
		//--==>> 에러 발생 (컴파일 에러)
		//		 cannot find symbol
		
		// check!! → Test126 과 비교!!
		//InnerOuterTest.InnerNested ob4 = new InnerOuterTest.InnerNested();
		//--==>> InnerOuterTest(outer)를 통해 InnerNested(inner) 인스턴스 생성
		//--==>> 에러 발생(컴파일 에러)
		//		 an enclosing instance that contains InnerOuterTest.InnerNested is required
		
		
		// ※ 중첩 내부 클래스(static 중첩 클래스)와는 달리
		//	  외부 클래스의 인스턴스(객체)를 사용하지 않고
		//	  단독으로 내부 클래스의 인스턴스를 생성하는 것은 불가능하다.
		
		// check!! → Test126 과 비교!!
		InnerOuterTest.InnerNested ob5 = ob2.new InnerNested();
		ob5.write();
		//--==>> inner의 write()...
		//		 a : 10
		//		 b : 20
		//		 c : 30
		
		// outer클래스명.inner클래스명 참조변수명 = outer객체.new inner생성자();
		
		// outer클래스명.inner클래스명 참조변수명 = new outer생성자().new inner생성자();
		
		// cf) static 중첩 클래스
		// outer클래스명.inner클래스명 참조변수명 = new outer클래스명.inner생성자();
		
		
		InnerOuterTest.InnerNested ob6 = new InnerOuterTest().new InnerNested();
		ob6.write();
		//--==>> inner의 write()...
		//		 a : 10
		//		 b : 20
		//		 c : 30
		
		
		
		
		
		
		
	}
}/*==========================
  ■■■ 클래스 고급 ■■■
  - 중첩 클래스
============================*/

/*
○ Annonymous 클래스(익명 클래스, 무명 클래스, 이름없는 클래스)

	- AWT, Swing 나 안드로이드 이벤트 처리에서 일반적으로 사용
	- 상위 클래스메소드를 하나 정도 재정의할 필요성이 있을때 사용
	- 클래스의 객체가 필요하면 또 다시 클래스를 생성해야 하는
	  번거로움으로 인해 빈번하게 객체 생성이 필요한 경우
	  익명의 클래스를 활용하여 처리할 수 있다.
	
○ 형식 및 구조

	new 상위 클래스의 생성자()
	{
		접근제어지시자 자료형 메소드()
		{
			...;
		}
	};		// check~!!! 세미콜론

*/

// import java.lang.Object;	- lang 패키지 안에 있는 것은 import 필요 X


class Test3	// extends Object
{
	/*
	Object 의 모든 멤버 상속~!!!
	
	toString()
	{
		...;
	}
	
	*/
	
	
	
	public Object getString()
	{
		return new Object()
		{
			// 특정 메소드 재구성 → 재정의
			@Override
			public String toString()
			{
				return "익명의 클래스...";
			}
		};		//-- 세미콜론 (미 작성 시 에러 발생)
	}
	
}

public class Test129 // extends Object
{
	public static void main(String[] args)
	{
		Test3 ob = new Test3();
		
		// System.out.println(ob.abcd());
		
		System.out.println(ob.toString());
		//--==>> Test3@6d06d69c				// 클래스명@해시코드
		
		System.out.println(ob.getString());
		//--==>> 익명의 클래스...
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - 자바에서 기본적으로 제공하는 주요 클래스들
==============================================*/

/*
○ 개요

	일반적으로 클래스는 하나만 존재하는 것이 아니라
	같은 종류의 클래스를 여러 개 묶어서 사용하게 되는데
	이러한 클래스나 인터페이스의 묶음을 패키지(package)라고 한다.
	sun(Oracle)사에서는 자바 프로그램을
	효율적으로 작성할 수 있도록 자바 표준 패키지를 제공하며
	자바 표준 패키지에는 그래픽, 네트워크, 데이터베이스 등의
	다양하고 유용한 클래스들이 포함되어 있다.
	
○ import 구문

	자바 표준 패키지나 사용자에 의해 외부에서 만들어진 패키지를
	사용하기 위해서는 컴파일을 수행하기에 앞서 프로그램에 포함시키는
	과정이 필요한데 이 때 『import』문을 이용하여 패키지 또는
	클래스를 프로그램에 포함시키게 된다.
	하지만, 『java.lang』패키지는 자바 프로그램에 기본적으로
	import 되어 있기 때문에 이 패키지의 클래스들은 import 하지 않고 
	바로 사용하는 것이 가능하다.
	
	import문은 반드시 클래스 설계 구문 전에 선언되어 있어여 하며
	형식은 다음과 같은 두가지가 있다.

	import [static] 패키지.클래스;
	import [static] 패키지.*;
	
	※ JDK 1.5 부터는 import 다음에 static 키워드를 사용할 수 있게 하였고
	   정적으로 패키지를 import할 수 있는 기능을 제공하게 되었다.
	   만약 패키지를 정적으로 import한 경우라면 모든 접근 가능한
	   메소드와 멤버 변수들은 접두사(ex → br, ob, sc)를 붙이지 않고 사용하는 것이 가능하다.
	
○ Object 클래스
	
	『java.lang.Object』클래스는 자바 최상위 클래스로
	자바 표준 패키지의 클래스나 사용자에 의해 작성된 모~~~~든 클래스는 
	기본적으로 이 클래스로부터 상속받는다.
	따라서, 자바의 모든 클래스는 『java.lang.Object』클래스의
	메소드를 가지고 있으며, 바로 사용하는 것이 가능하다.
*/

// package default;

// import java.lang.*;

// (import java.lang.Object;)


public class Test130  // extends Object
{
	/*
	Object 클래스로부터 상속받은 멤버들
	...
	
	
	String toString()
	{
		...;
	}
	*/
	
	/*
	public Test130()
	{
		super();
	}
	*/
	
	
	public static void main(String[] args)
	{
		Test130 ob = new Test130();
		
		//객체.xxx();
		//-- 해당 객체를 생성시키는 대상 클래스(→ Test130)의 메소드 xxx()호출
		
		//ex)
		// Rect ob = new Rect();
		// ob.input();
		//-- ob 객체를 생성시키는 대상 클래스 → Rect
		// Rect 클래스에 정의되어 있는 input() 메소드 호출
		
		// 객체.yyy();
		//-- 해당 객체를 생성시키는 대상 클래스에 yyy(); 메소드가 존재하지 않을 때...
		//--==>> 에러 발생(컴파일 에러)
		
		// System.out.println(ob.actionTest());
		//--==>> 에러 발생(컴파일 에러)
		//		 cannot find symbol
		//-- 해당 객체 (ob)를 생성시키는 대상 클래스(Test130)에
		//	 actionTest()라는 메소드가 존재하지 않기 때문에(정의되어 있지 않기 때문에)
		//	 에러가 발생하게 되는 상황
		
		System.out.println(ob.toString());
		//--==>> Test130@6d06d69c
		//-- 메모리 주소가 아니라
		//	 자바가 내부적으로 객체를 구분하기 위해 임의로 부여하는 식별번호
		//-- Test130 클래스에 toString() 메소드가
		//	 존재하지 않음에도 불구하고(정의되어 있지 않은 상황임에도 불구하고)
		//	 에러 발생하지 않는 상황
		//	 → Object로 부터 상속받음~!!
		
		System.out.println(ob);
		//--==>> Test130@6d06d69c
		
		//System.out.println(10);
		//System.out.println(2.12);
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Object 클래스
==============================================*/

// Test130.java 와 비교

// import java.lang.*;
// (import java.lang.Object;)

public class Test131	// extends Object
{
	/*
	...;
	...;
	
	public String toString()
	{
		...;
	}
	*/
	
	@Override
	public String toString()
	{
		return "재정의한 toString()...";
	}
	
	public static void main(String[] args)
	{
		Test131 ob = new Test131();
		
		// @Override를 사용할 수 있는 이유가 이미 해당 클래스가 Object클래스를 상속받았기 때문
		System.out.println(ob.toString());
		//--==>> 재정의한 toString()...
		
		// 재정의한 메소드로 덮어쓰기 되었기 때문에
		System.out.println(ob);
		//--==>> 재정의한 toString()...
		
		
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Object 클래스
==============================================*/

class Test
{
	private int a = 10;
	
	public void write()
	{
		System.out.println("a : " + a);
	}
	
}

public class Test132
{
	public static void main(String[] args)
	{
		Test ob1 = new Test();
		Test ob2 = new Test();
		
		System.out.println("10 == 9 : " + (10 == 9));
		//--==>> 10 == 9 : false
		
		int a = 10;
		int b = 10;
		System.out.println("a == b : " + (a == b));
		//--==>> a == b : true
		
		// ※ 『==』 비교 연산자는 피연산자의 크기를 비교하는 것을 확인(관찰)할 수 있다.
		
		System.out.println("ob1 == ob2 : " + (ob1 == ob2));
		//--==>> ob1 == ob2 : false
		
		// ※ 객체(Object)들을 비교하는 과정에서 사용되는 『==』 비교 연산자는
		//	  대상 객체들의 크기를 비교하는 것이 아니라 주소를 비교한다.
		
		System.out.println();
		System.out.println("--------------------------------------------------------");
		System.out.println();
		
		System.out.println("ob1            : " + ob1);
		System.out.println("ob1.toString() : " + ob1.toString());
		//--==>> ob1            : Test@6d06d69c
		//		 ob1.toString() : Test@6d06d69c
		
		System.out.println("ob2            : " + ob2);
		System.out.println("ob2.toString() : " + ob2.toString());
		//--==>> ob2            : Test@7852e922
		//		 ob2.toString() : Test@7852e922
		
		// 『클래스명@해시코드(hashcode)』
		//			  -------------------
		//			  자바 내부적으로 객체를 구분하기 위해 사용하는 것.
		//			  메모리의 주소값으로 생각하면 절대로 안된다.
		
		// ※ 객체가 같으면 hashCode(해시코드)가 같지만
		//	  hashCode(해시코드)가 같다고 같은 객체는 아니다~!!!
		
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Object 클래스
==============================================*/

class NewCar  // extends Object
{
	/*
	...;
	...;
	*/
	
	private int velocity;	//-- 자동차의 속도
	private int wheelNum;	//-- 자동차의 바퀴 갯수
	private String carName; //-- 자동차의 이름
	
	// 생성자(사용자 정의 생성자)
	NewCar(int speed, String name, int wheel)
	{
		velocity = speed;
		carName = name;
		wheelNum = wheel;
	}
}


public class Test133
{
	public static void main(String[] args)
	{
		NewCar nCar0 = new NewCar(320, "제네시스", 4);
		NewCar nCar1 = new NewCar(320, "제네시스", 4);
		NewCar nCar2 = new NewCar(280, "그랜져", 4);
		
		// equals()
		System.out.println("1-0 : " + nCar0.equals(nCar1));
		System.out.println("1-1 : " + nCar1.equals(nCar2));	 // 업 캐스팅이 발생
		System.out.println("1-2 : " + (nCar1 == nCar2));
		//--==>> 1-0 : false
		//		 1-1 : false
		//       1-2 : false
		
		NewCar nCar3 = nCar1;	//-- 객체 복사 → 얕은 복사(참조형)
								//			   → 주소값 복사
								
		System.out.println("2-1 : " + nCar1.equals(nCar3));
		System.out.println("2-2 : " + (nCar1 == nCar3));
		//--==>> 2-1 : true
		//		 2-2 : true
		
		// toString()
		System.out.println("3-1 : " + nCar1.toString());
		System.out.println("3-2 : " + nCar2.toString());
		System.out.println("3-3 : " + nCar3.toString());
		//--==>> 3-1 : NewCar@6d06d69c
		//		 3-2 : NewCar@7852e922
		//		 3-3 : NewCar@6d06d69c
		
		// hashCode()
		System.out.println("4-1 : " + nCar1.hashCode());
		System.out.println("4-2 : " + nCar2.hashCode());
		System.out.println("4-3 : " + nCar3.hashCode());
		//--==>> 4-1 : 1829164700
		//		 4-2 : 2018699554
		//		 4-3 : 1829164700
		//-- 결과값을 16진수 형태로 변환하게 되면
		//	『toString()』 메소드가 반환한 결과값 확인 가능.
		
		// getClass()
		System.out.println("5-1 : " + nCar1.getClass());
		System.out.println("5-2 : " + nCar2.getClass());
		System.out.println("5-3 : " + nCar3.getClass());
		//--==>> 5-1 : class NewCar
		//		 5-2 : class NewCar
		//		 5-3 : class NewCar
		//-- 생성된 객체를 통해(활용하여)
		//	 해당 객체의 기반 설계도(클래스)를 확인할 수 있는 기능을 가진 메소드.
		
		
		// clone()		//-- 객체 복사
		
		// finalize()	//-- 객체 직렬화
		
		// 기타 나머지 메소드는 스레드 처리와 관련이 있다.
		
		
	
	
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Object 클래스
==============================================*/

/*
○ Wrapper 클래스

	1. 자바에서는 언어 수준에서 제공하는 기본형 데이터를 제외한
	   나머지는 클래스로 설계하여 객체 단위로 처리한다.
	   따라서 자바게서는 이러한 기본형 데이터를
	   객체 단위로 처리할 수 있도록 클래스를 제공할 수 밖에 없는데
	   이러한 클래스들을 가리켜 Wrapper 클래스라 한다.
	
	2. 기본 자료형
	   byte, short, int,     long, float, double, char,      boolean 형에 대응하는
	     |     |     |         |     |      |       |		    |
	   Byte, Short, Integer, Long, Float, Double, Character, Boolean 의
	   Wrapper 클래스 및 큰 숫자들을 다루기 위한
	   java.math.BigInteger 와 java.math.BigDecimal 클래스들을 제공한다.
	
	   Wrapper 클래스는 java.lang 패키지에 포함되어 있으므로
	   별도의 import 과정 없이 바로 사용하는 것이 간으하며
	   기본형과 마찬가지로 Wrapper 클래스도 내부 메소드를 통해
	   형 변환이 가능하고, 동등 비교와 같은 연산도 가능하다.
	
	   ex) java.lang.Integer 클래스
	       int 기본 자료형의 Wrapper 클래스로
	       정수를 다루는데 필요한 상수나 메소드, 진수 변환 등에 필요한
	       메소드 등을 포함하고 있다.
	
	       static int parseInt(String s)
	       문자열 형식으로 저장된 숫자를 정수 형태로 변환하여 반환한다
	
		   static Integer valueOf(int i)
		   int 형을 Integer형으로 변환한다.
	
		   byte byteValue(), int intValue(),
		   short shortValue(), long longValue(),
		   float floatValue(), double doubleValue()
		   해당 기본 자료형으로 형 변환한 값을 반환한다.
*/


/*
※ 오토 박싱(Auto-Boxing) 오토 언박싱(Auto-Unboxing)

	일반적으로 레퍼런스 형과 기본 자료형은 호환되지 않으며
	이 경우 발생하는 문제를 해결하기 위해 자바는 Wrapper 클래스를 제공하게 되었다.
	하지만 JDK 1.5부터 레퍼런스 형과 기본 자료형이
	다음과 같은 형 변환이 가능하도록 지원하게 되었다.

	int a=10, b;
	Integer ob;
	ob = a;
	//-- 기본 자료형(int)이 Integer 형으로 자동 변환(오토 박싱)
	//-- 실제로는... 『ob = new Integer(a);』
	
	b = ob;
	//-- Integer(객체)가 기본 자료형(int)으로 자동 변환(오토 언박싱)
	//	 실제로는... 『b = ob.intValue();』
	
	이는 JDK 1.5이후 추가된 오토 박싱 / 오토 언박싱 이라는
	기능으로 인해 가능해진 것이다.
*/

public class Test134
{
	public static void main(String[] args)
	{
		int a=10, b;
		Integer c;
		Object d;
		
		b = a;					//-- int형 데이터(자료) → int형 변수
		
		c = new Integer(0);		//-- 객체 생성 
		
		// ※ 레퍼런스 형(참조 타입), 기본 자료형(기본 타입)은 호환되지 않는다.
		
		b = c;					//-- Integer형 데이터(객체) → int형 변수(오토 언박싱)
		b = c.intValue();		//-- 객체의 메소드를 활용하여(메소드를 호출하여) 결과값 반환(언박싱)
		
		d = new Object();		//-- 객체 생성
		
		System.out.println("d.toString() : " + d.toString());
		//--==>> d.toString() : java.lang.Object@6d06d69c
		
		d = new Integer(10);	//-- 업 캐스팅
		System.out.println("d.toString() : " + d.toString());
		//--==>> d.toString() : 10
		
		d = new Double(12.345); //-- 업 캐스팅
		System.out.println("d.toString() : " + d.toString());
		//--==>> d.toString() : 12.345
		
		d = 10;					//-- 오토 박싱
		System.out.println("d.toString() : " + d.toString());
		//--==>> d.toString() : 10
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Wrapper 클래스
==============================================*/

public class Test135
{
	public static void main(String[] args)
	{
		boolean bi = true;
		Boolean wrapBi = new Boolean(bi);
		Boolean wBi = bi;					//-- 오토 박싱
		
		int n = 300;
		Integer wrapN = new Integer(n);
		int n2 = wrapN;						//-- 오토 언박싱
		
		float f = 300.3f;
		Float wrapF = new Float(f);
		
		System.out.println(wrapBi.toString());
		System.out.println(wrapN.toString());
		System.out.println(wrapF.toString());
		//--==>> true
		//		 300
		//		 300.3
		
		System.out.println(wrapBi);
		System.out.println(wrapN);
		System.out.println(wrapF);
		//--==>> true
		//		 300
		//		 300.3
		
		// Integer 클래스
		
		String sn = "12";
		int ni = Integer.parseInt(sn);
		System.out.printf("ni : %3d\n",ni);
		//--==>> ni :  12
		
		ni = Integer.parseInt("0101", 2);
		System.out.printf("ni : %3d\n",ni);
		//--==>> ni :   5
		
		ni = Integer.parseInt("12", 8);
		System.out.printf("ni : %3d\n",ni);
		//--==>> ni :  10
		
		ni = Integer.parseInt("A", 16);
		System.out.printf("ni : %3d\n",ni);
		//--==>> ni :  10
															// toXxxxx() 메소드는 대부분 변환과 관련된 것
		sn = Integer.toBinaryString(20);
		System.out.printf("sn : %s\n",sn);
		//--==>> sn : 10100
		 
		sn = Integer.toOctalString(31);
		System.out.printf("sn : %s\n",sn);
		//--==>> sn : 37
		 
		sn = Integer.toHexString(31);
		System.out.printf("sn : %s\n",sn);
		//--==>> sn : 1f
		 
		Integer num = new Integer(50);
		System.out.println("num.toString() : " + num.toString());
		//--==>> num.toString() : 50
		 
		System.out.println("num : " + num);
		//--==>> num : 50
		 
		int n3 = 345;
		Integer n4 = Integer.valueOf(n3);
		System.out.println("n4 : " + n4);
		//--==>> n4 : 345
		 
			 
		 
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - BigInteger 클래스
==============================================*/

import java.math.BigInteger;

public class Test136
{
	public static void main(String[] args)
	{
		// 불가능
		//int a1 = 123456789123456789;
		//System.out.println(a1);
		
		// 불가능
		//long b1 = 123456789123456789;
		//System.out.println(b1);
		
		// 가능
		long c1 = 123456789123456789L;
		System.out.println(c1);
		//--==>> 123456789123456789
		
		// 불가능
		//long d1 = 123456789123456789123456789L;
		//System.out.println(d1);
	
		
		BigInteger a = new BigInteger("123456789123456789");
		BigInteger b = new BigInteger("123456789123456789");
		
		//BigInteger c = a + b;
		//System.out.println(c);
		
		// 더하기
		BigInteger c = a.add(b);
		System.out.println("덧셈 결과 : " + c);
		//--==>> 덧셈 결과 : 246913578246913578
		
		// 빼기
		BigInteger d = a.subtract(b);
		System.out.println("뺄셈 결과 : " + d);
		//--==>> 뺄셈 결과 : 0
		
		// 곱하기
		BigInteger e = a.multiply(b);
		System.out.println("곱셈 결과 : " + e);
		//--==>> 곱셈 결과 : 15241578780673678515622620750190521
		
		// 나누기
		BigInteger f = a.divide(b);
		System.out.println("나눗셈 결과 : " + f);
		//--==>> 나눗셈 결과 : 1
		
		// 지수승
		BigInteger g = new BigInteger("2");
		System.out.println("2의 3승 : " + g.pow(3));
		//--==>> 2의 3승 : 8
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - BigDecimal 클래스
==============================================*/

import java.math.BigDecimal;

public class Test137
{
	public static void main(String[] args)
	{
		BigDecimal a = new BigDecimal("123456789.123456789");
		
		// movePointLeft() : 소수점을 왼쪽으로 이동
		BigDecimal b = a.movePointLeft(3);
		System.out.println("처리 결과 : " + b);
		//--==>> 처리 결과 : 123456.789123456789
		
		
		// 나눗셈 연산
		BigDecimal c = a.divide(b);
		System.out.println("처리 결과 : " + c);
		//--==>> 처리 결과 : 1E+3
		
		BigDecimal d = a.divide(b, BigDecimal.ROUND_DOWN);	//-- 반올림을 하지 않는다. → 절삭
		System.out.println("처리 결과 : " + d);				//   (API → 대체 속성 확인)
		//--==>> 처리 결과 : 1000.000000000
		
		// BigInteger 객체로 변환
		System.out.println(a.toBigInteger());
		//--==>> 123456789
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Wrapper 클래스
==============================================*/


public class Test138
{
	public static void main(String[] args)
	{
		byte b = 3;
		int i = 256;
		
		Byte b2 = new Byte(b);
		Integer i2 = new Integer(i);
		
		//System.out.println(b2);
		//System.out.println(i2);
		//--==>> 3
		//		 256
		
		
		print(b2);
		print(i2);
		//--==>> 3
		//		 256
	}
	
	/*
	static void print(Byte b)
	{
	}
	
	static void print(Integer i)
	{
	}
	
	static void print(Short s)
	{
	}
	
	static void print(Long l)
	{
	}			
	
	static void print(Float f)
	{
	}
	
	static void print(Double d)
	{
	}
	
	*/
	
	/*
	static void print(Object ob)
	{
		System.out.println(ob);
	}
	*/
	
	// java.lang.Number 클래스(추상 클래스)는
	// 모든 숫자형 Wrapper 클래스의 부모 클래스
	// (슈퍼 클래스, 상위 클래스)이다.
	// b1, i2 자료형이 Number에 넘어오면서
	// 내부적으로는 업 캐스팅이 일어난게 된다.
	static void print(Number n)
	{
		System.out.println(n);
		
		// instanceof
		/*
		if (n instanceof Integer)
		{
			//System.out.println(n + "은 Integer 객체");
			System.out.println(n.intValue());
		}
		else if (n instanceof Byte)
		{
			System.out.println(n + "은 Byte 객체");
		}
		*/
	}
}
/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Wrapper 클래스
==============================================*/


// 추가 관찰

public class Test139
{
	public static void main(String[] args)
	{
		System.out.println(Integer.MAX_VALUE);
		System.out.println(Integer.MIN_VALUE);
		//--==>> 2147483647
		//		 -2147483648
		
		System.out.println(Long.MAX_VALUE);
		System.out.println(Long.MIN_VALUE);
		//--==>>9223372036854775807
		//		-9223372036854775808
		System.out.println(Double.MAX_VALUE);
		System.out.println(Double.MIN_VALUE);
		//--==>> 1.7976931348623157E308
		//		 4.9E-324				→ e  표기법
		
		System.out.println();			// 개행
		
		// 실수 기반의 나눗셈 연산
		System.out.println("1 : " + (3.0/0));
		System.out.println("2 : " + (-3.0/0));
		//--==>> 1 : Infinity
		//		 2 : -Infinity
		
		System.out.println("3 : " + (3.0/0 == 3.0/0));
		System.out.println("4 : " + (3.0/0 == -3.0/0));
		//--==>> 3 : true
		//		 4 : false
		
		// 『Double.isInfinite()』
		System.out.println("5 : " + Double.isInfinite(3.0/0));
		System.out.println("6 : " + Double.isInfinite(-3.0/0));
		//--==>> 5 : true
		//		 6 : true
		
		System.out.println("7 : " + (0.0/0));
		System.out.println("8 : " + (3.0/0 + -3.0/0));
		//--==>> 7 : NaN (→ Not a Number)
		//		 8 : NaN (→ Not a Number)
		
		System.out.println("9 : " + (0.0/0 == 0.0/0)); 
		System.out.println("10: " + (0.0/0 != 0.0/0)); 
		//--==>> 9 : false
		//		 10: true
		
		// ※ NaN (→ Not a Number)과 임의의 수를 
		//	  크기 비교를 수행하는 『==』연산자를 통해 비교 연산을 수행하게 되면
		//	  결과는 언제나 『false』를 반환한다.
		
		
		//『Double.isNaN()』
		System.out.println("11: " + Double.isNaN(0.0/0));
		System.out.println("12: " + Double.isNaN(1.0/2.0));
		//--==>> 11: true
		//		 12: false
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - String 클래스
==============================================*/

/*
○ String 클래스는 내부 문자열 데이터에 대한 수정이 불가능하다.
	(즉, 내용 불변 : Immutable)
	문자열의 내용이 변경되면 새로운 객체를 생성하며
	참조 대상을 잃어버린 객체는 가비지 컬렉션의 대상이 되고,
	새로운 객체에 새 주소를 할당하게 되므로
	해시코드도 변하게 된다.
	
○ String 클래스 간에 『+』 연산자를 사용하게 되면
	문자열 간의 결합이 가능하며,
	String 클래스와 다른 클래스의 객체, 또는 기본형 데이터 간에
	『+』연산자를 사용하는 경우에도
	내부적으로 자동  String 클래스로 변환이 가능하다.
	
	※ 눈으로(시각적, 표면적으로) 확인되느 결과는 이렇지만...
		String 은 내용을 변경할 수 없기 때문에
		『+』연산자를 사용하게 되면
		내부적으로 StringBuffer를 생성하여
		append() 메소드를 이용해 문자열에 대한 결합을 수행하게 된다.
		따라서 동적인 문자열을 많이 사용하는 Servlet등에서는
		되도록이면 String을 사용하는 것 보다
		StringBuffer 나 char[] 를 사용하는 것이 효율적일 수 있다.


		==> 정적인 문자열을 처리하는 경우에는 주로 String 클래스를 이용
			동적인 문자열을 처리하는 경우에는
			런 타임시 동적으로 처리해주는 StringBuffer 클래스를
			사용하는 것이 효율적이다.
			
○ String 객체의 생성 및 특징

	String 객체를 생성하는 방법은
	① 문자열 상수를 지정하는 방법과
	② String 클래스의 생성자를 이용하는 방법
	이렇게 두 가지 방법이 있다.
	
	String str1 = "Java";
	String str2 = "Java";
	
	String str3 = new String("Java");
	String str4 = new String("Java");
	
	하지만 『문자열 상수』를 대입 연산자를 사용하여
	지정하는 방법을 통해 객체를 생성하는 경우와
	『new』 연산자를 이용하여 객체를 생성하는 것은
	내부적으로 의미가 다르다.

*/

public class Test140
{
	public static void main(String[] args)
	{
		String s1 = "seoul";
		String s2 = "seoul";
		String s3 = new String("seoul");
		String s4 = new String("seoul");
		
		System.out.println("s1 : " + s1);
		System.out.println("s2 : " + s2);
		System.out.println("s3 : " + s3);
		System.out.println("s4 : " + s4);
		//--==>> s1 : seoul
		//		 s2 : seoul
		//		 s3 : seoul
		//		 s4 : seoul
		
		System.out.println("s1 == s2 : " + (s1 == s2));
		System.out.println("s2 == s3 : " + (s2 == s3));
		System.out.println("s3 == s4 : " + (s3 == s4));
		System.out.println("s4 == s1 : " + (s4 == s1));
		//--==>> s1 == s2 : true
		//		 s2 == s3 : false
		//		 s3 == s4 : false
		//		 s4 == s1 : false
		
		
		// ※ s1 과 s2 객체가 참조하는 문자열 상수가 동일한 경우
		//	  문자열이 저장된 기억장소의 영역이 동일하기 때문에
		//	  s1 객체와 s2 객체는 동일한 기억 장소를 참조하게 된다.
		//	  하지만,
		//	  s3 와 s4는 동일한 영역이 아닌 다른 기억 공간을 
		//	  새롭게(→ new) 확보하여 문자열 상수를 그 공간에 대입한 경우이므로
		//	  두 인스턴스는 같은 영역을 참조하는 것이 아니다.
		//	  따라서, 『s3 == s4』는 거짓이 되며,
		//	  만약, 같은 문자열 상수인지의 여부를 비교해야할 상황이라면
		//	  『equals()』메소드를 이용해야 한다.
		
		System.out.println("s1.equals(s2) : " + s1.equals(s2));
		System.out.println("s2.equals(s3) : " + s2.equals(s3));
		System.out.println("s3.equals(s4) : " + s3.equals(s4));
		System.out.println("s4.equals(s1) : " + s4.equals(s1));
		//--==>> s1.equals(s2) : true
		//		 s2.equals(s3) : true
		//		 s3.equals(s4) : true
		//		 s4.equals(s1) : true
		
		// ※ String 클래스는 Object 클래스의 equals() 를 Overriding~!!!
		
		System.out.println("s1.hashCode() : " + s1.hashCode());
		System.out.println("s2.hashCode() : " + s2.hashCode());
		System.out.println("s3.hashCode() : " + s3.hashCode());
		System.out.println("s4.hashCode() : " + s4.hashCode());
		//--==>> s1.hashCode() : 109324212
		//		 s2.hashCode() : 109324212
		//		 s3.hashCode() : 109324212
		//		 s4.hashCode() : 109324212
		
		// ※ 객체가 같으면 hashCode 가 같지만...
		//	  hashCode가 같다고 해서 같은 객체는 아니다~!!!
		
		s2 += " korea";
		System.out.println("s2 : " + s2);
		//--==>> s2 : seoul korea
		
		s2 = "korea";
		System.out.println("s2 : " + s2);
		//--==>> s2 : korea
		
		//-- 이와 같은 경우
		//	 s2가 참조한 "seoul"이 저장된 영역은
		//   『s2 += " korea";』가 수행되는 시점에서
		//   해당 영역의 값이 변경되는 것이 아니라
		//   가비지 컬렉션의 대상이 되며,
		//   "seoul korea" 상수가 저장된 영역을
		//   s2가 참조하게 되었다가
		//   다시 s2가 참조한 "seoul korea"가 저장된 영역은
		//   『s2 = "korea";』가 수행되는 시점에서
		//   가비지 컬렉션의 대상이 되며,
		//   "korea" 문자열 상수가 새롭게 저장된 영역을
		//   s2가 참조하게 된다.
		
		// ==> ※ String 객체의 내용은 불변이다~!!
		
		
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - String 클래스
==============================================*/

public class Test141
{
	public static void main(String[] args)
	{
		String s = "seoul korea";
		System.out.println("s : " + s);
		//--==>> s : seoul korea
		
		// ○ 문자열 추출
		// seoul korea
		System.out.println(s.substring(6,9));
		//--==>> kor
		
		// ※ 『String substring(s,e)』
		//		String 문자열을 대상으로
		//	s번째에서... e-1번째까지 추출하여 결과 문자열 반환
		// (단, 인덱스는 0부터 시작)
		
		// seoul korea
		System.out.println(s.substring(7));
		//--==>> orea
		
		// ※ 『String substring(s)』
		//		String 문자열을 대상으로
		//		s번째에서... 끝까지 추출하여 결과 문자열 반환
		//		(즉, 문자열이 가진 길이만큼...)
		
		
		// ○ 문자열의 데이터(값) 비교
		System.out.println(s.equals("seoul korea"));
		System.out.println(s.equals("seoul Korea"));
		//--==>> true
		//		 false
		//-- 대소문자 엄격히 구분
		
		System.out.println(s.equalsIgnoreCase("SEOUL KOREA"));
		System.out.println(s.equalsIgnoreCase("SeOuL kOrEa"));
		//--==>> true
		//		 true
		//-- 대소문자 구분 안함
		
		// ○ 찾고자 하는 대상 문자열에
		// 『kor』문자열이 존재할까?
		// 존재한다면... 그 위치는 어떻게 될까?
		
		// seoul korea
		// 01234567890
		System.out.println(s.indexOf("kor"));
		//--==>> 6
		
		// seoul korea
		// 01234567890
		System.out.println(s.indexOf("ea"));
		//--==>> 9
		
		// seoul korea
		// 01234567890
		System.out.println(s.indexOf("e"));
		//--==>> 1
		//-- 먼저 찾은 문자열의 인덱스를 반환하고 종료되는 형태
		
		// seoul korea
		// 01234567890
		System.out.println(s.indexOf("tt"));
		//--==>> -1
		//-- 찾고자 하는 문자열(tt)이 대상 문자열(s)에 존재할 경우
		// 그 문자열의 인덱스를 반환하지만
		// 존재하지 않을 경우 음수를 반환하게 된다. (-1)
		
		
		// ○ 대상 문자열(s)이 『rea』로 끝나는지의 여부 확인
		// (→ true / false)
		System.out.println(s.endsWith("rea"));
		System.out.println(s.endsWith("oul"));
		//--==>> true
		//		 false
		
		
		// ○ 찾고자 하는 대상 문자열(s)에
		// 『kor』문자열이 존재할까?
		// 존재한다면... 그 위치는 어떻게 될까?
		// (단, 뒤에서부터 검사)
		
		// seoul korea
		System.out.println(s.indexOf("e"));
		System.out.println(s.indexOf("o"));
		//--==>> 1
		//		 2
		
		
		System.out.println(s.lastIndexOf("e"));
		System.out.println(s.lastIndexOf("o"));
		//--==>> 9
		//		 7
		
		
		// ○ 대상 문자열(s) 중 
		// 『6』 번째 인덱스 위치의 문자는?
		
		// seoul korea
		System.out.println(s.charAt(6));
		System.out.println(s.charAt(10));
		//--==>> k
		//		 a
		
		// seoul korea
		//System.out.println(s.charAt(22));
		//--==>> 에러 발생(런타임 에러)
		//		 StringIndexOutOfBoundsException	→ 대상 문자열이 가지는 인덱스를 벗어난 경우...
		
		// ○ 대상 문자열(s)과 비교 문자열 『seoul korea』 중
		//	  어떤 문자열이 더 큰가?		→ 문자열에 대한 크기 비교
		//    - 두 문자열이 같다면...		→ 0
		//	  - 두 문자열이 다르다면...		→ 차이를 반환(사전식 배열)
		
		
		// seoul korea
		System.out.println(s.compareTo("seoul korea"));
		//--==>> 0
		//-- 두 문자열이 같다.
		//   즉, s와 "seoul korea"는 같다.
		
		
		System.out.println(s.compareTo("seoul corea"));
		//--==>> 8
		//-- 두 문자열이 같지 않다.
		//   즉, s 와 "seoul corea"는 같지 않다.
		//-- c ~ k → defghjk → 8
		
		// ○ 대상 문자열(s) 중
		//	  해당 문자열을 모두 찾아 원하는 형태로 수정된 문자열 반환
		
		s = "우리나라 대한민국 대한독립 만세";
		System.out.println("s : " + s);
		//--==>> s : 우리나라 대한민국 대한독립 만세
		
		s = s.replaceAll("대한","자주");
		//-- 『repalceAll()』은 JDK 1.5 이후부터 사용 가능.
		
		System.out.println("s : " + s);
		//--==>> s : 우리나라 자주민국 자주독립 만세
		
		
		// ○ 공백 제거
		s = s.replaceAll(" ", "");		// s = s.replaceAll("\\s", "");
		System.out.println("s : " + s);
		//--==>> s : 우리나라자주민국자주독립만세
		
		s = "         사           랑        ";
		System.out.println(s);
		//--==>>          사           랑
		System.out.println("|" + s + "|");
		//--==>> |         사           랑        |
		
		System.out.println("|" + s.trim() + "|");
		//--==>> |사           랑|
		//-- 양쪽 가장자리 공백 제거
		
		System.out.println("|" + s.replaceAll(" ", "") + "|");
		//--==>> |사랑|
		
		
		// 50
		int temp = Integer.parseInt("50");
		//System.out.println(temp);
		System.out.printf("%d\n", temp);
		//--==>> 50
		
		
		s = Integer.toString(30);
		//System.out.println(s);
		System.out.printf("%s\n", s);
		//--==>> 30
		
		
		int n = 2345678;
		System.out.printf("%d", n);
		//--==>> 2345678
		System.out.format("%d", n);
		//--==>> 2345678
		
		
		System.out.println();			// 개행
		
		
		s = String.format("%d", n);		// 2345678 → "2345678"
		System.out.println(s);
		//--==>> 2345678
		
		s = String.format("%d월", 10);
		System.out.println(s);
		//--==>> 10월
		
		s = String.format("%.2f", 3.141592);
		System.out.println(s);
		//--==>> 3.14
		
		s = String.format("%d + %d = %d", 10, 20, 30);
		System.out.println(s);
		//--==>> 10 + 20 = 30
		
		
		s = String.format("%b", true);
		System.out.println(s);
		//--==>> true
		
		//String str = "기본, 열정, 배려";
		//String[] strArr = str.split(",");
		
		// line 212 ~ 213 과 동일한 구문
		String[] strArr = "기본, 열정, 배려".split(",");
		
		for (String str : strArr)
			System.out.print(str + " ");
		System.out.println();
		//--==>> 기본  열정  배려
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - String 클래스
==============================================*/

// 사용자로부터 사칙연산수식을 입력받아
// 해당 연산의 처리 결과를 출력하는 프로그램을 구현한다.

// 실행 예)
// 연산수식 입력(num1+num2) : 5+3
// >> 5 + 3 = 8
// 계속하려면 아무 키나 누르세요...


// 연산수식 입력(num1+num2) : 5-3
// >> 5 - 3 = 2
// 계속하려면 아무 키나 누르세요...

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test142
{
	public static void main(String[] args)	throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("연산수식 입력(num1+num2) : ");
		String str = br.readLine();
		str = str.replaceAll("\\s","");
		
		String[] opArr = {"+", "-", "*", "/"};
		for (String op : opArr)
		{
			int pos = str.indexOf(op);
			if (pos > -1)
			{
				int num1 = Integer.parseInt(str.substring(0,pos));
				int num2 = Integer.parseInt(str.substring((pos+1)));
				
				int result = 0;
				char operator = str.charAt(pos);
				switch (operator)
				{
					case '+' : result=num1+num2; break;
					case '-' : result=num1-num2; break;
					case '*' : result=num1*num2; break;
					case '/' : result=num1/num2; break;
				}
				
				String s = String.format("%d %c %d = %d", num1, operator, num2, result);
				System.out.println(s);
				break;
			}
		}
		
		
		
		
		/* 나의 풀이
		String str;
		
		System.out.print("연산수식 입력(num1+num2) : ");
		str = br.readLine();
		
		int opNum = 0;
		
		if (str.indexOf("+") != -1)
			opNum = str.indexOf("+");
		else if (str.indexOf("-") != -1)
			opNum = str.indexOf("-");
		else if (str.indexOf("*") != -1)
			opNum = str.indexOf("*");
		else if (str.indexOf("/") != -1)
			opNum = str.indexOf("/");
	
		char op = str.charAt(opNum);
		
		int num1 = Integer.parseInt(str.substring(0,opNum));
		int num2 = Integer.parseInt(str.substring((opNum+1)));
		
		int result=0;
		
		switch (op)
		{
			case '+' : result = num1 + num2; break;
			case '-' : result = num1 - num2; break;
			case '*' : result = num1 * num2; break;
			case '/' : result = num1 / num2; break;
		
		}
		
		System.out.printf("%d %s %d = %d\n",num1,op,num2,result);
		*/
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - StringBuffer 클래스
==============================================*/

/*
○ StringBuffer 클래스

	문자열을 처리하는 클래스로 String 클래스와의 차이점은
	String 클래스는 내부 문자열 데이터의 수정이 불가능한지만
	StringBuffer 클래스는 문자열을 사용할 때
	내부 문자열을 실행 단계에서 변경할 수 있다.
	
	즉, StringBuffer 객체는 가변적인 길이를 가지므로
	객체를 생성하는 시점에서 미리 그 크기가 값을 지정하거나
	실행 시점에 버퍼의 크기를 바꿀 수 있는 기능을 제공한다.
	
	또한, JDK 1.5 이후부터는
	문자열을 처리하는 StringBuilder 라는 클래스도 제공한다.
	StringBuilder 클래스의 기능은 StringBuffer 클래스와 동일하지만
	가장 큰 차이점은 multi-thread unsafe 라는 점이다.
	즉, Syncronization이 없기 때문에
	StringBuffer 보다 빠르고 동시성(동기화) 문제가 없다면
	StringBuider 를 사용하는 것이 성능을 향상시킬 수 있다.
*/

// 임시로 뭔가를 저장하는 공간 - Buffer


public class Test143
{
	public static void main(String[] args)
	{
		String str1 = new String("seoul");
		String str2 = new String("seoul");
		
		System.out.println(str1);
		System.out.println(str2);
		//--==>> seoul
		//		 seoul
		
		System.out.println(str1 == str2);
		System.out.println(str1.equals(str2));
		//--==>> false
		//		 true
		
		StringBuffer sb1 = new StringBuffer("korea");
		StringBuffer sb2 = new StringBuffer("korea");
		//-- String 클래스 외에는
		//	 모든 문자열 관련 클래스가 new 연산자를 통해서만 메모리 할당 가능
		
		System.out.println(sb1);
		System.out.println(sb2);
		//--==>> korea
		//		 korea
		
		System.out.println(sb1 == sb2);
		System.out.println(sb1.equals(sb2));
		//--==>> false
		//		 false
		
		System.out.println("-------------------------------------------------");
		
		System.out.println(sb1);
		//--==>> korea
		
		System.out.println(sb1.toString());
		//--==>> korea
		
		System.out.println(sb1.toString().equals(sb2.toString()));
		//--==>> true
		
		System.out.println("-------------------------------------------------");
		
		StringBuffer sb3 = new StringBuffer();
		//-- StringBuffer 기본 생성자 호출(인스턴스 생성 과정)
		//	 기본적으로 생성되는 버퍼의 크기는 『16』
		
		// capacity()
		System.out.println("버퍼 크기 : " + sb3.capacity());
		//--==>> 버퍼 크기 : 16
		
		System.out.println(sb3);
		//--==>> 無
		
		/*
		String name = "박지우";
		name += "박세진";
		name += "김믿음";
		name += "윤영식";
		
		System.out.println(name);
		//--==>> 박지우박세진김믿음윤영식
		*/
		
		// append()
		sb3.append("seoul");		// sb3 += "seoul";
		sb3.append("korea");		// sb3 += "korea";
		sb3.append("우리나라");		// sb3 += "우리나라";
		sb3.append("대한민국");		// sb3 += "대한민국";
		
		System.out.println(sb3);
		System.out.println(sb3.toString());
		//--==>>seoulkorea우리나라대한민국
		//		seoulkorea우리나라대한민국
		
		// 버퍼 크기 다시 확인
		System.out.println("버퍼 크기 : " + sb3.capacity());
		//--==>> 버퍼 크기 : 34
		
		
		System.out.println("-------------------------------------------------");
		
		
		String temp1 = "java and oracle";
		System.out.println(temp1.toUpperCase());
		//--==>> JAVA AND ORACLE
		
		String temp2 = "JAVA AND ORACLE";
		System.out.println(temp2.toLowerCase());
		//--==>> java and oracle
		
		//System.out.println(sb3.toUpperCase());
		//System.out.println(sb3.toLowerCase());
		//--==>> 에러 발생(컴파일 에러)
		//		 cannot find symbol
		
		String temp3 = sb3.toString();
		System.out.println(temp3.toUpperCase());
		System.out.println(temp3.toLowerCase());
		//--==>> SEOULKOREA우리나라대한민국
		//		 seoulkorea우리나라대한민국
		
		System.out.println(sb3.toString().toUpperCase());
		System.out.println(sb3.toString().toLowerCase());
		//--==>> SEOULKOREA우리나라대한민국
		//		 seoulkorea우리나라대한민국
		
		System.out.println(sb3);
		//--==>> seoulkorea우리나라대한민국
		
		
		// ○ 대상 문자열(sb3) 중 seoul 앞에
		//	  "한국" 이라는 문자열 추가
		//	  seoulkorea우리나라대한민국 → 한국seoulkorea우리나라대한민국
		sb3.insert(0, "한국");
		System.out.println("처리 결과 : " + sb3.toString());
		//--==>> 처리 결과 : 한국seoulkorea우리나라대한민국
		
		
		// ○ 대상 문자열(sb3) 중 korea 뒤에
		//	  "사랑" 이라는 문자열 추가
		//	  단, 대상 문자열은 인덱스를 눈으로 직접 확인하지 않고...
		//	  한국seoulkorea우리나라대한민국 → 한국seoulkorea사랑우리나라대한민국
		
		
		// 테스트 ①
		System.out.println(sb3.toString());
		//--==>> 한국seoulkorea우리나라대한민국
		
		// 테스트 ②
		// sb3.insert(12, "사랑");
		// System.out.println("처리 결과 : " + sb3.toString());
		//--==>> 처리 결과 : 한국seoulkorea사랑우리나라대한민국
		
		// 테스트 ③
		// sb3.insert("korea");
		System.out.println(sb3.indexOf("korea"));
		//--==>> 7
		
		// 테스트 ④
		//System.out.println(sb3.insert(sb3.indexOf("korea"), "사랑"));
		//--==>> 한국seoul사랑korea우리나라대한민국
		
		// 테스트 ⑤
		//System.out.println(sb3.insert(sb3.indexOf("korea")+5, "사랑"));
		//--==>> 한국seoul사랑korea우리나라대한민국
		
		// 테스트 ⑥
		//System.out.println(sb3.insert(sb3.indexOf("korea")+ "korea".length(), "사랑"));
		//--==>> 한국seoulkorea사랑우리나라대한민국
		
		
		// ○ 대상 문자열(sb3) 에서
		//	  "우리나라" 문자열 삭제
		//sb3.delete(14, 18);
		//System.out.println(sb3);
		//--==>> 한국seoulkorea사랑대한민국
		
		sb3.delete(sb3.indexOf("우리나라"), sb3.indexOf("우리나라") + "우리나라".length());
		System.out.println(sb3);
		//--==>> 한국seoulkorea대한민국
		
		
		// ○ 대상 문자열(sb3) 에서
		//	  "korea"이후 모든 문자열 삭제(korea 포함)
		//	한국seoulkorea사랑대한민국 → 한국seoul
		
		//sb3.delete(7,18);
		//System.out.println(sb3.toString());
		//--==>> 한국seoul
		
		sb3.delete(sb3.indexOf("korea"), sb3.length());
		System.out.println(sb3.toString());
		//--==>> 한국seoul
		
		System.out.println("-------------------------------------------------");
		
		// 버퍼 크기 다시 확인
		System.out.println("버퍼 크기 : " + sb3.capacity());
		//--==>> 버퍼 크기 : 34
		
		// 문자열 데이터(sb3)의 길이 확인
		System.out.println("문자열 크기 : " + sb3.length());
		//--==>> 문자열 크기 : 7
		
		// 버퍼 크기 조절
		// → 현재 문자열을 담아둘 수 있는 버퍼의 크기로...
		// trimToSize();
		sb3.trimToSize();
		
		// 버퍼 크기 조절 이후 버퍼 크기 다시 확인
		System.out.println("버퍼 크기 : " + sb3.capacity());
		//--==>> 버퍼 크기 : 7
		
		
		
		/* 나의 풀이
		System.out.println(sb3.delete(sb3.indexOf("korea")+"korea".length(), sb3.indexOf("대한민국")));
		System.out.println(sb3);
		*/
		
		
		
		/* 나의 풀이
		sb3.insert(sb3.indexOf("우"), "사랑");
		System.out.println("처리 결과 : " + sb3.toString());
		//--==>> 처리 결과 : 한국seoulkorea사랑우리나라대한민국
		*/
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - StringBuffer 클래스
==============================================*/


public class Test144
{
	public static void main(String[] args)
	{
		String s1 = "123456789";
		s1 = (s1 + "123").replace('2','A');
		// "123456789"
		// "123456789123"
		// "1A34567891A3"
		
		System.out.println("s1 : " + s1);
		//--==>> s1 : 1A34567891A3
		
		
		StringBuffer s2 = new StringBuffer("123456789");
		s2.delete(0,3).replace(1, 3, "24").delete(4, 6);
		// "123456789"
		// "123456789".delete(0,3).replace(1, 3, "24").delete(4, 6);
		// "456789".replace(1, 3, "24").delete(4, 6);
		// "424789".delete(4, 6);
		// "4247";
	
		System.out.println("s2 : " + s2);
		//--==>> s2 : 4247
		
		StringBuffer s3 = new StringBuffer("123456789");
		String s4 = s3.substring(3, 6);
		// "123456789"
		// "123456789".substring(3, 6);
		// "456"
		
		System.out.println("s4 : " + s4);
		//--==>> s4 : 456
		
		StringBuffer s5 = new StringBuffer("123456789");
		s5.delete(0, 3).delete(1, 3).delete(2, 5).insert(1,"24");
		// "123456789"
		// "123456789".delete(0, 3).delete(1, 3).delete(2, 5).insert(1,"24");
		// "456789".delete(1, 3).delete(2, 5).insert(1,"24");
		// "4789".delete(2, 5).insert(1,"24");
		// "47".insert(1,"24");
		// "4247";
		
		System.out.println("s5 : " + s5);
		//--==>> s5 : 4247
	
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - StringBuffer 클래스
==============================================*/

/*
○ StringTokenizer 클래스
	
	문자열 파싱(parsing)을 위한 정보를 제공하는 클래스로
	파싱(parsing)하고자 하는 문자열을 인자로 받아 생성하는데,
	여기에서 파싱(parsing)이란 하나의 문자열을 여러 문자열로
	나누는 작업을 임하게 되며, 이 때 나누는 단위가 되는 문자열을
	토큰(token)이라고 한다.
	
	StringTokenizer 클래스를 사용하기 위해서는
	java.util 패키지의 StringTokenizer 를 import해야한다.
	
	StringTokenizer 클래스는 호환성을 유지하는 목적으로 
	보관 유지되고 있으며, 문자열을 파싱(parsing)하기 위해서는
	String 클래스의 split() 메소드나 java.util.regex 패키지를
	사용할 것을 권장하고 있다.
	
○ 생성자

	- 원형
	StringTokenizer(String str)
	StringTokenizer(String str, String delim)
	StringTokenizer(String str, String delim, boolean returnDelims)
	: 주어진 문자열 str을 단어로 분리하는 객체를 생성하며
	  공백(구분) 문자는 delim에 포함된 문자로 처리하게 된다.
	  만약 returnDelims 가 true이면
	  구분 문자도 분리된 데이터에 포함하여 처리하게 된다.
*/

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;
import java.util.StringTokenizer;

public class Test145
{
	public static void main(String[] args) throws IOException
	{
		String strTemp;
		String[] strArr;
		int n;
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	
		System.out.print("파싱할 문자열 입력(컴마 구분) : ");
		strTemp = br.readLine();
		// "사과,딸기,바나나,포도"
		
		// StringTokenizer 인스턴스 생성
		StringTokenizer st = new StringTokenizer(strTemp, ",");
		//-- strTemp 를 대상 문자열로... ("사과,딸기,바나나,포도");
		//	 『,』 구분자로...
		
		// StringTokenizer의  『countTokens()』
		// int countTokens()
		// : 파싱한 문자열의 갯수를 반환(리턴)한다.
		strArr = new String[st.countTokens()];
		//					-----------------
		//							4
		// → strArr = new String[4];
		
		// StringTokenizer 의 『hasMoreTokens()』 와 『nextToken()』
	
		// "사과,딸기,바나나,포도"
		
		n = 0;
		while (st.hasMoreTokens())			// true true true true false
		{
			strArr[n++] = st.nextToken();
			// strArr[0] = "사과";
			// strArr[1] = "딸기";
			// strArr[2] = "바나나";
			// strArr[3] = "포도";
		}
		
		//-- 『hasMoreTokens()』
		//	 : 사용할 수 있는 토큰이 남아있는 경우 true 를 반환
		//	   더이상 사용할 토큰이 없는 경우 false 를 반환
		//	   확인한 결과만 반환할 뿐...
		//	   실제 데이터를 읽어들이지도 않고,
		//	   실제 데이터를 읽어들이는 헤드를 이동시키지도 않는다.
		
		//-- 『nextToken()』
		//	 : 다음 토큰을 얻어온다.
		//	   다음 토큰을 얻어오며 헤드를 이동시키게 된다.
		//     구분자를 바꾸었을 경우 다음 호출에도
		//     바뀐 구분자를 활용하여 토큰을 분리한다.
	
	
		System.out.print("파싱된 토큰(문자열) : ");
		for (String str : strArr)
			System.out.print(str + " ");
		System.out.println();
	
	}
}

// 실행 결과

/*
파싱할 문자열 입력(컴마 구분) : 사과,딸기,바나나,포도,수박
파싱된 토큰(문자열) : 사과 딸기 바나나 포도 수박
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - 문자열 관련 클래스
  - 캐릭터 셋(Character Set)
==============================================*/

/*
○ 캐릭터 셋(Character Set)
	
	- 유니코드(unicode)
	  국제 표준으로 제정된 2바이트계의 만국 공통의 국제 문자부호 체계
	  (UCS : Universal Code System)를 말한다.
	  애플, IBM, 마이크로소프트 등이 컨소시엄으로 설립한 유니코드(unicode)가
	  1990년에 첫 버전을 발표하였고, ISO/IEC JTC1에서 1995년 9월 국제 표준으로 재정하였다.
	  공식 명칭은 ISO/IEC 10646-1(Universal Multiple-Octet coded Character Set)이다.
	  
	  데이터의 교환을 원활하게 하기 위하여
	  문자 1개에 부여되는 값을 16비트로 통일하였다.
	  코드 1문자 당 영어는 7비트, 비영어는 8비트
	  한글이나 일본어는 16비트의 값을 가지게 되는데
	  이들을 모두 16비트로 통일한 것이다.
	  
	- UTF-8 과 UTF-16
	  UTF -8 과 UTF-16의 차이를 한 마디로 말하면
	  문자를 표현할 때의 단위가 다르다는 것이다.
	  UTF-8은 8비트 가변장 멀티바이트에서 문자를 표현하고
	  UTF-16은 16비트 가변장 멀티바이트에서 문자를 표현한다.
	  
	 ·UTF-8(8bit USC Transformation Format)
	   웹에서 기본적으로 사용하는 코드
	   UCS-2 로 정의되는 문자 집합을 이용하여 기술된 문자열을
	   바이트 열로 변환하는 방식의 1개 한 문자를 1~6바이트
	   가변장 멀티바이트로 변환한다.
	   
	 ·UTF-16(16bit USC Transformation Format)
	   자바의 기본코드, 자바에서는 문자 하나를 저장하면 바이트 수는
	   영문자든, 한글 문자든 2바이트를 차지하게 된다.
	   UCS-2 로 정의되는 문자 집합을 이용하여 기술된 문자열에
	   UCS-4 의 일부 문자를 채워넣기 위한 인코딩 방식.
	   UTF-8 과 병용할 수 있다.
	   UCS-2 로 이용할 수 있는 문자 수를 대폭 늘릴 수 있다.
		
   ※ 자바단에서는 UTF-16을 사용하고 웹에서는 UTF-8을 사용하기 떄문에
	  경우에 따라 변환해야 하는 상황이 발생할 수 있다.
		
○ 문자 코드의 종류

	- KSC5601
	  한글 완성형 표준(한글 2,350자 표현)
	  한국공업표준 정보처리분야(C)의 5601번 표준안.
		
	- KSC5636
	  영문자에 대한 표준
	  한국공업표준 정보처리분야(C)의 5636번 표준안.
	  기존 ASCII Code에서 역슬러시(\)를 원(￦) 표시로 대체.
		
	- EUC-KR(M5949)
	  Bell-Laboratories에서 유닉스 상에서 영문자 이외의 문자를
	  지원하기 위해 제안한 확장 유니코드(Extend UNIX Code)중
	  한글 인코딩 방식
	  영문은 KSC5636으로 처리하고, 한글은 KSC5601로 처리
	  즉, EUC-KR(M5949) = KSC5636 + KSC5601
		
	- UTF-8
	  영문과 숫자는 1바이트, 한글은 3바이트로 표현
	  (웹에서 많이 사용, UTF-8 형식으로 JSP를 작성할 때에는
	  파일도 UTF-8형식으로 저장해야한다.)
	
	- UTF-16
	  자바 기본 문자 코드
	  영문과 숫자는 1바이트, 한글은 2바이트로 표현
	
	- ISO-8859-1
	  서유럽 언어 표기에 필효한 US-ASKII 에 없는 
	  94개 글자의 순차적 나열.

*/

import java.io.UnsupportedEncodingException;


public class Test146
{
	public static void main(String[] args) throws UnsupportedEncodingException
	{
		byte[] buf;
		String name = new String("임성산");
		
		System.out.println("디폴트 캐릭터셋 : " + System.getProperty("file.encoding"));
		//--==>> 디폴트 캐릭터셋 : MS949
		
		// 『String.getBytes()』
		//	: 디폴트 캐릭터셋을 기반(규칙)으로 바이트 배열을 반환하는 메소드
		buf = name.getBytes();

		System.out.println("Length : " + buf.length);
		//--==>> Length : 6
		
		for (byte  b : buf)
			System.out.println("[" + b + "]");
		System.out.println();
		//--==>> [-64]┐
		//		 [-45]┘임
		//		 [-68]┐
		//		 [-70]┘성
		//		 [-69]┐
		//		 [-22]┘산
		
		// "UTF-8" 캐릭터 셋을 기반(규칙)으로 바이트 배열을 반환
		buf = name.getBytes("UTF-8");
		//--==>> 에러 발생(컴파일 에러)
		//		 unreported exception UnsupportedEncodingException
		// ※ throws UnsupportedEncodingException 사용 이후 에러 처리 완료
		
		// 반환받은 바이트 배욜의 길이(방의 갯수) 확인
		System.out.println("Length : " + buf.length);
		//--==>> Length : 9
		
		for (byte b : buf)
			System.out.println("[" + b + "]");
		System.out.println();
		//--==>> [-20]	┐
		//		 [-98]	│임
		//		 [-124]	┘
		//		 [-20]	┐
		//		 [-124]	│성
		//		 [-79]	┘
		//		 [-20]	┐
		//		 [-126]	│산
		//		 [-80]	┘
		
		
		// new String("임성산");
		// new String(임성산문자열의바이트배열);
		// → new String(임성산문자열의바이트배열, 디폴트캐릭터셋);
		// new String(임성산문자열의바이트배열, 인코딩방식);
		// new String(임성산문자열의바이트배열, "UTF-8");
		
		// utf-8 형태로 저장된 바이트 배열을\
		// String 객체로 파라미터 값 『utf-8』을 부여하여 생성
		// 즉, utf-8 기반으로 buf 바이트 배열을 합쳐서(조립하여)
		// 문자열 객체를 생성한 후 이 결과를 출력
		System.out.println("Value 1 : " + new String(buf, "UTF-8"));
		//--==>> Value 1 : 임성산
		
		System.out.println();	// 개행
		
		
		// utf-8 형태로 저장된 바이트 배열을
		// String 객체로 두 번째 파라미터 값 없이(디폴트 캐릭터셋을 부여하여) 생성
		// ※ 현재 디폴트 캐릭터셋 : MS949
		System.out.println("Value 2 : " + new String(buf));
		//--==>> Value 2 : ?엫?꽦?궛
		
		System.out.println();	// 개행
		
		
		String convert = new String(name.getBytes(), "utf-8");
		
		System.out.println("Value 3 : " + convert);
		//--==>> Value 3 : ?????
		
		buf = convert.getBytes();		// MS949
		System.out.println("Length : " + buf.length);
		//--==>> Length : 5
		
		buf = convert.getBytes("utf-8");	
		System.out.println("Length : " + buf.length);
		//--==>> Length : 14
		
		/*
		※ check~!!
		
			MS949(EUC-KR)을 UTF-8로 변환하겠다는 의도로
			위와 같이 코딩을 해버리면...
			이러한 변환(잘못된 변환)으로 인해 배열이 깨져서
			MS949든... UTF-8이든
			어떠한 바이트 배열을 읽어오든
			결과물이 깨져있는 것을 확인할 수 있다.
		
			이미 깨져서 생성된 String 객체의 바이트 배열은
			어떤 방식으로든 복구가 불가능하다.
		*/
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Calendar 클래스
==============================================*/

/*
※ Calendar 클래스는 추상 클래스 이기 때문에 객체를 생성할 수 없다.
   (추상 클래스 : 완성되지 않은 클래스 즉, 완성되지 않은 설계도)
   
   Calendar ob = new Calendar();
   → 이와 같은 구문을 통해 객체 생성 불가~!!!
   
○ Calendar 클래스 객체(인스턴스)를 생성할 수 있는 방법

	1. Calendar ob1 = Calendar.getInstance();
	
	2. Calendar ob2 = new GregorianCalendar();
	
	3. GregorianCalendar ob3 = new GregorianCalendar();
	
	(※ GregorianCalendar : Calendar 클래스의 하위 클래스)

*/

// 연, 월, 일, 요일을 Calender 객체로부터 가져와 출력

import java.util.Calendar;
import java.util.GregorianCalendar;
public class Test147
{
	public static void main(String[] args)
	{
		// Calendar 인스턴스 생성
		// Calendar ob = new Calendar();
		Calendar rightNow = Calendar.getInstance();
		
		// 생성된 달력(rightNow) 인스턴스를 통해
		// 날짜 관련 정보를 얻어낼 수 있는 메소드
		// → 『get()』
	
		int y = rightNow.get(Calendar.YEAR);
		System.out.println("y : " + y);
		//--==>> y : 2024
		
		int m = rightNow.get(Calendar.MONTH) + 1;		//-- 『+1』 check!
		System.out.println("m : " + m);
		//--==>> m : 10
		
		int d = rightNow.get(Calendar.DATE);
		System.out.println("d : " + d);
		//--==>> d : 29
		
		int w = rightNow.get(Calendar.DAY_OF_WEEK);
		System.out.println("w : " + w);
		//--==>> w : 3
		
		// 테스트(확인)
		/*
		System.out.println(Calendar.SUNDAY);		//--==>> 1 → 일요일
		System.out.println(Calendar.MONDAY);			//--==>> 2 → 월요일
		System.out.println(Calendar.TUESDAY);		//--==>> 3 → 화요일
		System.out.println(Calendar.WEDNESDAY);		//--==>> 4 → 수요일
		System.out.println(Calendar.THURSDAY);		//--==>> 5 → 목요일
		System.out.println(Calendar.FRIDAY);		//--==>> 6 → 금요일
		System.out.println(Calendar.SATURDAY);		//--==>> 7 → 토요일
		*/
		
		System.out.println(y + "-" + m + "-" + d + " " + w);
		//--==>> 2024-10-29 3
		
		String week = "";
		switch (w)
		{
			/*
			case Calendar.SUNDAY : week = "일요일"; break;
			case Calendar.MONDAY : week = "월요일"; break;
			case Calendar.TUESDAY : week = "화요일"; break;
			case Calendar.WEDNESDAY : week = "수요일"; break;
			case Calendar.THURSDAY : week = "목요일"; break;
			case Calendar.FRIDAY : week = "금요일"; break;
			case Calendar.SATURDAY : week = "토요일"; break;
			*/
			
			case 1 : week = "일요일"; break;
			case 2 : week = "월요일"; break;
			case 3 : week = "화요일"; break;
			case 4 : week = "수요일"; break;
			case 5 : week = "목요일"; break;
			case 6 : week = "금요일"; break;
			case 7 : week = "토요일"; break;
			
			
		}
		
		System.out.println(y + "-" + m + "-" + d + " " + week);
		//--==>> 2024-10-29 화요일
		
		
		System.out.println("------------------------------------------");
		
		// Calendar 인스턴스 생성
		// Calendar rightNow2 = new Calendar();
		Calendar rightNow2 = new GregorianCalendar();
		
		String[] week2 = {"일요일","월요일","화요일","수요일","목요일","금요일","토요일"};
		
		
		// 달력의 날짜를 세팅
		// → 『set()』 메소드 활용
		
		// 2025년 4월 22일
		rightNow2.set(2025, 3, 22);		//『-1』 check~!!
		
		System.out.println(rightNow2.get(Calendar.DAY_OF_WEEK));
		//--==>> 3
		
		System.out.println(week2[rightNow2.get(Calendar.DAY_OF_WEEK)-1]);
		//--==>> 화요일
		
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Calendar 클래스
==============================================*/

/*
○ java.util.Calendar 클래스는
	날짜와 시간을 객체 모델링화 한 클래스로
	연, 월, 일, 요일, 시, 분, 초까지의 시간과 날짜와 관련된 정보를 제공한다.
	그리고, Calendar 클래스는 추상 클래스이므로 직접 객체를 생성할 수 없으며
	실제적인 메소드 구현은 Calendar 클래스의 서브 클래스인
	GregorianCalendar 클래스에 정의되어 있다.
	
	시스템으로부터 현재 시스템 시간 정보를 얻어올 때
	getInstance()라는 정적(static) 메소드를 이용하여 객체를 생성할 수 있다.
	생성된 Calendar클래스 객체는 시스템의 현재 날짜와 시간 정보를 가지며,
	이 객체가 생성되면 갖고있는 시간 정보들은
	get() 메소드를 이용하여 쉽게 가져올(사용할) 수 있다.
	
	getInstance() 메소드는 내부적으로 GregorianCalendar 객체를 생성하며
	돌려주기 때문에 GregorianCalendar 객체를 직접 생성하여 시간 정보를 구할 수도 있다.

*/

// 사용자로부터 연, 월을 입력받아
// 달력을 그려주는(출력하는) 프로그램을 구현한다.
// 단, Calendar 클래스를 활용하여 작성할 수 있도록한다.
// ※ API Document 참조하여 메소드의 활용 방법을 검토할 것~!!
//						    ------
//							 getActualMaximum()
// 실행 예)
// 연도 입력 : 0
// 연도 입력 : 2024
// 월	입력 : -20
// 월	입력 : 15
// 월   입력 : 10
/*
	[ 2024년 10월 ]
 
  일  월  화  수  목  금  토
==============================
		   1   2   3   4   5
   6   7   8   9  10  11  12
  13  14  15  16  17  18  19
  20  21  22  23  24  25  26
  27  28  29  30  31
==============================
계속하려면 아무 키나 누르세요...
*/

import java.util.Scanner;
import java.util.Calendar;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;


public class Test148
{
	public static void main(String[] args) throws IOException
	{
		/*
		Calendar ob = Calendar.getInstance();
		
		System.out.println(ob.getActualMaximum(Calendar.YEAR));				//-- 292278993	
		System.out.println(ob.getActualMaximum(Calendar.MONTH));			//-- 11
		System.out.println(ob.getActualMaximum(Calendar.DATE));				//-- 31
		System.out.println(ob.getActualMaximum(Calendar.HOUR));				//-- 11
		System.out.println(ob.getActualMaximum(Calendar.HOUR_OF_DAY));		//-- 23
		System.out.println(ob.getActualMaximum(Calendar.MINUTE));			//-- 59
		System.out.println(ob.getActualMaximum(Calendar.SECOND));			//-- 59
		System.out.println(ob.getActualMaximum(Calendar.DAY_OF_WEEK));		//-- 7
		System.out.println(ob.getActualMaximum(Calendar.DAY_OF_MONTH));		//-- 31
		*/
		
		// BufferedReader 인스턴스 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
			
		// Calendar 인스턴스 생성
		Calendar cal = Calendar.getInstance();
		
		// 주요 변수 선언
		int y, m;			//-- 연, 월			
		int w;				//-- 요일
		int i;				//-- 루프 변수 활용
		
		do
		{
			System.out.print("연도 입력 : ");
			y = Integer.parseInt(br.readLine());
		}
		while (y<1);
		
		do
		{
			System.out.print("월   입력 : ");
			m = Integer.parseInt(br.readLine());
		}
		while (m<1 || m>12);
		
		// 사용자로부터 입력받은 연(y), 월(ㅡ)을 이용하여
		// 달력의 날짜 세팅
		cal.set(y, m-1, 1);
		//-- 월 구성시 입력값(m)을 그대로 사용하는 것이 아니라
		//	 입력갑에서 1을 뺀 값으로 월을 설정해야 한다.
		//-- 일 구성 시 입력받은 연, 월에 해당하는 1일로 설정해야 한다.
		//	 이는 1일의 요일 확인인 필요하기 때문이다.
		
		// 세팅된 달력의 날짜로부터 요일 가져오기
		w = cal.get(Calendar.DAY_OF_WEEK);
		
		// 테스트(확인)
		// System.out.println("w : " + w);
		//--==>> 연도 입력 : 2024
		//		 월   입력 : 10
		//		 w : 3	→ 2024년 10월 기준 → 화요일 → 2024년 10월 1일은 화요일
		
		// 결과 출력 → 달력 그리기
		System.out.println();
		System.out.println("\t[" + y + "년" + m + "월 ]\n");
		System.out.println("  일  월  화  수  목  금  토"); 
		System.out.println("============================");
		
		for (i=1; i<w; i++)
		{
			System.out.print("    ");	//-- 공백 4칸 발생
		}
		
		// 테스트(확인)
		//System.out.printf("%4d", 1);
		
		// Calendar 의 『getActualMaximum()』메소드 check!!
		//for (i=1; i<=31; i++)
		for (i=1; i<=cal.getActualMaximum(Calendar.DATE); i++)
		{
			System.out.printf("%4d",i);		//-- 반복문을 수행하며 날짜가 증가할 때 마다	
			w++;							//   요일도 이와 함께 증가할 수 있도록 처리
			
			if (w%7 == 1)					//-- 증가한 요일이 일요일이 될 때 마다
			{								//   개행 후 출력될 수 있도록 처리
				System.out.println();
			}
		}
		if (w%7 != 1)						//-- 최종 출력 이후 일요일 개행이 적용되지 않았을 경우만
		{									//   개행할 수 있도록 처리
			System.out.println();
		}
		
		System.out.println("============================");
		
		
		/*
		int y, m, w;
		
		Calendar ob = Calendar.getInstance(); 
		
		Scanner sc = new Scanner(System.in);
		
		do
		{
			System.out.print("연도 입력 : ");
			y = sc.nextInt();
		}
		while (y<1);
		
		do
		{
			System.out.print("월   입력 : ");
			m = sc.nextInt();
		}
		while (m<1 || m>12);
		
		
		ob.set(y, m-1, 1);
		
		String[] week = {"일", "월", "화", "수", "목", "금", "토"};
		w = ob.get(Calendar.DAY_OF_WEEK);
		 
		System.out.println();
		System.out.printf("	[ %d  %d월 ]\n",y,m);
		System.out.println();
		System.out.println("  일  월  화  수  목  금  토"); 
		System.out.println("==============================");
		
		for (int i=1; i<w; i++)
		{
			System.out.print("    ");
		}
		
		for (int i=1; i<=ob.getActualMaximum(ob.DATE); i++)
		{
			System.out.printf("%4d",i);
			w++;
			
			if (w%7 == 1)
			{
				System.out.println();
			}	
			
		}
	
		System.out.println();
		
		System.out.println("==============================");
		*/
	}
	
}

// 실행 결과

/*
연도 입력 : 2024
월   입력 : 2

        [2024년2월 ]

  일  월  화  수  목  금  토
============================
                   1   2   3
   4   5   6   7   8   9  10
  11  12  13  14  15  16  17
  18  19  20  21  22  23  24
  25  26  27  28  29
============================
계속하려면 아무 키나 누르십시오 . . .
*/

/*
연도 입력 : 2023
월   입력 : 2

        [2023년2월 ]

  일  월  화  수  목  금  토
============================
               1   2   3   4
   5   6   7   8   9  10  11
  12  13  14  15  16  17  18
  19  20  21  22  23  24  25
  26  27  28
============================
계속하려면 아무 키나 누르십시오 . . .
*/

/*
연도 입력 : 2024
월   입력 : 10

        [2024년10월 ]

  일  월  화  수  목  금  토
============================
           1   2   3   4   5
   6   7   8   9  10  11  12
  13  14  15  16  17  18  19
  20  21  22  23  24  25  26
  27  28  29  30  31
============================
계속하려면 아무 키나 누르십시오 . . .
*/

/*
연도 입력 : 2024
월   입력 : 11

        [2024년11월 ]

  일  월  화  수  목  금  토
============================
                       1   2
   3   4   5   6   7   8   9
  10  11  12  13  14  15  16
  17  18  19  20  21  22  23
  24  25  26  27  28  29  30
============================
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Calendar 클래스
==============================================*/

// 오늘을 기준으로 입력받은 날짜만큼 후의 연, 월, 일, 요일을
// 확인하여 결과를 출력하는 프로그램을 구현한다.
// ※ API Document 참조하여 메소드의 활용 방법을 검토할 것~!!
//							------
//							add()
//							: 현재 날짜를 기준으로 날 수를 더하는 연산 메소드
//							→ 『객체.add(Calendar.DATE, 날수);』

// 실행 예)
// 오늘 날짜 : 2024-10-30 수요일
// 며칠 후의 날짜를 확인하고자 하십니까? : 200
//
// ========[확인결과]=========
// 200일 후 : xxxx-xx-xx x요일
//============================
// 계속하려면 아무 키나 누르세요...

import java.util.Scanner;
import java.util.Calendar;

public class Test149
{
	public static void main(String[] args)
	{
		// Scanner 인스턴스 생성
		Scanner sc = new Scanner(System.in);
		
		// Calendar 인스턴스 생성
		// Calendar now = Calendar();
		Calendar now = Calendar.getInstance();
		
		// 주요 변수 선언
		int nalsu;			//-- 사용자로부터 입력받은 날 수
		int y, m, d, w;		//-- 연, 월, 일, 요일
		String[] week = {"일","월","화","수","목","금","토"};
		
		// 현재의 연, 월, 일, 요일 확인하기
		// → 가져오기 : get()
		y = now.get(Calendar.YEAR);
		m = now.get(Calendar.MONTH) + 1;		//--『+1』check
		d = now.get(Calendar.DATE);
		w = now.get(Calendar.DAY_OF_WEEK);
		
		// 현재의 연, 월, 일, 요일 확인 결과 출력
		//System.out.println("오늘 날짜 : " + 2024 + "-" + 10 + "-" + 30 + " " + 수 + "요일"
		System.out.println("오늘 날짜 : " + y + "-" + m + "-" + d + " " + week[w-1] + "요일");
		//--==>> 오늘 날짜 : 2024-10-30 수요일
		
		do
		{
			System.out.print("며칠 후의 날짜를 확인하고자 하십니까? : ");
			nalsu = sc.nextInt();
		}
		while (nalsu<1);
		
		// check!!!
		now.add(Calendar.DATE, nalsu);
		
		// 결과 출력
		System.out.println();
		System.out.println("=========[확인결과]=========");
		
		System.out.printf("%d일 후 : %tF %tA\n", nalsu, now, now);
		
		System.out.println("============================");
		
		// String.format("%tF", 날짜 시간객체);
		// → 년-월-일 형태의 문자열 반환
		
		// String.format("%tA", 날짜시간객체);
		// → 요일 형태의 문자열 반환
		
		
		/*
		Scanner sc = new Scanner(System.in);
		
		Calendar cal = Calendar.getInstance();
		
		final String[] DAY_OF_WEEK = {"일","월","화","수","목","금","토"};
		
		System.out.println("오늘 날짜 : " + cal.get(Calendar.YEAR) + "-" + ((cal.get(Calendar.MONTH))+1) + "-" + cal.get(Calendar.DATE) + " " + DAY_OF_WEEK[cal.get(Calendar.DAY_OF_WEEK)] + "요일");
		System.out.print("며칠 후의 날짜를 확인하고자 하십니까? : ");
		int d = sc.nextInt();
		
		cal.add(Calendar.DATE, d);
		
		System.out.println("=========[확인결과]=========");
		System.out.println(d + "일 후 : " + cal.get(Calendar.YEAR) + "-" + ((cal.get(Calendar.MONTH))+1) + "-" + cal.get(Calendar.DATE) + " " + DAY_OF_WEEK[cal.get(Calendar.DAY_OF_WEEK)] + "요일" );
		System.out.println("============================");
		*/
	}
}

// 실행결과

/*
오늘 날짜 : 2024-10-30 수요일
며칠 후의 날짜를 확인하고자 하십니까? : 100

=========[확인결과]=========
100일 후 : 2025-02-07 금요일
============================
계속하려면 아무 키나 누르십시오 . . .
*/

/*
오늘 날짜 : 2024-10-30 수요일
며칠 후의 날짜를 확인하고자 하십니까? : 10

=========[확인결과]=========
10일 후 : 2024-11-09 토요일
============================
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Math 클래스
==============================================*/

/*
○ java.lang.Math 클래스

	수학(Mathmatics)과 관련된 여러 속성들과 함수들을 제공하는 클래스로
	생성자가 있긴 하지만... 『private』으로 선언되어 있기 때문에
	외부에서 객체(인스턴스)를 생성할 수 없다.
	단, 모든 메소드가 『static』으로 정의되어 있으므로
	객체를 생성하지 않고 바로 접근하여 사용하는 것이 가능하다.
	
	
○	java.lang.Math 클래스의 주요 상수 및 메소드

	- public static final double E = 2.71...;
	  : 자연 로그 상수
	  
	- public static final double PI = 3.14...;
	  : 원주율(Π)			// ㅎ
	  
	  
	- public static double sin(double a_
	- public static double cos(double a_
	- public static double tan(double a)
	- sin(a), cos(a), tan(a) 값을 반환한다. (삼각함수)
	
	- public static double asin(double a)
	- public static double acos(double a)
	- public static double atan(doouble a_
	  : asin(a), acos(a), atan(a) 값을 반환한다. (삼각함수의 역함수)
	  
	- public static double toRadians(double angdeg)
	  : 각도(angdeg)를 라디안(radian)으로 바꾸어 반환한다.
	- public static double toDegrees(double angrad)
	  : 라디안(angrad)을 각도(degree)로 바꾸어 반환한다.
	  
	- public static double exp(double a)
	  : e 의 a 승을 구하여 반환한다.
	 
    - public static double log(double a)
	  : 로그(log 값을 구하여 반환한다.
	 
	 
	- public static double sqrt(double a)
	  : a 의 제곱근을 구하여 반환한다.
	  
	- public static double ceil(double a)
	  : a 보다 크거나 같은 정수를 반환한다.(올림의 개념)
	  
	- public static double floor(double a)
	  : a 보다 작거나 같은 정수를 반환한다.(절삭의 개념)
	  
	- public static double pow(double a, double b)
	  : a의 b승을 구하여 반환한다.
	  
	- public static int round(float a)
	- public static long round(double a)
	  : a 를 반올림하여 결과값을 반환한다.
	  
	- public static double random()
	  : 0.0 ~ 1.0 사이의 난수(임의의 실수)를 발생시켜 반환한다.
	  
	  
*/

public class Test150
{
	public static void main(String[] args)
	{
		System.out.println("원주율 : " + Math.PI);
		System.out.println("2의 제곱근 : " + Math.sqrt(2));
		//--==>> 원주율 : 3.141592653589793
		//		 2의 제곱근 : 1.4142135623730951
		
		
		System.out.println("파이에 대한 Degree : " + Math.toDegrees(Math.PI));
		System.out.println("2파이에 대한 Degree: " + Math.toDegrees(2.0*Math.PI));
		//--==>> 파이에 대한 Degree : 180.0
		//		 2파이에 대한 Degree: 360.0
		
		//각모를 라디안으로 변환
		double radian45 = Math.toRadians(45);
		System.out.println("각도 45 : " + radian45);
		//--==>> 각도 45 : 0.7853981633974483
		
		
		System.out.println("싸인     45: " + Math.sin(radian45));
		System.out.println("코싸인   45: " + Math.cos(radian45));
		System.out.println("탄젠트   45: " + Math.tan(radian45));
		//--==>>싸인     45: 0.7071067811865475
		//		코싸인   45: 0.7071067811865476
		//		탄젠트   45: 0.9999999999999999
		
		
		
		System.out.println("로그    25: " + Math.log(25));
		//--==>> 로그    25: 3.2188758248682006
		
		
		System.out.println("2의 4승	  : " + Math.pow(2, 4));
		//--==>> 2의 4승   : 16.0
		
		
		System.out.println("0.0 ~ 1.0 사이의 난수 : " + Math.random());
		//--==>> 0.0 ~ 1.0 사이의 난수 : 0.9845108252770418
		//--==>> 0.0 ~ 1.0 사이의 난수 : 0.38417826267964295
		//--==>> 0.0 ~ 1.0 사이의 난수 : 0.18146335485349818
		//--==>> 0.0 ~ 1.0 사이의 난수 : 0.4850089687121749
	
		
	}
}/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Random 클래스
==============================================*/

/*
○ java.util.Random 클래스는 

   여러 형태의 난수를 발생시켜 제공하는 클래스이다.
   Math 클래스의 정적 메소드인 random() 메소드도 난수를 발생시켜 제공하는 메소드이지만
   0.0~1.0 사이의 실수 형태만 발생하게 되므로
   필요한 여러 형태의 난수를 만들어내기 위해서는 추가적인 연산을 수행해야 한다.
   그래서 자바는 난수를 발생시켜주는 전용 클래스인
   Random 클래스를 별도로 제공하고 있다.
   
*/

// 로또 번호 생성(난수 발생) 프로그램

// 프로그램이 실행되면...
// 기본적으로 로또를 5게임 수행하는 프로그램을 구현한다.

// 실행 예)
// 3 5 12 24 31 42
// 1 2 8 36 40 43
// 4 9 12 13 22 34
// 5 10 13 17 21 40
// 22 31 36 37 40 43
// 계속하려면 아무 키나 누르세요...



import java.util.Random;



class Lotto
{
	
	
	int[][] arr = new int[5][6];
	int a = (int)(Math.random()*45)+1;
	int temp;
	
	
	
	
	public void sort()
	{
		for (int w = 0;w<arr.length;w++)				//
		{
		
			for (int i = 0;i<arr[w].length;i++)
			{
				for (int j = 0;j<arr[w].length-1;j++)
				{
					
					if (arr[w][j] > arr[w][j+1])
					{
						arr[w][j] = arr[w][j]^arr[w][j+1];
						arr[w][j+1] = arr[w][j+1]^arr[w][j];
						arr[w][j] = arr[w][j]^arr[w][j+1];
					}
				}	
				
			}
		}
	
	}
	
	public void input()
	{
		
		for (int i = 0;i<arr.length;i++)
		{
			
			
			for (int j=0;j<arr[i].length;j++)
			{
				boolean flag = false;
				a = (int)(Math.random()*45)+1;
				
				
				//arr[i][j] += a;

				for (int e = 0;e<=i;e++)
				{
					if (arr[i][e] == a)
					{
						flag = true;
						j--;
						break;
					}
				}
				
				if (!flag)
				{
					arr[i][j] = a;
				}	
					
			}
			
		}
	
	}
	
	
	public void print()
	{
		for (int i = 0;i<arr.length;i++)
		{
			for (int j= 0;j<arr[i].length;j++)
			{
				System.out.printf("%4d",arr[i][j]);
			}
			System.out.println();
		}
		
	}
	
}


public class Test151{
	
	public static void main(String[] args){
		
		Lotto lt = new Lotto();
	
		lt.input();
		lt.sort();
		lt.print();
	}
}



			
/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Random 클래스
==============================================*/

/*
○ java.util.Random 클래스는 

   여러 형태의 난수를 발생시켜 제공하는 클래스이다.
   Math 클래스의 정적 메소드인 random() 메소드도 난수를 발생시켜 제공하는 메소드이지만
   0.0~1.0 사이의 실수 형태만 발생하게 되므로
   필요한 여러 형태의 난수를 만들어내기 위해서는 추가적인 연산을 수행해야 한다.
   그래서 자바는 난수를 발생시켜주는 전용 클래스인
   Random 클래스를 별도로 제공하고 있다.
   
*/

// 로또 번호 생성(난수 발생) 프로그램

// 프로그램이 실행되면...
// 기본적으로 로또를 5게임 수행하는 프로그램을 구현한다.

// 실행 예)
// 3 5 12 24 31 42
// 1 2 8 36 40 43
// 4 9 12 13 22 34
// 5 10 13 17 21 40
// 22 31 36 37 40 43
// 계속하려면 아무 키나 누르세요...



import java.util.Random;
import java.util.Arrays;


class Lotto
{
	// 주요 속성 구성
	// 로또 번호를 담아둘 배열방 6칸
	// → 배열 변수 선언 및 메모리 할당
	
	private int[] num;
	
	// 생성자
	Lotto()
	{
		num = new int[6];
	}
	
	// getter
	public int[] getNum()
	{
		return num;
	}
	
	// 6개의 난수를 발생시키는 메소드 정의(중복 없음)
	public void start()
	{
		// Random 인스턴스 생성
		Random rd = new Random();
		int n;
		int cnt = 0;
		
		jump:
		
		while (cnt<6)					// cnt → 0 1 2 3 4 5
		{
			n = rd.nextInt(45) +1;		// 0 ~ 44 → 『+1』 → 1 ~ 45 , 난수의 대역폭을 지정하는 파라미터
										
			
			for (int i=0;i<cnt;i++ )		// cnt:0 → i:x | 
			{
				if (num[i]==n)
					continue jump;   // 같은 값을 발견한 상태
			}
			
			
			num[cnt++] = n;
			
			
			//cnt++
		}
		
		// 정렬 메소드 호출
		sorting();
		
		
		
	}
	
	
	// 정렬 메소드 정의
	private void sorting()
	{
		// 우리가 직접 정렬 알고리즘 구현할 수도 있지만...
		Arrays.sort(num);
	}
	
}


public class Test151_1{
	
	public static void main(String[] args){
		
		//Lotto 인스턴스 생성
		Lotto lotto = new Lotto();
		
		// 기본 5게임
		for (int i=1;i<=5;i++)			// i → 1 2 3 4 5
		{
			//Lotto 게임 수행
			lotto.start();
			
			// 결과 출력
			for (int n : lotto.getNum())
			{
				System.out.printf("%4d",n);
			}
			System.out.println();
		}
		

	}
}


//실행결과

/*
  10  30  35  40  42  45
   4   7   8  19  30  40
   5   7  35  40  43  44
  10  17  20  25  27  35
  10  11  27  30  36  43
계속하려면 아무 키나 누르십시오 . . .

*/



			
/*============================================
  ■■■ 자바의 주요(중요) 클래스 ■■■
  - Random 클래스
==============================================*/

// 스무 고개 → 열 고개

// 다음과 같은 프로그램을 구현한다.

// 실행 예)
// 스무고개 10회 (1~100)				// 사전에 난수 1개 발생 : 32
// input : 20
// 20보다 큽니다.
// input : 80
// 80보다 작습니다.
// input : 50
// 50보다 작습니다.
// input : 30
// 30보다 큽니다.
// input : 35
// 35보다 작습니다.
// input : 32
// val = 32
// count = 6
// 계속하려면 아무 키나 누르세요...

//		:
//		:
// val = 32
// 실패했습니다.
// 계속하려면 아무 키나 누르세요...



import java.util.Scanner;
import java.util.Random;




public class Test152{
	public static void main(String[] args){
		
		Random rd = new Random();
		Scanner sc = new Scanner(System.in);
		int val = rd.nextInt(100) + 1 ;
		int input;
		int cnt = 0;
		
		// 테스트(확인)
		//System.out.println("답 : " + val);
		//--==>> 답 : 33
		
		System.out.println("스무고개 10회 (1~100)");
		
		do
		{
				System.out.print("input : ");
				input = sc.nextInt();
			
			if (val > input)
				System.out.printf("%d보다 큽니다.\n", input);
			else if (val < input)
				System.out.printf("%d보다 작습니다.\n",input);
			cnt++;
		}
		while (input!=val && cnt<10);
		
		
		System.out.println("val = " + val);
		if (input != val)
		{
			System.out.println("실패했습니다.");
			
		}
		else
		{
			System.out.println("count = " + cnt);
		}
		
		
		
		
		
		
	}
}

//실행결과

/*
스무고개 10회 (1~100)
input : 5
5보다 큽니다.
input : 50
50보다 큽니다.
input : 80
80보다 큽니다.
input : 90
90보다 작습니다.
input : 85
85보다 작습니다.
input : 87
87보다 작습니다.
input : 89
89보다 작습니다.
input : 83
83보다 작습니다.
input : 82
val = 82
count = 9
계속하려면 아무 키나 누르십시오 . . .
*/
/*
스무고개 10회 (1~100)
input : 1
1보다 큽니다.
input : 2
2보다 큽니다.
input : 3
3보다 큽니다.
input : 4
4보다 큽니다.
input : 5
5보다 큽니다.
input : 6
6보다 큽니다.
input : 7
7보다 큽니다.
input : 8
8보다 큽니다.
input : 9
9보다 큽니다.
input : 10
10보다 큽니다.
val = 58
실패했습니다.
계속하려면 아무 키나 누르십시오 . . .
*/


























/*
class Smoth
{
	Scanner sc = new Scanner(System.in);
	Random rd = new Random();
	int num;
	int ran;
	int cnt=0;
	
	
	void set()
	{
		
		//랜덤 변수하나 생성
		
			ran = rd.nextInt(100) + 1;
			System.out.println(ran);
	}
	
	
	void input()
	{
		
		do
			{
			System.out.print("스무고개 10회 (1~100) : ");
			num = sc.nextInt();
			
			}
			while (num<1 || num>100);
		
		
		while (true)
		{
			cnt++;
			
			if (cnt==10)
			{
			System.out.println("val   : " + ran);
			System.out.println("실패했습니다.");
			return;
			}
			
				
			else if (num>ran)
			{
				System.out.println("input : " + num);
				System.out.println(num + " 보다 작습니다.");
				System.out.print("스무고개 10회 (1~100) : ");
				num = sc.nextInt();
			}
			
			else if (num<ran)
			{
				System.out.println("input : " + num);
				System.out.println(num + " 보다 큽니다.");
				System.out.print("스무고개 10회 (1~100) : ");
				num = sc.nextInt();
			}
			else if (num==ran)
			{
				System.out.println("input : " + num);
				System.out.println("val   : " + ran);
				System.out.println("count : " + cnt);
				break;
				
			}
			
		}
		
		
		
		
	}
}



public class Test152{
	public static void main(String[] args){
		
		Smoth sm = new Smoth();
		
		sm.set();
		sm.input();
	}
}
*//*============================================
  ■■■ 예외 처리(Exception Handling) ■■■
==============================================*/

/*
○ 프로그램에서 발생하는 오류는

	① 잘못된 문법을 사용하거나 변수 등을 정의하지 않은 상태에서
	   사용함으로써 컴파일 단계에서 발생하는 문법적인 오류와
		
		
	② 프로그램을 실행하는 과정에서 발생되는 런타임 오류로 나눌 수 있다.
	   
	   - 개발자가 문제 분석을 잘못하거나 실수에 의해
	     엉뚱한 결과를 가져오게 되는 논리적인 오류와
		 
	   - 시스템 이상에서 발생되는 시스템 오류, 그리고
	   
	   - 프로그램램 실행 중 발생되는 비정상적인 상황을 의미하는
		 예외사항(Exception)이 있다.
		 
	==>> 개발자가 이런 예외 사항이 발생할 경우를 미리 예측하여
		 적절히 대응하기 위한 절차를 구현하도록 문법을 정리해 놓은것.
		 → 예외처리
		 
		 
		 
※	 정리해 놓은 문법! (Exception 클래스)

	- 예외는 프로그램 실행 중에 발생할 수 있는
	  명령어의 정상적인 흐름을 방해하는 이벤트로
	  자바에서 예외는 하나의 오브젝트(Object, 객체)이다.
	  
	- 프로그램 실행 중에 메소드 안에서 오류가 발생하게 될 경우
	  메소드는 그 오류에 해당하는 예외 오브젝트를 만들고
	  그것을 자바 런터임 시스템(Runtime System)에 전달해준다.
	  
	- 자바에서의 모든 예외 클래스는 Throwable 클래스나
	  Throwable 클래스의 하위 클래스를 상속받아 사용한다.
	  
	- Thorwable 클래스는 예외를 설명하는 문장이나
	  예외가 발생할 때의 프로그램의 상태에 관한 정보를 포함하고 있다.
	  
	- Throwable 클래스에서 파생된 클래스
	
	  ．Exception 클래스
		Exception 예외 클래스는 일반적으로 프로그래머에 의해
		복원될수 있는 예외상황으로 
		메소드가 실행 중에 던지는 예외를 가리킨다.
		
	  ． Error 클래스
	     심각한 예외의 형태로 개발자가 복원할 수 없는 형태의 오류이다.
		 
		 
		 
※	예외의 종류

   - checked exception
     메소드 내에서 예외가 발생한 경우
	 메소드를 정의 할 때 『Throws』 문에 메소드 내에서 발생할 수 있는
	 예외들을 명시해 주거나 또는 그 예외를 『try~catch』 해서
	 처리해 주어야만 하는 예외이다.
	 컴파일러가 컴파일 하는 과정에서 『checked exception』이
	 『throws』되는가 여부 혹은 『try~catch』되는지의 여부를 판단하여
	 프로그램에서 예외를 어떤 방식으로든 처리하지 않으면
	 컴파일 자체가 불가능하다
	 
   - unchecked exception
     사전에 처리하지 않아도 컴파일러가 체크하지 않은
	 런타임 시에 발생할 수 있는 예외이다.
	 
	 
○  java.lang.Thorwable 클래스의 주요 메소드

   - String toString()
     : Thorwable 각각에 대한 설명을 문자열 형태로 반환한다.
   - void printStackTrace(PrintStream s)
   - void printStackTrace(PrintWriter w)
     : 표준 출력 스트름에 스택 호출 목록을 마지막 메소드부터 출력한다.
	 
	 
○	주요 런타임 예외 클래스

   - ArithemticException
     : 수치 계산상의 오류(0으로 나누기 등)
   - ArrayStoreException
     : 배열에 잘못된 데이터 형을 저장하려 했을 경우 발생하는 오류
   - IndexOutOfBoundsException
     : 배열, 문자열, 백터 등에서 인덱스 범위가 벗어난 경우 발생하는 오류
   - ClassCastException
     : 클래스 변환을 잘못 수행한 경우 발생하는 오류
   - NullPointerException
     : 빈 객체를 참조하는 경우(촉기화 되지 않은 변수 사용 등) 발생하는 오류
   - SecurityException
     : 자바의 내부 보안 사항을 위반하였을 경우 발생하는 오류
	 
									:
									:
	   
*/

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;


public class Test153{
											// ① 
	public static void main(String[] args) //throws IOException 
	{
		
		//BufferedReader 인스턴스 생성
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		// 주요 변수 선언
		int a, b, c;
		
		
		// ②
		/*
		try
		{
			System.out.print("첫 번째 정수 입력 : ");
			a = Integer.parseInt(br.readLine());
			
			System.out.print("두 번째 정수 입력 : ");
			b = Integer.parseInt(br.readLine());
			
			c = a + b;
			
			System.out.println("결과 : " + c);
			
		}
		catch (IOException e)
		{
			//IOException → checked exception
			//-- 메소드를 정의하는 과정에서 throws 한 예외.
			//   잡아 내거나 던지지 않을 경우 컴파일 에러 발생.
			System.out.println(e.toString());
		}
		*/
		
		//③
		/*
		try
		{
			System.out.print("첫 번째 정수 입력 : ");
			a = Integer.parseInt(br.readLine());
			
			System.out.print("두 번째 정수 입력 : ");
			b = Integer.parseInt(br.readLine());
			
			c = a + b;
			
			System.out.println("결과 : " + c);
			
		}
		catch (IOException e)
		{
			//IOException → checked exception
			//-- 메소드를 정의하는 과정에서 throws 한 예외.
			//   잡아 내거나 던지지 않을 경우 컴파일 에러 발생.
			System.out.println(e.toString());
		}
		catch (NumberFormatException e)
		{
			// NumberFormatExcpetion → unchecked exception
			// -- 런 타임 시 발생할 수 있는 예외로
			//    반드시 던질 필요도, 잡아낼 필요도 없다.
			//System.out.println(e.toString());
			//--==>> java.lang.NumberFormatException: For input string: "A"
			//e.printStackTrace();
			System.out.println(">> 숫자 형태의 데이터를 입력해야 합니다 !");
			
		}
		*/
		
		// ④
		/*
		try
		{
			System.out.print("첫 번째 정수 입력 : ");
			a = Integer.parseInt(br.readLine());
			
			System.out.print("두 번째 정수 입력 : ");
			b = Integer.parseInt(br.readLine());
			
			c = a + b;
			
			System.out.println("결과 : " + c);
			
		}
		catch (Exception e)
		{
			System.out.println(e.toString());
			//--==>> java.lang.NumberFormatException: For input string: "a"
			System.out.println(e.getMessage());
			//--==>> For input string: "a"
			
			System.out.println("printStackTrace...");
			e.printStackTrace();
			//--==>> printStackTrace...
			//		 java.lang.NumberFormatException: For input string: "a"
			//				at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
			//				at java.lang.Integer.parseInt(Integer.java:580)
			//				at java.lang.Integer.parseInt(Integer.java:615)
			//				at Test153.main(Test153.java:182)
			
		}
		*/
		
		//  etc....
		try
		{
			System.out.print("첫 번째 정수 입력 : ");
			a = Integer.parseInt(br.readLine());
			
			System.out.print("두 번째 정수 입력 : ");
			b = Integer.parseInt(br.readLine());
			
			c = a + b;
			
			System.out.println("결과 : " + c);
			
		}
		catch (Exception e)
		{
			System.out.println(e.toString());
			System.out.println(e.getMessage());
			System.out.println("printStackTrace...");
			e.printStackTrace();
			
		}
		finally
		{
			// 예외가 발생하거나 발생하지 않거나 언제나 실행되는 영역
			System.out.println("고생많으셨습니다~감사합니다.");
		}
		
	}
}/*============================================
  ■■■ 예외 처리(Exception Handling) ■■■
==============================================*/


// Test155.java 파일과 비교~!!!


import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;


public class Test154{
	
		private String[] data = new String[3];
		
		public void proc() throws IOException
		{
			BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		
			String str;
			int n = 0;
		
			System.out.print("이름 입력(종료:ctrl+z) : ");
			while ((str=br.readLine()) != null)
			{
				data[n++] = str;
				System.out.print("이름 입력(종료:Ctrl+z) : ");
			}
			
			System.out.println("입력된 내용............");
			for (String s : data)
			{
				if (s != null)
				{
					System.out.println(s);
				}
			}
		}


		
	public static void main(String[] args) throws IOException
	{
		
		
		Test154 ob = new Test154();
		ob.proc();
	}
}


/*
이름 입력(종료:ctrl+z) : 이은솔
이름 입력(종료:Ctrl+z) : 박제훈
이름 입력(종료:Ctrl+z) : 정승민
이름 입력(종료:Ctrl+z) : ^Z
입력된 내용............
이은솔
박제훈
정승민
계속하려면 아무 키나 누르십시오 . . .
*/

/*
이름 입력(종료:ctrl+z) : 이은솔
이름 입력(종료:Ctrl+z) : 박제훈
이름 입력(종료:Ctrl+z) : 정승민
이름 입력(종료:Ctrl+z) : 임성산
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 3
        at Test154.proc(Test154.java:24)
        at Test154.main(Test154.java:45)
계속하려면 아무 키나 누르십시오 . . .
*/

/*
이름 입력(종료:ctrl+z) : 이은솔
이름 입력(종료:Ctrl+z) : 박제훈
이름 입력(종료:Ctrl+z) : ^Z
입력된 내용............
이은솔
박제훈
계속하려면 아무 키나 누르십시오 . . .
*/


// ArrayIndexOutOfBoundsException/*============================================
  ■■■ 예외 처리(Exception Handling) ■■■
==============================================*/

// Test154.java 파일과 비교~!!!



import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;


public class Test155{
	
	String[] data = new String[3];
	
	public void proc() //throws IOException
	{
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		String str;
		int s = 0;
		
		
		try
		{
			System.out.print("이름 입력(Ctrl+z 종료) : ");
		
			while ((str=br.readLine()) != null)
			{
				data[s++] = str;
				System.out.print("이름 입력(Ctrl+z 종료) : ");
			}
		
			System.out.print("입력된 내용......");
			for (String n : data)
			{
				if (n != null)
				{
					System.out.println(n);
				}
			
			}
		}
		catch (IOException e)
		{
			System.out.println(e.toString());
		}
		catch (ArrayIndexOutOfBoundsException e)
		{
			System.out.println("배열 인덱스 관련 예외 발생~!!!");
		}
		
	}
	
	
	
	
	public static void main(String[] args) //throws IOException
		{
		
		Test155 ts = new Test155();
		
		ts.proc();
	}
}

/*
이름 입력(Ctrl+z 종료) : 안석창
이름 입력(Ctrl+z 종료) : 김민승
이름 입력(Ctrl+z 종료) : 김정현
이름 입력(Ctrl+z 종료) : 박지우
배열 인덱스 관련 예외 발생~!!!
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
  ■■■ 예외 처리(Exception Handling) ■■■
==============================================*/

// Test157.java 파일과 비교~!!!

class Demo
{
	private int value;
	
	public void setValue(int value)
	{
		if (value <= 0)				// 넘겨받는 value 가 0보다 작거나 같을 경우...
		{
			return;					// 종료 → 메소드 종료
		}
		
		this.value = value;
	}
	
	public int getValue()
	{
		return value;
	}
}


public class Test156{
	public static void main(String[] args){
		
		Demo ob = new Demo();
		ob.setValue(-7);
		int result = ob.getValue();
		
		System.out.println(result);
		
	}
}

// 실행 결과
/*
0
계속하려면 아무 키나 누르십시오 . . .
*//*============================================
■■■ 예외 처리(Exception Handling) ■■■
==============================================*/

// Test156.java 파일과 비교~!!!

// ※ thorws		/		throw
//     처리				    발생

class Demo
{
	private int value;
	
	public void setValue(int value) throws Exception
	{
		if (value <= 0)				// 넘겨받는 value 가 0보다 작거나 같을 경우...
		{
			//return;					// 종료 → 메소드 종료
			throw new Exception("value 는 0보다 작거나 같을 수 없습니다.");
			//-- 예외발생(어떻게 후속조치 할것인지도 추가해야함)
		}
		
		this.value = value;
	}
	
	public int getValue()
	{
		return value;
	}
}

public class Test157{
	public static void main(String[] args) //throws Exception
	{
		
		Demo ob = new Demo();
		/*
		ob.setValue(-7);
		int result = ob.getValue();
		System.out.println(result);
		*/
		
		try
		{
			//ob.setValue(-7);
			ob.setValue(20);
			int result = ob.getValue();
			System.out.println(result);
			
		}
		catch (Exception e)
		{
			System.out.println(e.toString());
		}

	}
}

/*============================================
■■■ 예외 처리(Exception Handling) ■■■
==============================================*/

// 예외 다시 던지기

public class Test158{
	public static void main(String[] args)			// throws Excpetion
		{
		
		Test158 ob = new Test158();
		
		try
		{
			// ⑧ 예외 발생
			int a =ob.getValue(-2);
			System.out.println("a : " + a);
		}
		catch (Exception e)			// ⑨ 발생한 예외 잡아내기
		{
			// ⑩ 잡아낸 예외에 대한 처리
			System.out.println("printStackTrace...........................");
			e.printStackTrace();
		}
		
	} // main 메소드
								//② 발생한 예외 던지기
	public int getData(int data) throws Exception
	{
		if (data < 0)
		{
			// ① 예외 발생
			throw new Exception("data 가 0 보다 작습니다.");
		}
		return data + 10;
	}// getData 메소드
									//⑦ 잡아낸 예외를 다시 던지기
	public int getValue(int value) throws Exception
	{
		int a = 0;
		
		try
		{
			// ③ 예외 발생
			a = getData(-2);	
		}
		catch (Exception e) // ④ 발생한 예외 잡아내기
		{
			// ⑤ 잡아낸 예외에 대한 처리
			System.out.println("printStackTrace............");
			e.printStackTrace();
			
			// check
			// ⑥ 잡아서 처리한 예외를 다시 발생
			throw e;
		}
		
		
		return a;
	}// getValue 메소드
}/*============================================
■■■ 예외 처리(Exception Handling) ■■■
==============================================*/

// 다른 예외 다시 던지기

public class Test159{
	
	public int getValue(int value) throws Exception						// ⑦ 발생한 예외 던지기
	{																	// ⑧ (파랑 폭탄)
		int a = 0;
		try
		{
			a = getData(-2);											// ③ 예외 발생	
		}																//    (빨강 폭탄)
		catch (Exception e)												//  ④ 발생한 예외 잡아내기
		{																//	  (빨강 폭탄)
			// ⑤ 잡아낸 예외에 대한 처리(빨강폭탄)
			System.out.println("printStackTrace.........................");
			e.printStackTrace();
			
			// check!
			// ⑥ 예외 발생(파랑 폭탄)
			throw new Exception("Value 가 음수입니다.");				
		}
		return a;													
	}
	
	public int getData(int data) throws Exception					// ② 발생한 예외 던지기
	{																//	  (빨강 폭탄)
		if (data < 0)
		{
			throw new Exception("data 가 0 보다 작습니다.");		// ① 예외 발생
		}															//	  (빨강 폭탄)
		return data + 10;
	}
	
	
	public static void main(String[] args){
		
		Test159 ob = new Test159();
		
		try
		{
			int a = ob.getValue(-2);									// ⑧ 예외 발생
			System.out.println("a : " + a);								//   (파랑 폭탄)
			
		}
		catch (Exception e)												// ⑨ 발생한 예외 잡아내기
		{																//	  (파랑 폭탄)
			// ⑩ 잡아낸 예외에 대한 처리(파랑 폭탄)
			System.out.println("printStackTrace()............................");
			e.printStackTrace();
		}
		
		
		
	}
	
	
	
	
}

/*
printStackTrace.........................
java.lang.Exception: data 가 0 보다 작습니다.
        at Test159.getData(Test159.java:33)
        at Test159.getValue(Test159.java:14)
        at Test159.main(Test159.java:45)
printStackTrace()............................
java.lang.Exception: Value 가 음수입니다.
        at Test159.getValue(Test159.java:24)
        at Test159.main(Test159.java:45)
계속하려면 아무 키나 누르십시오 . . .
*//*===============================================
■■■ 컬렉션 프레임워크 (Collection Framework) ■■■
================================================*/
/*
○	컬렉션 프레임워크(collection Framework)
    = 컬렉션(collection) + 프레임워크(Framework)
      ------------------   ---------------------
	         |					환경, 틀, 약속
			 |						
		   집합 → 수집품,소장품,(물건,사람들의) 무리, 더미, 수집, 수거
		          ----------------------------------------------------
							│ 모아놓은 것들... 모여있는 것들...
	
	
	==> 자료구조

	
○	자료
	현실 세계로부터 단순한 관찰이나 측정을 통해 수집된
	사실이나 개념의 값들 또는 그 값들의 집합.
	
	↓
	
○	자료구조
	자료 처리를 위한 자료의 표현, 저장, 관계, 관리 및
	이용에 관한 방법 등의 개념을 이해하여 프로그램에 사용하고
	컴퓨터에 의해 처리되는 과정에서 적절한 자료의 표현, 구성, 저장 및 
	처리를 위한 알고리즘 작성 및 선택과 이용 방법을 연구한느 분야.
	
	↓
	
○	컬렉션 프레임워크
	컬렉션(모아놓은 데이터들)의 표현과 조작을 위한 통일된 아키텍처로
	컬렉션 프레임워크를 구성하는 요소는 다음과 같다.
	
	1. 인터페이스(Interface)
	   기본적으로 컬렉션에 필요한 데이터 관리 기능을 제공한다.
	   예를 들어, List 는 추가, 삭제, 검색 등의 기능을 제공하는
	   컬렉션 인터페이스가 존재하며
	   각 컬렉션마다 고유의 인터페이스가 정의되어 있다.
	   
	2. 구현(Implementation)
	   인터페이스를 구현한 클래스로 각 컬렉션을
	   실제 어떤 자료구조를 이용하여 표현했느냐에 따라
	   컬렉션의 종류가 달라지게 된다.
	
	3. 알고리즘(Algorithms)
	   각 컬렉션들마다 유용하게 사용될 수 있는 메소드를 의미한다.
	   
※  자바의 컬렉션은 견고한 컬렉션 프레임워크 기반 위에 정의되어 있으므로
   각 컬렉션 종류마다 제공되는 메소드의 일관성이 있기 떄문에
   한 가지 컬렉션을 익혀두면 다른 컬렉션을 사용하는데 용이하다.
*/

/*
○ 스택(Stack)
	
  Stack 클래스는 오브젝트 후입선출(LIFO) 구조의 Stack 을 나타낸다.
  이는, 벡터(Vector)를 스택으로 처리하는 5개의 메소드로
  벡터(Vector) 클래스를 확장하게 된다.
  
  통상의 push() 메소드와 pop() 메소드가 제공되는 것 외에
  스택의 선두 항목으로 peek() 을 실시하는 메소드,
  스택이 비어있는지의 여부를 확인하는 메소드 isEmpty(),
  스택으로 항목을 찾아서 선두로부터 몇 번째인지를 찾아내는 메소드 등이 제공된다.
  
  스택이 처음으로 작성되었을 때, 항목은 존재하지 않는다.
  
  - boolean empty()
    스택이 비어있는지 확인한다.
  - E Object peek()
    스택의 맨 위의 객체를 스택에서 제거하지 않고 반환한다.
  - E Object pop()
    스택의 맨 위의 객체를 반환하고 스택에서 제거한다.
  - E Object push(E item)
    객체를 스택 자료구조에 저장한다.
  - int serch(Object o)
    스택의 맨위에서 부터 파라미터 값으로 넘겨받은 객체까지의 거리를 반환한다.
	맨 위의 객체의 경우 1을 반환하고 그 아래 객체는 2를 반환하는 형식
	
	List > 순서가 의미가 있음
	Set > 순서의 의미가 없음
	Map > 자료의 꼬리표가 따라다니는 구조 / 중복이 있으면 문제
	
	
	
  
*/


// 제네릭, 제네릭 표현식

import java.util.Stack;
public class Test160{
	public static void main(String[] args){
		
		//	Stack 자료구조 생성
		Stack<Object> myStack = new Stack<Object>();
		
		String str1 = "곽유진";
		String str2 = "정승민";
		String str3 = "엄서연";
		String str4 = "박제훈";
		
		// myStack 이라는 Stack 자료구조 안에 str1 ~ str4 까지 담아내기
		// add(), push()
		myStack.add(str1);
		myStack.add(str2);
		myStack.push(str3);
		myStack.push(str4);
		
		// peek() : 스택 맨 위의 객체 반환, 제거하지 않는다.
		String val1 = (String)myStack.peek();
		System.out.println("val1 : " + val1);
		//--==>> val1 : 박제훈
		
		String val2 = (String)myStack.peek();
		System.out.println("val2 : " + val2);
		//--==>> val2 : 박제훈
		
		String val3 = (String)myStack.peek();
		System.out.println("val3 : " + val3);
		//--==>> val3 : 박제훈
		
		String Value = "";
		
		// myStack 이라는 이름을 가진 Stack 자료구조에
		// 데이터가 비어있는 상태라면...
		// → myStack.isEmpty()
		
		// myStack 이라는 이름을 가진 Stack 자료구조에
		// 데이터가 비어있는 상태가 아니라면...(즉, 채워져 있는 상태라면...)
		// → !myStack.isEmpty()
		
		// myStack 에 값이 들어있으면...		//유진 승민 서연 제훈  / 유진 승민 서연 / 유진 승민		/ 유진				/	()
		while (!myStack.isEmpty())				// !false → true      / !false → true   /!false → true / !false → true	   / !true → flase
		{
			// pop() : 스택 맨 위의 객체 반환 제거한다.
			Value = (String)myStack.pop();		// 제훈 / 서연 / 승민 / 유진
			System.out.println("value : " + Value);
			/*
			value : 박제훈
			value : 엄서연
			value : 정승민
			value : 곽유진
			*/
		}
		
	}
}/*===============================================
■■■ 컬렉션(Collection Framework) ■■■
================================================*/

import java.util.Stack;

public class Test161{
		
	// 정적 문자열 배열 선언 및 초기화
	private static final String[] colors
		 = {"검정","노랑","초록","파랑","빨강","연두"};
	
	
	// 생성자(사용자 정의 생성자)
	public Test161()
	{
		// st라는  Stack 자료구조 생성
		// 제네릭을 활용하여 자료구조에 담기는 데이터표현 → 『<String>』
		Stack<String> st = new Stack<String>();
		
		
		// st라는 Stack 자료구조에 데이터(colors) 담기
		// st = colors;		//--(Ⅹ)
		
		/*
		st.push(colors[0]);
		st.push(colors[1]);
		st.push(colors[2]);
		st.push(colors[3]);
		st.push(colors[4]);
		st.push(colors[5]);
		*/
		/*
		st.add(colors[0]);
		st.add(colors[1]);
		st.add(colors[2]);
		st.add(colors[3]);
		st.add(colors[4]);
		st.add(colors[5]);
		*/
		/*
		for (int i = 0;i<colors.length;i++)
		{
			//st.add(colors[i]);
			st.push(colors[i]);
		}
		*/
		for (String color : colors)
		{
			st.push(color);					// st.add(color);
		}
		
		//st.push(10);
		//st.push(10.0);
		//--==>> 에러 발생(컴파일 에러)
		//-- 제네릭 표현식을 통해 선언하고 있는
		//   String이 아닌 다른 자료형(int 나 double)을
		//	 스택 자료구조 st에 push() 하려고 했기 떄문에 발생하는 에러
		
		st.push("보라");
		
		//출력 메소드 호출
		popStack(st);

	}
	
	// 출력 메소드
	private void popStack(Stack<String> st)
	{
		
			while (!st.isEmpty())
			{
			System.out.println("pop : " + st.pop());
			}

	}
	
	public static void main(String[] args){
		
		Test161 ob = new Test161();
				
	}
		
	
}

//실행결과

/*
pop : 연두
pop : 빨강
pop : 파랑
pop : 초록
pop : 노랑
pop : 검정
계속하려면 아무 키나 누르십시오 . . .
*/

//보라 추가 후
/*
pop : 보라
pop : 연두
pop : 빨강
pop : 파랑
pop : 초록
pop : 노랑
pop : 검정
*//*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/


/*
○	큐(Queue)

	큐(Queue)는 선입선출(FIFO) 구조로 먼저 입력된 자료를 먼저 출력하며,
	Queue 인터페이스를 구현한 클래스는 큐와 관련된 다양한 기능을 제공한다.
	
※	Queue 인터페이스 기반의 인스턴스를 생성하기 위해서는
	new 연산자를 이용하여 Queue 인터페이스를 구현한(implements)
	클래스의 생성자를 호출한다.
	
	ex) Queue ob = new LinkedList();
	
○	주요 메소드

	- E element()
	  큐의 head 요소를 반환하며 삭제하지 않는다.
	- boolean offer(E o)
	  지정된 요소를 큐에 삽입한다.
	- E peek()
	  큐의 head 요소를 반환하고 삭제하지 않으며
	  큐 자료구조가 empty 인 경우 null 을 반환한다.
    - E poll()
	  큐 head 요소를 반환하고 삭제하며
	  큐 자료구조가 empty 인 경우 null을 반환한다.
	- E remove()
	  큐의 head 요소를 반환하고 삭제한다.
*/


import java.util.Queue;
import java.util.LinkedList;

public class Test162{
	public static void main(String[] args){
		
		// Queue 자료구조 생성
		// Queue myQue = new Queue();		//--(Ⅹ)
		Queue<Object> myQue = new LinkedList<Object>();
		
		// 데이터 준비
		String str1 = "김정현";
		String str2 = "김태완";
		String str3 = "임성산";
		String str4 = "박제훈";
		
		// myQue 라는 Queue 자료구조에 데이터 추가
		// → offer()
		myQue.offer(str1);
		myQue.offer(str2);
		myQue.offer(str3);
		//myQue.offer(str4);
		boolean test = myQue.offer(str4);
		
		// 테스트(확인)
		System.out.println("test : " + test);
		//--==>> test : true
		
		
		// 테스트(확인)
		//System.out.println(myQue);					//-- 더미
		//--==>> [김정현, 김태완, 임성산, 박제훈]		<< 실제데이터가 아닌 가짜데이터
		//-- 실제 데이터처럼 처리해서는 안된다.
		
		
		System.out.println("값1 : " + (String)myQue.element());
		System.out.println("값2 : " + (String)myQue.element());
		System.out.println("값3 : " + (String)myQue.element());
		//--==>> 값1 : 김정현
		//		 값2 : 김정현
		//	 	 값3 : 김정현
		//-- Queue 자료구조 myQue 에서
		//   요소를 제거하지 않으면서 head 요소 반환
		
		System.out.println();				// 개행
		
		String val;
		
		/*
		// ①
		// peek()
		//-- 큐의 head 요소 반환, 제거 안함.
		//   큐가 empty 일 경우 null 을 반환.
		while (myQue.peek() != null)			// 정현 / 태완 / 성산 / 제훈 / null
		{
			// poll()
			//-- 큐의 head 요소 반환, 제거함.
			//   큐가 empty 일 경우 null 을 반환.
			val = (String)myQue.poll();			// 정현 / 태완 / 성산 / 제훈
			System.out.println("요소 : " + val);
		}
		System.out.println();
		//--==>>요소 : 김정현
		//		요소 : 김태완
		//		요소 : 임성산
		//		요소 : 박제훈
		
		*/	
		/*
		// 테스트			// 앞서 테스트한 Queue 문에서 poll() 메소드로 인해서 다 제거를 했기때문에 결과값이 출력되지 않음.
		while (myQue.poll() != null)			// 정현 / 태완 / 성산 / 제훈 / null
		{
			// poll()
			//-- 큐의 head 요소 반환, 제거함.
			//   큐가 empty 일 경우 null 을 반환.
			val = (String)myQue.poll();			// 정현 / 태완 / 성산 / 제훈
			System.out.println("요소 : " + val);
		}
		System.out.println();
		//--==>> 요소 : 김태완
		//		 요소 : 박제훈
		*/
		
		
		// ②
		/*
		while (true)
		{
			val = (String)myQue.poll();
			
			if (val==null)
				break;
			else
			{
				System.out.println("요소 : " + val);
			}
		
		}
		System.out.println();
		
		//--==>> 요소 : 김정현
		//		 요소 : 김태완
		//		 요소 : 임성산
		//		 요소 : 박제훈
		*/
		
		
		
		// ③
		while (!myQue.isEmpty())
		{
			val = (String)myQue.poll();
			System.out.println("요소 : " + val);
		}
		System.out.println();
		//--==>>
		//요소 : 김정현
		//요소 : 김태완
		//요소 : 임성산
		//요소 : 박제훈

	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/
import java.util.Queue;
import java.util.LinkedList;

public class Test163{
	
		// 정적 문자열 배열 선언 및 초기화
		private static final String[] colors
		 = {"검정","노랑","초록","파랑","빨강","연두"};

		public static void main(String[] args){
		
		// Queue 자료구조 생성
		//-- Queue 인터페이스 기반의 인스턴스를 생성하기 위해서는
		//   new 연산자를 이용하여 Queue 인터페이스를 implements 한
		//   하위 클래스의 생성자를 호출해야 한다.
		
		Queue<String> qu = new LinkedList<String>();
		
		// Queue 자료구조에 colors 배열의 데이터 입력
		
			for (String color : colors)
			qu.offer(color);
		
		// Queue 자료구조 요소 전체 출력
		
		// peek()
		// : 큐의 head 요소를 반환하고 삭제하지 않으며
		//   큐 자료구조가 비어있는 상태가 되면(empty) null 반환
		// poll()
		// : 큐의 head 요소를 반환하고 삭제하며
		//   큐 자료구조가 비어있는 상태가 되면(empty) null 반환
		
			while (qu.peek() != null)
			{
				String Val = (String)qu.poll();
				System.out.println(Val);
				
			}
		
		
	}
}


// 실행 결과
/*
검정
노랑
초록
파랑
빨강
연두
계속하려면 아무 키나 누르십시오 . . .
*//*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

/*
○	Vector(벡터)

	자바의 자료 구조 기능을 제공하는 클래스들 중 가장 기본적인 클래스로
	배열과 비슷하지만 배열과 달리 다른 종류의 데이터 형을 가진
	데이터 요소들을 가질 수 있으며, 데이터가 가득  차면 자동으로 저장 영역을
	확장시키게 된다.
	
	또한, 객체 레퍼런스를 저장하기 때문에
	JDK 1.5 이전에는 자바 기본형 데이터는 저장할 수 없었으나
	JDK 1.5 이후부터는 오토박싱/오토언박싱 기능이 지원되면서
	기본 데이터형도 저장이 가능하게 되었다.
	
	백터 클래스의 기본 구조는
	시퀸스(Sequence) 데이터 구조에 기반하여
	시퀸스 데이터 접근을 순차적인 인덱스 값에 대한 위치로 접근하게 된다.
	따라서 자료구조의 양 끝단에서만 접근이 가능한 큐나
	한쪽 끝에서만 접근이 가능한 스택과 달리
	시퀸스 개념의 인덱스 값을 이용하여 자료구조의 임의의 지점에서
	저장 및 접근이 가능하다.
	
	백터의 시퀸스 구조는
	List 인터페이스를 통해 제공받고 있기 때문에
	List 인터페이스의 모든 메소드를 사용할 수 있다.
	
	- void add(int index, E element)
	- void insertElementAt(E obj int index)
	  주어진 위치에 객체를 저장한다.
	  주어진 위치의 객체부터 오른쪽으로 하나씩 이동한다.
	  
	- void addElement(E obj)
	- boolean add(E e)
	  객체를 벡터 끝에 추가한다.
	 
	- void removeElementAt(int index)
	- E remove(int index)
	  주어진 위치의 객체를 제거한다.
	  제거 후 주어진 위치 다음의 객체부터 하나씩 왼쪽으로 이동한다.
	  E remove(int index) 메소드는 저장되었던 객체를 반환한다.
	  
	- boolean removeElement(Object obj)
	- boolean remove(Object obj)
	  대상 객체를 제거한다.
	  제거 후 주어진 위치 다음의 객체부터 하나씩 왼쪽으로 이동한다.
	  객체가 정상적으로 제거되었다면 true를 반환한다.
	  
	- void removeAllElment()
	- void clear()
	  벡터의 모든 요소를 제거한다.
	  
	- void removeAllElement()
	- void clear()
	  백터의 모든 요소를 제거한다.
	  
	- void setElement(E obj, int index)
	- E set(int index, E element)
	  백터의 index 위치에 주어진 객체를 저장한다.
	  주어진 위치에 저장되어 있던 객체는 소멸한다.( → 덮어쓰기의 개념)
	  
	- E elementAt(int index)
	- E get(int index)
	  주어진 위치에 저장된 객체를 반환한다.
	  
	- Enumeration<E> elements()
	  백터의 모든 요소를 반환한다.
	  
    - int indexOf(object o)
	  주어진 객체가 저장된 위치를 반환한다.
	  존재하지 않을 경우 『음수』를 반환한다.
	  
    - int indexOf(object o, int index)
	  주어진 객체가 저장된 위치를 index 위치부터 찾아서 반환한다.
	  index 위치는 스캔을 시작하는 위치
	  
	- boolean contains(Object o)
	  벡터가 주어진 객체를 포함하고 있는지의 여부를 반환한다.
	  
	- void insureCapacity(int minCapacity)
	  벡터의 용량을 주어진 크기보다 크도록 조절한다.
	  
	-  E firstElement()
	  벡터의 첫 번째 요소의 데이터를 반환한다.
	  
	-  E lastElement()
	  벡터의 마지막 요소의 데이터를 반환한다.
	  
	- void setSize(int newSize)
	 벡터의 크기를 조절한다.
	 주어진 크기가 현재 크기보다 작다면 나머지는 버린다.
	 반대로 주어진 크기가 현재 크기보다 크다면
	 빈 공간은 null 객체로 채우게 된다. (→ 객체를 참조하지 않음을 의미)
	 
    - int cpapcity()
	  현재 벡터의 용량을 반환한다.
	  
	- int size()
	  현재 벡터에 저장된 객체의 갯수(size)를 반환한다.
	  
	- imt trimToSize()
	  벡터의 용량을 저장된 객체의 갯수에 맞도록 최소화한다.
*/

import java.util.Vector;
import java.util.Iterator;

public class Test164{
	
			// 정적 문자열 배열 선언 및 초기화
				private static final String[] colors
				= {"검정","노랑","초록","파랑","빨강","연두"};

	
	public static void main(String[] args){
		
		int i;
		String str;
		
		//Vector(벡터) 자료구조 v 생성
		Vector<Object> v = new Vector<Object>();
		
		// v 라는 벡터 자료구조에 colors 배열에 담겨있는 데이터 담아내기
		// → add()
		for (i=0;i<colors.length;i++)
		{
			v.add(colors[i]);
		}
		
		// 데이터(요소) 추가
		v.addElement("하양");
		
		// firstElemnet()
		str = (String)v.firstElement();
		System.out.println("첫 번째 요소 : " + str);
		//--==>> 첫 번째 요소 : 검정
		
		// get()
		str = (String)v.get(1);
		System.out.println("두 번째 요소 : " + str);
		
		// get()
		str = (String)v.get(0);
		System.out.println("첫 번째 요소 : " + str);
		//--==>> 첫 번째 요소 : 검정
		
		
		// elementAt()
		str = (String)v.elementAt(1);
		System.out.println("두 번째 요소 : " + str);
		//--==>> 두 번째 요소 : 노랑
		
		// lastElement()
		str = (String)v.lastElement();
		System.out.println("마지막 요소 : " + str);
		//--==>> 마지막 요소 : 연두
		
		
		// ※ line 133 데이터 추가 후
		//--==>> 마지막 요소 : 하양
		
		
		// ※ 벡터 자료구조에 요소 추가 시(→ add() / addElement())
		//   인덱스 마지막(가장 끝)의 위치에 추가되는 것을 확인 할 수 있다.
		
		
		
		
		// 전체 요소 출력
		// 『Iterator(이터레이터 or 아이터레이터)』
		// - 『hasNext()』 : 다음 데이터 요소가 있는지 없는지의 여부 확인
		// - 『next()』    : 다음 데이터 요소를 직접적으로 반환
		
		
		Iterator<Object> it = v.iterator();
		
		while (it.hasNext())						//ture ture ture ture ture ture ture
		{
			str = (String)it.next();
			System.out.print(str + " ");			//검정 노랑 초록 파랑 빨강 연두 하양
			
		}
		System.out.println();
		//--==>> 검정 노랑 초록 파랑 빨강 연두
		
		/*
										▼
		----------------------------------
		검정 노랑 초록 파랑 빨강 연두 하양
		----------------------------------
		*/
		
		// ※ line 133 데이터 추가 후
		//--==>> 검정 노랑 초록 파랑 빨강 연두 하양
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// Vector v = new Vector();
//-- 비어있는 Vector 자료구조 v 생성

// Vector v = new Vector(8);
//-- 8 개의 초기 element 를 가진 Vector 자료구조 v 생성
//   이 자료구조를 활용하는 과정에서
//   8 개가 모두 채워지게 되면(모자라게 되면) 자동으로 확장된다.

// Vector v = new Vector(3, 5);
// -- 3 개의 초기 element 를 가진 Vecotr 자료구조 v 생성
//    이 자료구조를 활용하는 과정에서
//    3 개가 모두 채워지게 되면(모자라게 되면) 자동으로 5개 증가(확장)된다.

// ※ 벡터는 데이터 요소로서 정수형, 실수형, 문자열... 등을
//   담아내는 것이 가능하다. (→ 가능해졌다.)
//	 → 데이터 안정성 확보 Check! 

import java.util.Vector;
import java.util.Iterator;

// MyVector 클래스 설계 → Vector 클래스 상속
class MyVector extends Vector<Object>
{
	//생성자 → 사용자 정의 생성자
	MyVector()
	{
		// Vector(슈퍼 클래스) 생성자 호출
		//super();
		// → Vector();
		super(1, 1);
		// → Vector(1, 1);
		//-- 첫 번째 인자 : 주어진 용량(기본 size)
		//   두 번째 인자 : 증가량(증가 size)
	}
	
	void addInt(int i)
	{
		addElement(new Integer(i));
	}
	
	
	void addFloat(float f)
	{
		addElement(new Float(f));
	}
	
	
	void addString(String s)
	{
		addElement(new String(s));
	}
	
	void addCharArray(char[] a)
	{
		addElement(a);
	}
	
	
	void write()
	{
		/*
		Iterator<Object> it = this.iterator();
		while (it.hasNext())
		{
			System.out.println(it.next());
		}
		*/
		
		//--==>> 5
		//		 3.14
		//		 안녕하세요
		//		 [C@6d06d69c
		
		//Object o;
		//int length = size();
		
		// 테스트(확인)
		//System.out.println("벡터 요소 갯수 : " + length);
		//--==>> 벡터 요소 갯수 : 4
		
		/*
		for (int i=0;i<length;i++)
		{
			o = elementAt(i);
			System.out.println(o);
		}
		*/
		//--==>>5
		//		3.14
		//		안녕하세요
		//		[C@6d06d69c
		
		Object o;
		int length = size();
		
		System.out.println("벡터 요소 갯수 : " + length);
		
		for (int i=0;i<length;i++)
		{
			o = elementAt(i);
			
			// ※ 『instanceof』 연산자		check!
			//-- 처리해야 하는 대상의 객체 타입 확인
			
			// 각 요소별 접근 처리
			
			/*
			if (o instanceof char[])
			{
				System.out.println("문자배열");
			}
			else if (o instanceof String)
			{
				System.out.println("문자열");
			}
			else if (o instanceof Integer)
			{
				System.out.println("정수형");
			}
			else if (o instanceof Float)
			{
				System.out.println("실수형");
			}
			else
			{
				System.out.println("타입 확인 불가!");
			}
			*/
			
			if (o instanceof char[])
			{
				//System.out.println("문자배열 : " + o);
				System.out.println("문자배열 : " + o.toString());
				
				// 문자 배열의 각 요소에 따로 접근
				/*
				for (char ch : (char[])o)
				{
					System.out.print(ch);
				}
				System.out.println();
				*/
				System.out.println("문자배열 : " + String.copyValueOf((char[])o);
			}
			else if (o instanceof String)
			{
				System.out.println("문자열 : " + o);
			}
			else if (o instanceof Integer)
			{
				System.out.println("정수형 : " + o);
			}
			else if (o instanceof Float)
			{
				System.out.println("실수형 : " + o);
			}
			else
			{
				System.out.println("타입 확인 불가!");
			}
		}
	}
}



public class Test165{
	public static void main(String[] args){
		
		//MyVector 인스턴스 생성
		MyVector v = new MyVector();
		
		//주요 변수 선언 및 초기화
		int digit = 5;
		float real = 3.14f;
		String s = new String("안녕하세요");
		char[] letters = {'s','t','u','d','y'};
		
		v.addInt(digit);				//-- 벡터 자료구조에 정수 저장
		v.addFloat(real);				//-- 벡터 자료구조에 실수 저장
		v.addString(s);					//-- 벡터 자료구조에 문자열 저장
		v.addCharArray(letters);		//-- 벡터 자료구조에 문자 배열 저장			//check
		
		v.write();
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

import java.util.Vector;
import java.util.Collections;

public class Test166{
	
	
	// 정적 문자열 배열 선언 및 초기화
	private static final String[] colors
	= {"검정","노랑","초록","파랑","빨강","연두"};

	public static void main(String[] args){
		
		// 벡터 자료구조 v 생성
		Vector<String> v = new Vector<String>();
		
		// 벡터 자료구조 v 에 colors 배열 데이터를 요소로 추가
		for (String color : colors)
		{
			v.add(color);
		}
		
		// 접근 및 확인
		System.out.println("첫 번째 요소 : " + v.elementAt(0));
		System.out.println("두 번째 요소 : " + v.elementAt(1));
		System.out.println("마지막 요소 : " + v.lastElement());
		System.out.println("요소의 갯수 : " + v.size());
		//--==>> 첫 번째 요소 : 검정
		//		 두 번째 요소 : 노랑
		//		 마지막 요소 : 연두
		//		 요소의 갯수 : 6
		
		// ○ 첫 번째 요소를 "하양"으로 변경
		//		→ set()
		v.set(0, "하양");
		//-- "검정"에서 "하양"으로 덮어쓰기
		
		System.out.println("첫 번쨰 요소 : " + v.firstElement());
		//--==>> 첫 번쨰 요소 : 하양
		System.out.println("두 번쨰 요소 : " + v.get(1));
		//--==>> 두 번쨰 요소 : 노랑
		System.out.println("요소의 갯수 : " + v.size());
		//--==>> 요소의 갯수 : 6
		
		
		// ○ 첫 번째 요소에 "주황" 추가
		//	 → insertElementAt()
		v.insertElementAt("주황", 0);
		
		// ○ 전체 출력
		System.out.print("전체 출력 : ");
		for (String str : v)
			System.out.print(str + " ");
		System.out.println();
		//--==>> 전체 출력 : 주황 하양 노랑 초록 파랑 빨강 연두
		
		
		// ○ 오름차순 정렬
		Collections.sort(v);
		
		// ○ 오름차순 정렬 후 전체 출력
		System.out.print("오름차순 정렬 후 전체 출력 : ");
		for (String str : v)
			System.out.print(str + " ");
		System.out.println();
		//--==>> 오름차순 정렬 후 전체 출력 : 노랑 빨강 연두 주황 초록 파랑 하양
		
		// ○ 검색
		// Collections.binarySearch();
		// 검색 기능 수행.
		// 단, 오름차순 정렬이 수행되어 있는 자료에 대해서만 사용이 가능하다. check
		// 검색 결과가 존재하지 않을 경우 『음수』를 반환한다.
		
		int idxBlue = Collections.binarySearch(v, "파랑");
		System.out.printf("파랑 : %d번째 인덱스에 위치하고 있다. \n",idxBlue);
		//--==>> 파랑 : 5번쨰 인덱스에 위치하고 있다.
		
		// ○ 내림차순 정렬
		Collections.sort(v, Collections.reverseOrder());
		
		// ○ 확인 - 내림차순 정렬 후 전체 출력
		System.out.print("내림차순 정렬 후 전체 출력 : ");
		for (String str : v)
			System.out.print(str + " ");
		System.out.println();
		//--==>> 내림차순 정렬 후 전체 출력 : 하양 파랑 초록 주황 연두 빨강 노랑
		
		
		// ※ 내림차순 정렬 후 검색 테스트
		int box = Collections.binarySearch(v, "파랑");
		System.out.printf("파랑 : %d번째 인덱스에 위치하고 있다. \n",box);
		//--==>> 파랑 : -8번째 인덱스에 위치하고 있다.
		//				『-』 → 검색 결과 없음 → 찾지 못했음
		
		
		
		// ※ 내림차순 정렬 후 검색 테스트
		box = Collections.binarySearch(v, "파랑", Collections.reverseOrder());
		System.out.printf("파랑 : %d번째 인덱스에 위치하고 있다. \n",box);
		//--==>> 파랑 : 1번째 인덱스에 위치하고 있다.
		
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// 검색 및 삭제

import java.util.Vector;

public class Test167{
	
	// 정적 문자열 배열 선언 및 초기화
	private static final String[] colors
	= {"검정","노랑","초록","파랑","빨강","연두"};
	
	
	public static void main(String[] args){
		
		// 벡터 자료구조 v 생성
		Vector<String> v = new Vector<String>();
		
		// 벡터 자료구조 v 에 colors 배열 데이터를 요소로 추가
		for (String color : colors)
			v.add(color);
		
		// 벡터 자료구조 v의 전체 요소 출력
		System.out.print("전체 요소 출력 : ");
		for (String str : v)
			System.out.print(str + " " );
		System.out.println();
		
		String s1 = "보라";
		
		int i = v.indexOf(s1);
		System.out.println(s1 + " → index 위치 : " + i);
		//--==>> 보라 → index 위치 : -1
		//				→ 반환 결과 음수 → 존재하지 않음
		
		String s2 = "노랑";
		
		// contains()
		// 『v.contains(s)』
		// -- 벡터 자료구조 v에 찾고자 하는 s 가 포함되어 있다면...
		// → index 위치 확인
		
		if (v.contains(s2))
		{
			i = v.indexOf(s2);
			System.out.println(s2 + " → index 위치 : " + i);
			
			// ① 존재하는지의 여부를 확인하고 → line 40
			// ② 어디에 있는지를 확인하고	   → line 42
			// ③ 확인했으면 제거해라(삭제해라) → line 48
			v.remove(i);
		}
		System.out.println();

		// 찾아서 삭제한 후 전체 요소 출력
		System.out.print("삭제 후 전체요소 출력 : ");
		for (String str : v)
			System.out.print(str + " " );
		System.out.println();
		
	}
}
/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// ※ 자료구조 객체 선언 및 생성 시
//	 사용자 정의 클래스 활용
//   → 사용자 정의 자료형으로 활용


//  클래스 → 사용자 정의 자료형으로 활용

import java.util.Vector;

class UserData
{
	//주요 속성 구성 → 주요 변수 선언(멤버 변수)
	private String name;			//--이름
	private int age;				//--나이
	
	
	
	public String getName()
	{
		return name;
	}
	
	public int getAge()
	{
		return age;
	}
	
	public void setName(String name)
	{
		this.name = name;
	}
	
	public void setAge(int age)
	{
		this.age = age;
	}
	
	// 생성자(매개변수 2개인 생성) → 사용자 정의 생성자
	public UserData(String name, int age)
	{
		this.name = name;
		this.age = age;
	}
	
	// ※ 사용자 정의 생성자가 구성될 경우
	//	 default 생성자가 자동으로 삽입되지 않기 때문에
	//   default 생성자 형태의 생성자를 사용자 정의 생성자로
	//   추가 구성하게 되는 것이 일반적인 클래스 설계 과정
	//   (반드시 설계해야 한다는 문법적인 규칙은 없음)
	
	//  생성자(매개변수 없는 default 생성자 형태의 생성자) → 사용자 정의 생성자
	public UserData()
	{
		//this("", 0);
		name = "";			//this.name = "";
		age = 0;			//this.age = 0;
		
	}
	
	
}
public class Test168{
	public static void main(String[] args){
		
		// 벡터 자료구조 생성
		//Vector v = new Vector();
		Vector<UserData> v = new Vector<UserData>();
		
		// 벡터 자료구조 v 에
		// 임성산 3세 / 공찬민 17세 / 정영훈 49세
		// 담아내기
				
		//내가 한 풀이
		/*
		UserData num1 = new UserData("임성산",3);
		UserData num2 = new UserData("공찬민",17);
		UserData num3 = new UserData("정영훈",49);
		
		v.add(num1);
		v.add(num2);
		v.add(num3);
		
		for (UserData ud : v)
		{
			System.out.print(ud.getName() + " " + ud.getAge());
		}
		*/
		
		// ③
		v.add(new UserData("임성산", 3));
		v.add(new UserData("공찬민", 17));
		v.add(new UserData("정영훈",49));
		
		// 벡터 자료구조 v 에 담긴 내용(요소) 전체 출력하기
		// 실행 예)
		// 이름: 임성산, 나이:3세
		// 이름: 공찬민,  나이:17세
		// 이름: 정영훈,  나이:49세
		
		for (UserData ud : v)
		{
			System.out.println("이름 : " + ud.getName() + ", " + "나이 : " + ud.getAge() );
			//--==>>이름 : 임성산, 나이 : 3
			//		이름 : 공찬민, 나이 : 17
			//		이름 : 정영훈, 나이 : 49
			//		계속하려면 아무 키나 누르십시오 . . .
		}
		System.out.print("-------------------------------------------------------------");
		
		//②
		for (int i=0;i<v.size();i++)
		{
			System.out.printf("이름:%s, 나이:%d세\n",v.elementAt(i).getName(),v.elementAt(i).getAge());
		}
		
		//③
		for (int i=0;i<v.size();i++)
		{
			System.out.printf("이름:%s, 나이:%d세\n",v.get(i).getName(),v.get(i).getAge());
			//--==>> 이름:임성산, 나이:3세
			//	 	 이름:공찬민, 나이:17세
			//		 이름:정영훈, 나이:49세
		}
		
		//④
		for (Object temp : v)
		{
			System.out.printf("이름:%s, 나이:%d세\n",((UserData)temp).getName(),((UserData)temp).getAge());
			//-->>이름:임성산, 나이:3세
			//	  이름:공찬민, 나이:17세
			//	  이름:정영훈, 나이:49세
		}
		
		
		

	}
}
//Test169 클래스를 완성하여 다음 기능을 가진 프로그램을 구현한다.

/*
실행 예)

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 1

1번째 요소 입력 : 김정현
1번째 요소 입력 성공 !
요소 입력 계속(Y/N) : y

2번째 요소 입력 : 김태완
2번째 요소 입력 성공 !
요소 입력 계속(Y/N) : N

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 2

[요소 전체 출력]
김정현
김태완
전체 출력 완료!

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 3

>> 검색할 요소 입력 : 임성산

[검색 결과 출력]
항목이 존재하지 않습니다.

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 3

>> 검색할 요소 입력 : 김정현

[검색 결과 출력]
항목이 존재합니다.

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 4

>> 삭제할 요소 입력 : 박제훈

[삭제 결과 출력]
항목이 존재하지 않아 삭제할 수 없습니다.

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 4

>> 삭제할 요소 입력 : 김정현

[삭제 결과 출력]
김정현 항목이 삭제되었습니다.

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 5

>> 변경할 요소 입력 : 김믿음

[변경 결과 출력]
변경할 대상이 존재하지 않습니다.

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 5

>> 변경할 요소 입력 : 김태완
>> 수정할 내용 입력 : 박지우

[변경 결과 출력]
변경이 완료되었습니다.

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 2

[요소 전체 출력]
박지우
요소 전체 출력 완료!

	====[메뉴 선택]====
	1. 요소 추가
	2. 요소 출력
	3. 요소 검색
	4. 요소 삭제
	5. 요소 변경
	6. 종료
	===================
>> 메뉴 선택(1~6) : 6

프로그램 종료!
계속하려면 아무 키나 누르세요...

*/


import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Vector;

class Menus			// → 완료
{
	public static final int E_ADD = 1;				//--요소 추가
	public static final int E_DISP = 2;				//--요소 출력
	public static final int E_FIND = 3;				//--요소 검색
	public static final int E_DEL = 4;				//--요소 삭제
	public static final int E_CHA = 5;				//--요소 변경
	public static final int E_EXIT = 6;				//--종료
}




public class Test169{
	
	// 주요 속성 구성 → 완료
	private static final Vector<Object> vt;					// 자료구조
	private static BufferedReader br;						// 입력 시 활용
	private static Integer sel;								// 선택값
	private static String con;								// 계속진행여부
	
	// static 초기화 블럭 → 완료
	static 
	{
		//Vector 자료구조 vt 생성
		vt = new Vector<Object>();
		
		//BufferedReader 인스턴스 생성
		br = new BufferedReader(new InputStreamReader(System.in));
		
		// 사용자 입력값 초기화
		sel = 1;
		con = "Y";
		
	}
	
	// 메뉴 출력 메소드
	
	public static void menuDisp() throws IOException
	{
		System.out.print("====[메뉴 선택]====\n");
		System.out.println("1. 요소 추가");
		System.out.println("2. 요소 출력");
		System.out.println("3. 요소 검색");
		System.out.println("4. 요소 삭제");
		System.out.println("5. 요소 변경");
		System.out.println("6. 종료");
		System.out.println("====================");
		System.out.print("메뉴 선택(1~6) : ");
	}
	
	// 메뉴 선택 메소드
	public static void menuSelect() throws IOException, NumberFormatException
	{
		sel = Integer.parseInt(br.readLine());
		
	}
	
	// 선택된 메뉴 실행에 따른 기능 호출 메소드
	public static void menuRun() throws IOException
	{
		switch (sel)
		{
		case 1:addElement(); break;
		case 2:dispElement(); break;
		case 3:findElement(); break;
		case 4:delElement(); break;
		case 5:chaElement(); break;
		case 6:exit();
		
		}
	}
	
	/*
	// 자료구조에 요소 추가(입력) 메소드
	public static void addElement() throws IOException
	{
		//1번째 요소 입력 : 김정현
		//1번째 요소 입력 성공 !
		//요소 입력 계속(Y/N) : y
		
		while (con.equals("Y"))
		{
		System.out.printf(">>%d번째 요소 입력 : ",vt.size()+1);
		String name1 = br.readLine();
		System.out.printf(">>%d번째 요소 입력 성공!\n",vt.size() +1);
		vt.add(name1);
		System.out.print("요소 입력 계속(Y/N) : ");
		con = br.readLine();
		}
		con = "Y";	
	}
	*/
	
	// 자료구조에 요소 추가(입력) 메소드
	public static void addElement() 
	{
		//1번째 요소 입력 : 김정현
		//1번째 요소 입력 성공 !
		//요소 입력 계속(Y/N) : y
		try
		{
			while (con.equals("Y"))
			{
			System.out.printf(">>%d번째 요소 입력 : ",vt.size()+1);
			String name1 = br.readLine();
			System.out.printf(">>%d번째 요소 입력 성공!\n",vt.size() +1);
			vt.add(name1);
			System.out.print("요소 입력 계속(Y/N) : ");
			con = br.readLine();
			}
			con = "Y";		
		}
		catch (Exception n)
		{
			System.out.print(n.toString());
		}
		
	}
	
	//자료구조 전체 요소 출력 메소드
	public static void dispElement()
	{
		//[요소 전체 출력]
		//김정현
		//김태완
		//전체 출력 완료!
		System.out.println("[요소 전체 출력]");
		for (Object ob : vt)
			System.out.println(ob);
		System.out.println("전체 출력 완료 !");
	}
	
	//자료구조 내 요소 검색 메소드
	public static void findElement() throws IOException
	{
		//>> 검색할 요소 입력 : 임성산
		//[검색 결과 출력]
		//항목이 존재하지 않습니다.
		
		System.out.print("검색할 요소 입력 : ");
		String name2 = br.readLine();
		for (int i=0;i<vt.size();i++)
		{
			if (vt.elementAt(i).equals(name2))
			{
				System.out.println("[검색 결과 출력]");
				System.out.println("항목이 존재합니다.");
				return;
			}
		}
				System.out.println("[검색 결과 출력]");
				System.out.println("항목이 존재하지 않습니다.");
		
		
	}
	
	
	//자료구조 내 요소 삭제 메소드
	public static void delElement() throws IOException
	{
		
		//>> 삭제할 요소 입력 : 박제훈
		//	 [삭제 결과 출력]
		//	 항목이 존재하지 않아 삭제할 수 없습니다.

		
		System.out.print("검색할 요소 입력 : ");
		String name2 = br.readLine();
		for (int i=0;i<vt.size();i++)
		{
			if (vt.elementAt(i).equals(name2))
			{
				System.out.println("[삭제 결과 출력]");
				System.out.printf("%s항목이 삭제되었습니다.",vt.get(i));
				System.out.println();
				vt.remove(i);
			}
			else
			{
				System.out.println("[삭제 결과 출력]");
				System.out.println("항목이 존재하지 않아 삭제할 수 없습니다.");
			}
		}
		
	}
	
	
	// 자료구조 내 요소 수정(변경) 메소드
	public static void chaElement() throws IOException
	{
		//>> 변경할 요소 입력 : 김믿음
		//	 [변경 결과 출력]
		//	 변경할 대상이 존재하지 않습니다.

		System.out.print("변경할 요소 입력 : ");
		String name2 = br.readLine();
		for (int i=0;i<vt.size();i++)
		{
			if (vt.elementAt(i).equals(name2))
			{
				System.out.print("수정할 요소 입력 : ");
				name2 = br.readLine();
				System.out.println("[변경 결과 출력]");
				System.out.println("변경이 완료되었습니다.");
				vt.set(i, name2);
				return;
			}
				
		}
				System.out.println("[변경 결과 출력]");
				System.out.println("변경할 대상이 존재하지 않습니다.");
		
	}
	
	//프로그램 종료 메소드
	public static void exit()
	{
		System.out.println("\n프로그램 종료!");
		System.exit(-1);
	}
	
	
	
	
	// main() 메소드
	public static void main(String[] args)throws IOException, NumberFormatException
		{
		do
		{
			menuDisp();
			menuSelect();
			menuRun();
			
		}
		while (true);
		
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

/*
○	Enumertation 과 Iterator 인터페이스

	Collection Framework 에는 
	Enumeration 과 Iterator 라는 인터페이스가 있다.
	사전적인 의미로는 반복, 순환 이라는 의미를 가지고 있으며
	어떤 객체들의 모임이 있을 때,
	이 객체들을 특정 순서에 의해 하나씩 접근하여 사용하기 위한
	인터페이스라고 할 수 있다.
	
	- java.util.Enumertaion<E> 인터페이스
	  : 이 인터페이스는 단지 두 개의 메소드만을 제공하며
	   『hasMoreElements()』메소드를 통해
	   인터페이스 안에 다음 요소가 있는지에 대한 질의를 수행한다.
	   true 가 반환되었다면 다음 인덱스에 요소가 존재한다는 의미이며
	   『nextElement()』 메소드로 다음 요소를 꺼내어 사용하면 되는 것이다.
	   
	ex) // 백터 자료구조 v 에 저장된 모든 요소 출력
		for (Enumeration e = v.elements();e.hasMoreElements():)
		{
			System.out.println(e.nextElements())
		}
		
	- java.util.Iterator<E> 인터페이스 
	  : Enumeration 과의 차이점은 단지 『remove()』 메소드가 추가된 것 뿐이다.
	  Iterator 가 가지고 있는 『hasNext()』와 『next()』메소드는
	  이름만 약간 다를 뿐 Enumeration 인터페이스가 가지고 있는
	  『hasMoreElements()』와 그리고 『nextElement()』와
	  정확히 일치하는 기능을 수행한다.
	  Iterator 는 JDK 1.2 부터 추가로 지원되었다.

*/

import java.util.Vector;
import java.util.Enumeration;
import java.util.Iterator;
public class Test170{
	public static void main(String args[]){
		
		// 벡터 자료구조 v 인스턴스 생성
		Vector<String> v = new Vector<String>();
		
		// 벡터 자료구조 v 에 요소 추가
		v.add("Java");
		v.add("Orcle");
		v.add("Jsp");
		v.add("Servlet");
		v.add("Spring");
		
		// ① Enumeration
		//    - hasMoreElements()
		//    - nextElement()
		Enumeration<String> e = v.elements();
		while (e.hasMoreElements())
		{
			System.out.println(e.nextElement());
		}
		System.out.println();
		//--==>> Java
		//		 Orcle
		//		 Jsp
		//		 Servlet
		//		 Spring
		
		System.out.println("------------------------------------------------------------");
		
		
		// ② Iterator 
		//    - hasNext()
		//    - next()
		Iterator<String> it = v.iterator();
		while (it.hasNext())
		{
			System.out.println(it.next());
		}
		System.out.println();
		//--==>> Java
		//		 Orcle
		//		 Jsp
		//		 Servlet
		//		 Spring
	
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// List → Vector, ArrayList, LinkedList, ...
// · 순서 있음
// · 배열과 유사
// · 중복 허용

/*
○	ArryList 클래스

	- ArrayList 와 Vector 클래스는
	  List 를 크기 변경이 가능한 배열로 구현한 것으로
	  차이점은, Vector 클래스의 객체는 기본적으로 동기화 되지만,
	  ArrayList 는 그렇지 않다는 점이다.
	  
	- 비동기화 컬렉션은 동기화 컬렉션보다 더 나은 성능을 제공하며
	  스레드들이 컬렉션을 공유하지 않는 프로그램에서는
	  일반적으로 ArrayList 를 Vector 보다 더 선호하며,
	  ArrayList 는 동기화를 고려하지 않은 Vector 처럼 동작함으로써
	  스레드 동기화에 따르는 부담을 가지지 않기 떄문에
	  Vecotr 보다 더 빠르게 실행된다.
	  
	- null을 포함한 모든 요소를 허용하며
	  List 인터페이스를 구현하는 것 외에 리스트에 격납하기 위해
	  내부적으로 사용되는 배열의 사이즈를 조작하는 메소드를 제공한다.
*/

import java.util.ArrayList;
import java.util.Vector;
import java.util.List;
import java.util.ListIterator;

public class Test171{
	public static void main(String args[]){
		
		//List 자료구조 list 생성
		//ArrayList<String> list1 = new Array<String>();
		//Vector<String> list1 = new Vector<String>();
		//List<String> list1 = new Vector<String>();
		List<String> list1 = new ArrayList<String>();
		
		
		// list1 자료구조에 요소 추가
		// → add()
		list1.add("귀멸의 칼날");
		list1.add("중경삼림");
		list1.add("대도시의사랑법");
		
		// List 자료구조 list2 생성
		//List<String> list2 = new ArrayList<String>();
		List<String> list2 = new ArrayList<String>(list1);
		
		// list2 자료구조에 요소 추가
		// → add()
		list2.add("청설");
		list2.add("부끄러");
		
		//List 자료구조 list3 생성
		List<String> list3 = new ArrayList<String>();
		
		
		//list3 자료구조에 list2 의 전체 요소 추가
		// → addAll()
		list3.addAll(list2);
		
		
		
		// list3 자료구조의 "청설" 앞에 "어바웃타임" 추가
		
		// ① "청설" 찾기 → indexOf() → 위치 인덱스 반환
		int n = list3.indexOf("청설");
		
		// 테스트(확인)
		//System.out.println("n : "+ n);
		//--==>>n : 3
		
		// ② "청설" 찾은 인덱스 위치에 "어바웃타임" 삽입
		//			 →add()
		
		list3.add(n, "어바웃타임");
		
		
		
		
		// 출력 → 더미 데이터 확인
		System.out.println("=======================================================");
		System.out.println(list1);
		System.out.println(list2);
		System.out.println(list3);
		System.out.println("=======================================================");
		
		// 출력 → ListIterator 를 활용하여 출력(→ listIterator()) 메소드를 활용하여 출력
		ListIterator<String> li =  list3.listIterator();
		
		while (li.hasNext())
		{
			System.out.print(li.next() + " ");
		}
		System.out.println();
		//--==>> 귀멸의 칼날 중경삼림 대도시의사랑법 어바웃타임 청설 부끄러
		
		
		// 출력 → ListIterator 를 활용하여 역순으로 접근
		while (li.hasPrevious())
		{
			System.out.print(li.previous() + " ");
		}
		System.out.println();
		//--==>> 부끄러 청설 어바웃타임 대도시의사랑법 중경삼림 귀멸의 칼날
		/*
															←←←←▼
		---------------------------------------------------------
		귀멸의칼날 중경삼림 대도시의사랑법 어바웃타임 청설 부끄러
		---------------------------------------------------------
		*/
		
		
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

/*
○	List 인터페이스
	- 순서가 있음, 배열과 유사, 중복을 허용
	- 주요 구현 클래스
	  · Vector(동기화 지원)
  	  · ArrayList(동기화 지원하지 않음)
  	  · LinkedList(체인, 링크, 결합, 큐)
	  
*/

import java.util.ArrayList;
import java.util.List;
import java.util.Iterator;
import java.util.ListIterator;


public class Test172{
	public static void main(String[] args){
		// List 자료구조 list 생성
		List<String> list = new ArrayList<String>();
		
		list.add("서울");
		list.add("부산");
		list.add("인천");
		list.add("대구");
		list.add("광주");
		list.add("대전");
		list.add("울산");
		list.add("세종");
		
		// 출력 → 더미 확인
		System.out.println(list);
		//--==>> [서울, 부산, 인천, 대구, 광주, 대전, 울산, 세종]
		
		// 요소의 갯수 확인
		System.out.println("전체 갯수 : " + list.size());
		//--==>> 전체 갯수 : 8
		
		
		
		// 첫 번째 요소만 출력
		System.out.println("첫 번쨰 요소 : "  + list.get(0));
		//--==>> 첫 번쨰 요소 : 서울
		
		// 마지막 요소만 출력
		System.out.println("마지막 요소 : " + list.get(list.size()-1));
		//--==>> 마지막 요소 : 세종
		
		// 처음 위치에 "한국" 추가
		list.add(0, "한국");
		// 출력 → 더미 확인
		System.out.println(list);
		//--==>> [한국, 서울, 부산, 인천, 대구, 광주, 대전, 울산, 세종]
		
		// 처음 위치의 데이터(요소)를 "대한민국"으로 변경
		list.set(0, "대한민국");
		// 출력 → 더미확인
		System.out.println(list);
		//--==>> [대한민국, 서울, 부산, 인천, 대구, 광주, 대전, 울산, 세종]
		
		
		// "서울" 요스의 존재여부 확인
		if (list.contains("서울"))
		{
			System.out.println("서울이 존재합니다.");
		}
		System.out.println();
		//--==>> 서울이 존재합니다.
		
		
		// "서울"이 몇 번쨰 인덱스에 위치하는지 확인
		
		int n = list.indexOf("서울");
		System.out.println("서울의 위치 : " + n);
		//--==>> 서울의 위치 : 1 
		
		// "대한민국"지우기
		//list.remove("대한민국");
		list.remove(0);
		
		// 출력 → 더미 확인
		System.out.println(list);
		//--==>> [서울, 부산, 인천, 대구, 광주, 대전, 울산, 세종]
		
		//개행
		System.out.println();
		
		// list의 전체 요소 출력
		System.out.println("전체 출력 ... ①");
		for (int idx=0;idx<list.size();idx++)
		{
			System.out.print(list.get(idx) + " " );
			
		}
		System.out.println();
		
		
		//--==>> 전체 출력... ①
		//		 서울 부산 인천 대구 광주 대전 울산 세종
		
		
		
		// list의 전체요소 역순 출력
		System.out.println("\n역순 출력 ... ②");
		for (int idx=list.size()-1;idx>=0;idx-- )
		{
			System.out.print(list.get(idx) + " " );
		}
		System.out.println();
		
		
		// list 의 전체 요소 출력
		System.out.println("전체 출력 ... ②");
		for (String str : list)
		{
			System.out.print(str + " " );
		}
		System.out.println();
		
		
		
		// list 의 전체 요소 출력
		System.out.println("전체 출력 ... ③");
		Iterator<String> it = list.iterator();
		while (it.hasNext())
		{
			String str = it.next();
			System.out.print(str + " ");
		}
		System.out.println();
		
		
		// list 의 전체 요소 출력
		System.out.println("전체 출력 ... ④");
		ListIterator<String> li = list.listIterator();
		while (it.hasNext())
		{
			System.out.print(li.next() + " " );
		}
		System.out.println();
		
		

		// list 의 전체 요소 역순 출력
		System.out.println("전체 출력 ... ④");
		while (li.hasPrevious())
		{
			String str = li.previous();
			System.out.print(str + " ");
		}
		System.out.println();
		
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// List → String[] : List.toArray()
// String[] → List : Arrays.asList()

import java.util.List;
import java.util.ArrayList;
import java.util.Arrays;

public class Test173{
	public static void main(String[] args){
		
		// List 자료구조 mList 인스턴스 생성
		List<String> mList = new ArrayList<String>();
		
		// List 자료구조 mList 에 요소 추가
		mList.add("1");
		mList.add("2");
		mList.add("3");
		
		
		// check
		// List → String[]
		// mList.toArray(new String[100])
		String[] sArrays = mList.toArray(new String[mList.size()]);
		
		for (String str : sArrays)
		{
			System.out.print(str);
		}
		System.out.println();
		//--==>> 123
		
		// check
		// String[] → List
		// Arrays.asList();
		List<String> mNewList = Arrays.asList(sArrays);
		// ※ 『Arrays.asList()』의 반환 자료형은 『List』
		
		for (String str : mNewList)
		{
			System.out.print(str + " ");
		}
		System.out.println();
		//--==>> 1 2 3
	}
	
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// Set → HashSet, TreeSet
// · 순서 없음
// · 중복을 허용하지 않는 구조(기본)

/*
○	HashSet<E> 클래스

	java.util.HashSet<E> 클래스는
	Set 인터페이스를 구현하는 클래스로
	순서의 개념이 아니라 집합의 개념으로 이해해야 하는 자료구조이다.
	이로 인해 데이터의 중복을 허용하지 않는다.
	또한, 동기화를 지원하지 않는다.
*/

import java.util.Set;
import java.util.HashSet;


public class Test174
{
	public static void main(String[] args)
	{
		
		// Set 자료구조 dog 생성
		//Set<String> dog = new Set<String>();
		Set<String> dog = new HashSet<String>();
		
		// Set 자료구조 dog에 요소 추가
		dog.add("비숑");
		dog.add("골든리트리버");
		dog.add("사모예드");
		dog.add("진돗개");
		dog.add("말티즈");
		dog.add("시바견");
		
		// Set 자료구조 dog 요소 전체 출력
		System.out.print("전체 요소 : ");
		for (String str : dog)
		{
			System.out.print(str + " ");
		}
		System.out.println();
		//--==>> 전체 요소 : 진돗개 골든리트리버 시바견 비숑 사모예드 말티즈
		//		 순서가 의미 없는 자료구조이기 떄문에
		//		 데이터의 입력 순서와 자료구조의 요소 격납 순서가
		//		 상관 관계 없이 구성되어 있는 것을 관찰 및 확인
		
		
		// 데이터(요소) 추가
		dog.add("포메라니안");
		dog.add("치와와");
		dog.add("스피치");
		dog.add("푸들");
		
		dog.add("스피치");
		dog.add("스피치");
		dog.add("스피치");
		dog.add("스피치");
		dog.add("스피치");
		dog.add("말티즈");
		dog.add("말티즈");
		dog.add("말티즈");
		dog.add("말티즈");
		dog.add("말티즈");
		dog.add("진돗개");
		dog.add("진돗개");
		dog.add("진돗개");
		dog.add("진돗개");
		dog.add("진돗개");
		dog.add("시바견");
		dog.add("시바견");
		dog.add("시바견");
		dog.add("시바견");
		
		
		
		
		
		// 요소 추가 후 데이터 출력
		System.out.print("추가 후 : ");
		for (String str : dog)
		{
			System.out.print(str + " ");
		}
		System.out.println();
		//--==>> 추가 후 : 진돗개 골든리트리버 포메라니안 스피치 시바견 푸들 치와와 비숑 사모예드 말티즈
		
		//		※ 같은 데이터가 추가되는 순서와 상관없이 목록(요소들)이 구성되어 있으며
		//		  같은 데이터가 여러반 반복되어 추가될 경우
		//		  이들 중 하나만 유효한 데이터로 구성되는것을 확인할 수 있다.
		//	      (아무리 추가해도 한 번만 출력 됨 → 하나만 요소로 구성되어 있음)
		
		//		※ 또한, 자료구조의 특성 상
		//		  중복 데이터를 허용하지 않는다고 해서
		//		  중복된 데이터를 추가할 경우
		//		  에러가 발생한다는 의미는 아니라는 것도 확인할 수 있다.
		
		
	}

}
/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// Set → HashSet, TreeSet
// · 순서 없음
// · 중복을 허용하지 않는 구조(기본)


/*
○	TreeSet<E> 클래스

	java.util.TreeSet<E> 클래스는
	Set 인터페이스를 상속한 SortedSet 인터페이스를 구현한 클래스로
	데이터를 추가하면 데이터들이 자동으로 오름차순 정렬이 된다.
*/


import java.util.TreeSet;
import java.util.Iterator;
import java.util.Comparator;
import java.util.Arrays;

public class Test175{
	public static void main(String[] args){
		
		// TreeSet 자료구조 set 인스턴스 생성
		TreeSet<String> set = new TreeSet<String>();
		
		// TreeSet 자료구조 set에 요소 추가
		// → add()
		set.add("귀멸의칼날");
		set.add("슬램덩크");
		set.add("궁");
		set.add("원피스");
		set.add("블리치");
		set.add("천원돌파 그렌라간");
		set.add("주술회전");
		set.add("블루록");
		set.add("나루토");
		set.add("스파이패밀리");
		set.add("장송의프리렌");
		
		
		// Iterator 를 활용하여 set 요소 전체 출력
		
		Iterator<String> it = set.iterator();
		
		while (it.hasNext())
		{
			System.out.print(it.next() + " ");
		}
		System.out.println();
		//--==>> 궁 귀멸의칼날 나루토 블루록 블리치 스파이패밀리 슬램덩크 원피스 장송의프리렌 주술회전 천원돌파 그렌라간
		//-- 요소를 문자열로 구성하여 적재할 경우
		//	 가나다순 → 문자열 오름차순 정렬 확인
		
		
		// TreeSet 자료구조 set2 인스턴스 생성
		//TreeSet<GradeDTO> set2 = new TreeSet<GradeDTO>();
		//
		//						↓
		// MyComparator 클래스를 생성하여
		// compare() 메소드를 재정의 한후 다시 구성
		TreeSet<GradeDTO> set2 = new TreeSet<GradeDTO>(new MyComparator<GradeDTO>());
		
		// TreeSet 자료구조 set2에 요소 추가
		set2.add(new GradeDTO("2409123", "윤영식", 90,80,70));
		set2.add(new GradeDTO("2409225", "곽유진", 91,81,71));
		set2.add(new GradeDTO("2409332", "박세진", 88,78,68));
		set2.add(new GradeDTO("2409156", "정승민", 70,60,50));
		set2.add(new GradeDTO("2409133", "이은솔", 99,88,77));
		set2.add(new GradeDTO("2409452", "안석창", 56,86,96));
		
		
		// Iterator 를 활용하여 set2 요소 전체 출력
		/*
		Iterator<GradeDTO> it2 = set2.iterator();
		
		while (it2.hasNext())
		{
			System.out.print(it2.next() + " ");
		}
		*/
		
		
		// MyComparator 클래스를 생성하여
		// compare() 메소드를 재정의한 후 다시 구성
		/*
		Iterator<GradeDTO> it2 = set2.iterator();
		
		while (it2.hasNext())
		{
			System.out.print(it2.next() + " ");
		}
		*/
		//--==>> 객체 자체를 직접 출력하는 것이 아니라
		// 객체가 갖고있는 속성에 접근하여 출력할 수 있도록 처리
		Iterator<GradeDTO> it2 = set2.iterator();
		
		while (it2.hasNext())
		{
			GradeDTO dto = it2.next();
			System.out.printf("%7s %7s %4d %4d %4d %6d\n"
				,dto.getHak(), dto.getName()
				,dto.getKor(), dto.getEng(), dto.getMat()
				, dto.getTot());
				
				// 학번기준(오름차순)
				//--==>>2409123     윤영식   90   80   70    240
				//		2409133     이은솔   99   88   77    264
				//		2409156     정승민   70   60   50    180
				//		2409225     곽유진   91   81   71    243
				//		2409332     박세진   88   78   68    234
				//		2409452     안석창   56   86   96    238
				
				// 학번기준(내림차순)
				//		2409452     안석창   56   86   96    238
				//		2409332     박세진   88   78   68    234
				//		2409225     곽유진   91   81   71    243
				//		2409156     정승민   70   60   50    180
				//		2409133     이은솔   99   88   77    264
				//		2409123     윤영식   90   80   70    240
				
				
		}
		
		
	}
}

class MyComparator<T> implements Comparator<T>
{
	// 비교 기능을 수행하는 메소드 재정의
	@Override
	public int compare(T o1, T o2)
	{
		GradeDTO s1 = (GradeDTO)o1;
		GradeDTO s2 = (GradeDTO)o2;
		
		// 학번 기준(내림차순)
		//return Integer.parseInt(s2.getHak())-Integer.parseInt(s1.getHak())  ;
		// 학번 기준(오름차순)
		// return Integer.parseInt(s1.getHak()) -  Integer.parseInt(s2.getHak());
		// 총점 기준(오른차순)
		//return (s1.getTot()) -  (s2.getTot());
		// 총점 기준(내림차순)
		//return (s2.getTot()) - (s1.getTot()) ;
		// 이름 기준(오름차순)
		//return  s1.getName().compareTo(s2.getName());
		// 이름 기준(내림차순)
		return  s2.getName().compareTo(s1.getName());
	}
}

// VO		-  Value Object
// DTO		-  Data Tranfer Object
// DAO		-  Data Access Object

class GradeDTO
{
	// 주요 속성 구성
	private String hak;				//--학번
	private String name;			//--이름
	private int kor, eng, mat;		//--국어점수, 영어점수, 수학점수
	
	// 생성자(사용자 정의 생성자) → 5개의 매개변수를 가진 생성자
	GradeDTO(String hak, String name, int kor, int eng, int mat)
	{
		this.hak = hak;
		this.name = name;
		this.kor = kor;
		this.eng = eng;
		this.mat = mat;
	}
	
	// default 생성자 자동삽입 되지않음!
	
	// 생성자(사용자 정의 생성자) → default 생성자 형태(매개변수 없는 생성자)
	// 매개변수가 존재하는 생성자를 사용자 정의 생성자로 구성하였기 떄문에
	// default 생성자가 자동으로 삽입되지 않는 상황이므로 추가로 정의한 생성자
	GradeDTO()
	{
		this("","",0,0,0);
	}
	
	// getter / setter 구성
	
	String getHak ()
	{
		return hak;
	}
	String getName ()
	{
		return name;
		
	}
	int getKor ()
	{
		return kor;
		
	}
	int getEng ()
	{
		return eng;
	}
	int getMat ()
	{
		return mat;
	}
	
	
	
	
	void setHak(String hak)
	{
		this.hak = hak;
	}
	
	
	void setName(String name)
	{
		this.name = name;
	}

	void setKor(int kor)
	{
		this.kor = kor;
	}
	
	void setEng(int eng)
	{
		this.eng = eng;
	}
	
	void setMat(int mat)
	{
		this.mat = mat;
	}



	// 추가 메소드 정의
	// → 추가 업무 로직 구성 → 총점 산출
	
	public int getTot()
	{
		//return kor + eng + mat;
		return this.kor + this.eng + this.mat;
	}
	
	
}
/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// Map → Hashtable, HashMap
// · Key 와 Value 의 쌍으로 구성


/*
○	java.util.Map 인터페이스
	키(Key)를 값(value)에 매핑(mapping) 하여
	동일한 키를 등록할 수 없고 유일해야 하며
	각 키는 한 개의 값만 매핑해야 한다.
	즉, 하나의 키에 대응하는 하나의 값을 갖는 형태의 자료구조이다.
	
	
○	Hashtable(K, V) 클래스

	- 해시테이블 구조를 객체 모델링한 클래스로
	  검색이 용이하기 때문에 사용 빈도가 높은 편에 속한다.
	- 해시테이블이란 키(key)와 그에 상응하는 데이터(value)로
	  구분된 데이터 구조이다.
	- 데이터를 저장하고, 검색하기 위해서 키(key)로 접근하며
	  이 구조에서는 키 값을 부여하면 해당 데이터(value)가 변환된다.
	- 또한, Hashtable 클래스는 key 또는 value 의 값으로 null 을 허용하지 않는다.
*/


import java.util.Hashtable;

public class Test176{
	
	private static final String[] names
	= {"김믿음","박지우","엄서연","정영훈","박제훈","임성산"};
	
	private static final String[] tels
	= {"010-9347-8768","010-9596-5988","010-2678-0282"
		, "010-2762-1916","010-5454-3552","010-3677-6167"};
		
		
	public static void main(String[] args){
		
		// Hashtable 자료구조 ht 인스턴스 생성
		Hashtable<String, String> ht = new Hashtable<String, String>();
		
		// ht 라는 Hashtable 자료구조에
		// 각각의 배열(names, tels)에 담겨있는 데이터를 요소로 담아내기
		// → put(k, v)
		
		for (int i=0;i<names.length;i++)			// for (int i=0;i<6;i++)
		{
			//ht.put("김믿음","010-9347-8768");
			ht.put(names[i],tels[i]);
		}
		
		// Hashtable 자료구조 ht 에서 key 를 이용한 데이터 검색
		// → get(k)
		String findName1 = "박지우";
		String str = ht.get(findName1);
		if (str != null)
		{
			System.out.println(findName1 + " 전화번호 : " + str);
		}
		System.out.println();
		//--==>> 박지우 전화번호 : 010-9596-5988
		
		// Hashtable 자료구조 ht 에... key 가 존재하지는지의 여부 확인
		// → containsKey()
		
		//String findName2 = "엄서연";
		String findName2 = "김태완";
		if (ht.containsKey(findName2))
		{
			System.out.println(findName2 + "데이터가 존재합니다. ");
		}
		else
		{
			System.out.println(findName2 + " 데이터가 존재하지 않습니다.");
		}
		System.out.println();
		//--==>> 엄서연데이터가 존재합니다.
		//--==>> 김태완데이터가 존재하지 않습니다.
		
		
		// Hashtable 자료구조 ht 에... value 가 존재하는지의 여부 확인
		// → contains()
		//String findTel1 = "010-1234-1234";
		String findTel1 = "010-5454-3552";
		if (ht.contains(findTel1))
		{
			System.out.println(findTel1 + " 데이터가 존재하빈다.");
		}
		else
		{
			System.out.println(findTel1 + " 데이터가 존재 안하빈다.");
		}
		System.out.println();
		//--==>> 010-1234-1234 데이터가 존재 안하빈다.
		//--==>> 010-5454-3552 데이터가 존재하빈다.
		
		
		//Hashtable 자료구조 ht 에서 『임성산』 데이터 삭제
		// → remove()
		ht.remove("임성산");
		
		// ※ 『remove()』메소드는 인자값으로 key 를 넘겨받지만
		//    이 때, key 만 삭제되는 것이 아니다.
		//    해당 key와 연결되어(매핑되어)있는 value 도 함께 삭제(remove) 된다.
		
		if (ht.containsKey("임성산"))
			System.out.println("성산이가 존재합니다.");
		else
			System.out.println("성산이 어디갔어?????");
		System.out.println();
		//--==>> 성산이가 존재합니다.
		
		//ht.remove("임성산"); 코드 수행 이후
		//성산이 어디갔어?????
		
		if (ht.contains("010-3677-6167"))
			System.out.println("성산이 전화번호가 존재합니다.");
		else
			System.out.println("성산이 전화번호가 존재하지 않습니다.");
		System.out.println();
		//--==>> 성산이 전화번호가 존재합니다.
		
		//ht.remove("임성산"); 코드수행 이후
		//--==>> 성산이 전화번호가 존재하지 않습니다.
		
		// ※ null 관련 처리
		//ht.put(null, null);						//-- key 와 value 모두 null
		//--==>> 에러발생(런타임 에러)
		//--==>> java.lang.NullPointerException
		
		//ht.put("안석창", null);					//-- value 가 null
		//--==>> 에러발생(런타임 에러)
		//--==>> java.lang.NullPointerException
		
		//ht.put(null, "010-1234-5678");				//-- key 가 null
		//--==>> 에러발생(런타임 에러)
		//--==>> java.lang.NullPointerException
		
		
		// ※ 중복 데이터 관련 처리
		//  중복된 key 입력
		ht.put("박제훈","010-1111-1111");
		// 테스트(확인)
		System.out.println(ht.get("박제훈"));
		System.out.println();
		//--==>> 010-1111-1111
		//-- 중복된 key 를 활용하여 데이터를 입력하 경우
		//   기존 "010-5454-3552" 에서 "010-1111-1112" 로 변경되었음을 확인
		//   (덮어쓰기 개념)
		
		
		// 중복된 value 입력
		ht.put("김민승", "010-9347-8768");				//-- 믿음이 전화번호
		
		
		// 테스트(확인)
		System.out.println(ht.get("김믿음"));
		System.out.println();
		//--==>> 010-9347-8768
		
		// 테스트(확인)
		System.out.println(ht.get("김민승"));
		System.out.println();
		//--==>> 010-9347-8768
		
		// ※ value 는 중복된 데이터를 사용하더라도
		//	 기존 데이터에 아무론 영향을 미치지 않음을 확인

		
	}
}/*===============================================
       ■■■ 컬렉션(Collection Framework) ■■■
================================================*/

// Map → Hashtable, HashMap
// · Key 와 Value 의 쌍으로 구성


/*
○	java.util.Map 인터페이스
	키(Key)를 값(value)에 매핑(mapping) 하여
	동일한 키를 등록할 수 없고 유일해야 하며
	각 키는 한 개의 값만 매핑해야 한다.
	즉, 하나의 키에 대응하는 하나의 값을 갖는 형태의 자료구조이다.
	
	
○	HashMap(K, V) 클래스

    - Hashtable 클래스와 마찬가지로 Map 인터페이스에서 상속받은
	  HashMap 클래스의 기능은 Hashtable 과 동일하지만
	  Synchronization 이 없기 떄문에 동시성 문제가 없다면
	  (즉, 멀티 스레드 프로그램이 아닌 경우라면)
	  HashMap 을 사용하는 것이 성능을 향상시킬 수 있다.
	- 또한, HashMap 은 Hashtable 과는 달리 null을 허용한다.
*/

import java.util.HashMap;
import java.util.Map;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test177{
	public static void main(String[] args)throws IOException{
		
		
		// HashMap 자료구조 map 인스턴스 생성
		//HashMap<String, String> map = new HashMap<String, String>();
		Map<String, String> map = new HashMap<String, String>();
		
		// map 이라는 HashMap 자료구조에 요소 추가
		// → put();
		map.put("영화","중경삼림");
		map.put("드라마","오징어게임");
		map.put("만화","슬램덩크");
		
		//테스트(확인) → 더미 확인
		System.out.println(map);
		//--==>> {드라마=오징어게임, 영화=중경삼림, 만화=슬램덩크}
		//-- 데이터 매핑 구조 확인
		//   데이터 요소 격납 순서가 구성된 순서와 관계 없음
		
		
		// ※ null 관련 처리
		
		map.put(null, null);				//-- key 와 value 가 모두 null
		
		// 테스트(확인) → 더미 확인
		System.out.println(map);
		//--==>> {null=null, 드라마=오징어게임, 영화=중경삼림, 만화=슬램덩크}
		//       ----------
		//        check!
		
		
		map.put("동화",null);				//-- value 가 null
		
		// 테스트(확인) → 더미 확인
		System.out.println(map);
		//--==>> {null=null, 드라마=오징어게임, 영화=중경삼림, 동화=null, 만화=슬램덩크}
		//													   ---------
		//														check!
		
		map.put(null, "모나리자");			//-- key 가 null
		// 테스트(확인) → 더미 확인
		System.out.println(map);
		//--==>> {null=모나리자, 드라마=오징어게임, 영화=중경삼림, 동화=null, 만화=슬램덩크}
		//		  -------------
		//		     check!
		
		//==>> 데이터 입력 유형에 따라 모든 종류의 null 입력이 가능하지만
		//     마지막 null 을 key 로 매핑된 "모나리자"가
		//     최초 null을 key로 매핑하는 nulll 을 덮어쓰는 상황이 발생하게 된다.
		//	   즉, HashMap 은 null 을 하나의 고유한 key로 간주한다.(처리한다.)
		
		System.out.println();
		
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		System.out.print("카테고리, 타이틀 입력(컴마 구분) : ");
		String[] temp;
		
		for (String str; (str=br.readLine()) !=null;)
		{
			temp = str.split(",");
			if (temp.length<2)
			{
				System.out.print("카테고리, 타이틀 입력(컴마 구분) : ");
				continue;
			}
			
			map.put(temp[0].trim(), temp[1].trim());
			
			//더미 확인
			System.out.println(map);
		}
		
	}
}/*===============================================
       ■■■ 자바의 기본 입출력(I/O) ■■■
================================================*/

/*
○	자바의 기본 입출력 개요

	- 자바에서의 모든 데이터의 입출력은 『스트림(stream)』 이라는 개념에 의해
	  이루어 지는데 『스트림(stream)』 이라는 단어의 사전적 의미는
	  "흐르느 물"의 개념이며, 이는 연속된 일련의 데이터를 일컫는다.
	  
	- 데이터 입출력 시 모든 데이터를 형태와 관계없이 일련의 흐름으로
      전송을 하는 것이 스트림 입출력 모델의 기본 개념이다.
	  
	- 기본적으로 스트림(stream)이는
	  바이트 기반 스트림과 문자 기반 스트림이 있다.
	  
○	바이트 스트림(byte=stream) 입출력

	- InputStram 클래스와 OutputStream 클래스, 그리고 이들의 하위 클래스를
	통해서 제공되는 바이트 스트림(byte=stream) 을 위한 표준 입출력으로
	8 비트 크기를 갖는 바이트들의 스트림이 입출력된다.
	(바이트, 바이트배열, 정수 등)
	
○	문자 스트림(character=stream) 입출력

	- Reader 클래스와 Writer 클래스, 그리고 이들의 하위 클래스에 의해
	구현되었으며, 8 비트 크기를 갖는 바이트들의 스트림이 아닌
	16비트 크기를 갖는 유니코드 문자들의 스트림이라는 점에서 차이가 있다.
	(문자, 크기배열, 문자열 등)
	
※	스트림(stream)의 특징

	- 스트림은 FIFO 구조이다.
	  FIFO 구조란, 먼저 들어간 것이 먼저 나오는 형태로
	  스트림의 데이터는 순차적으로 흘러가며 순차적 접근 밖에는 허용되지 않는다.
	
	- 스트림은 단방향이다.
	  자바에서 스트림은 읽기 쓰기가 동시에 이루어지지 않는다.
	  따라서 읽기 쓰기가 필요하다면 읽는 스트림과 쓰는 스트림을
	  하나씩 열어서 사용해야 한다.
	
	- 스트림은 지연될 수 있다.
	  스트림에 넣어진 데이터는 처리되기 전에는 스트림에 사용하는 스레드가
	  지연(blocking) 상태에 빠진다.
	  네트워크 상에서는 데이터가 모두 전송되기 전까지 스레드는 지연(blocking)
	  상태가 된다.

*/

import java.io.IOException;

public class Test178{
	public static void main(String[] args) throws IOException{
		
		int data;
		char ch;
		
		System.out.println("문자열 입력(종료:ctrl+z)");
		
		//read() : InputStream 클래스의 대표적 메소드(→ 바이트 스트림)		
		while ((data = System.in.read()) != -1)
		{
			ch = (char)data;
			
			//System.out.print(ch);			// (→ 문자 스트림)
			
			//--==>> 문자열 입력(종료:ctrl+z)
			//		 abcd
			//		 abcd
			//		 1234
			//		 1234
			//	 	 가나다라
			//		 °¡³ª´?¶?
			//		 ^Z
			//		계속하려면 아무 키나 누르십시오 . . .
			
			
			//write() : OutputStream 클래스의 대표적 메소드(→ 바이트 스트링)
			System.out.write(ch);
			//--==>> 문자열 입력(종료:ctrl+z)
			//			abcd
			//			abcd
			//			1234
			//			1234
			//			가나다라
			//			가나다라
			//			^Z
			//			계속하려면 아무 키나 누르십시오 . . .
								}
		
	}
}/*===============================================
       ■■■ 자바의 기본 입출력(I/O) ■■■
	   -OutputStream 실습
================================================*/

import java.io.OutputStream;
import java.io.IOException;

public class Test179{
	public static void main(String[] args) throws IOException {
		
		// ※ System.in : 자바의 표준 입력 스트림
		//   System.out : 자바의 표준 출력 스트림
		OutputStream out = System.out;
		
		// 바이트 배열 구성
		byte[] ch = new byte[3];
		
		ch[0] = 65;			//-- 'A'
		ch[0] = 97;			//-- 'a'
		ch[0] = 122;		//-- 'z'
		
		
		//	↓
		out.write(ch);			//-- 밖으로 내보낼 데이터(변수)를 스트림(물줄기)에 기록
		
		out.flush();			//-- 기록된 스트림을 내보내는(밀어내는) 기능을 수행
								//   지금은 Buffer 를 활용하지 않고 있는 상황이기 때문에
								//	 생략이 가능한 코드.
								//   (즉,Buffered 되어있는 스트림(stream)일 경우 생략 불가)
		
		out.close();			//-- 리소스 반납
								//   출력 스트림(물줄기)에 대한 리소스 반납
								//	 (out 스트림(수도꼭지)을 잠가버린 상황)
								
		
		System.out.println("절대적인 신뢰를 갖고 있는 구문...");
		//-- 『out.close();』를 작성한 이후 출력되지 않는 구문.
		//    → 출력되는 스트림(물줄기)을 닫았기 때문에...
	}
}/*===============================================
       ■■■ 자바의 기본 입출력(I/O) ■■■
	   - Reader 실습
================================================*/

// Test178.java 파일과 비교!

import java.io.Reader;
import java.io.InputStreamReader;
import java.io.IOException;

public class Test180{
	public static void main(String[] args) throws IOException{
		
		int data;
		char ch;
		
		Reader rd = new InputStreamReader(System.in);
	//	------		     ---------------- ----------
	//								       자바의 표준 입력 스트림 → 바이트 기반 스트림
	//                   바이트기반 스트림을 문자 기반 스트림으로...(통역,번역,필터링)
	//  문자 기반 스트림 객체
		
		System.out.println("문자열 입력(종료:ctrl+z)");
		
		
		// 문자 기반 읽어들이는 처리
		while ( (data=rd.read()) != - 1)
		{
			ch = (char)data;
			
			// 문자 기반 출력 처리
			//System.out.print(ch);
			
			//--==>> 문자열 입력(종료:ctrl+z)
			//		 abcd
			//		 abcd
			//		 1234
			//		 1234
			//	 	 가나다라
			//		 가나다라
			//		 대한민국
			//		 대한민국
			//		 ^Z
			//		 계속하려면 아무 키나 누르십시오 . . .
			
			// 바이트 기반 출력 처리
			System.out.write(ch);
			//--==>>문자열 입력(종료:ctrl+z)
			//		abcd
			//		abcd
			//		1234
			//		1234
			//		가나다라
			//		섆|
			//		대한민국
			//		\?
			//		^Z
			//		계속하려면 아무 키나 누르십시오 . . .
		}
		
	}
}/*===============================================
       ■■■ 자바의 기본 입출력(I/O) ■■■
================================================*/
public class Test181{
	public static void main(String[] args){
		
		
		// ※ System.out : 자바 기본 출력 스트림
		
		System.out.write(65);	//-- 'A'
		System.out.write(66);	//-- 'B'
		
		System.out.write(180);	//┐
		System.out.write(235);	//┘180 + 235 → '대'
		
		//-------------------- 여기까지 수행하면 아무것도 출력되지 않는 상황임을 확인
		
		System.out.flush();
		
		//--==>> AB대
		
		// ※ 출력 버퍼가 채워지지 않으면
		//	 출력할 데이터(자료)를 출력 디바이스(장치로)로 보내지 않기 떄문에
		//	 flush() 메소드를 통해 아직 다채워지지 않은 출력 버퍼의 내용을
		//   출력 장치로 밀어내어 보낼 수 있도록 처리해야 한다.
		
		//   즉, 앞에서 본 내용과 달리
		//   현재의 구문에서는 『System.out.flush();』구문을 생략할 수 없다.
		
	}
}/*===============================================
       ■■■ 자바의 기본 입출력(I/O) ■■■
	   -Reader Writer 실습
================================================*/
import java.io.*;


public class Test182{
	
	public void process(InputStream is)			// System.in 전달 (→ 자바의 표준 입력 스트림 → 바이트 기반 스트림)
	{
		int data;
		
		System.out.println("문자열 입력(종료:Ctrl+z)");
		
		try
		{
			// 매개변수 is 라는 바이트 기반 객체(InputStream)를
			// 문자 기반 스트림으로 변환하여
			// (→ InputStreamReader 가 수행)
			// Reader 타입의 rd 에서 참조할 수 있도록 처리
			Reader rd = new InputStreamReader(is);				// System.in → InputStream → Reader
			
			// 문자 기반 입력 스트림 『rd』!
			
			// 바이트 기반 스트림인 자바의 기본 출력 스트림(System.out)을
			// 문자 기반 스트림으로 변환하여
			// (→ OutputStreamWriter 가 수행)
			// Writer 타입의 wt 에서 참조할 수 있도록 처리    
			Writer wt = new OutputStreamWriter(System.out);
			// 문자 기반 출력 스트림 『wt』!
			
			while ((data=rd.read()) != -1)		//-- 문자 기반 입력 스트림으로 읽어들이기..			→ 반복
			{
				wt.write(data);					//-- 문자 기반 출력 스트림(물줄기)에 data 기록		→ 반복
				wt.flush();					//-- 기록한 스트림(물줄기)을 밀어내어 내보냄		→ 반복
			}
		}
		catch (IOException e)
		{
			System.out.println(e.toString());
		}
	}
	
	

//실행결과
	
/*
	문자열 입력(종료:Ctrl+z)
abcdefg
abcdefg
1234567
1234567
가나다라마바사
가나다라마바사
우리나라대한민국대한독립만세
우리나라대한민국대한독립만세
^Z
계속하려면 아무 키나 누르십시오 . . .
*/
	
	
	
	
	
	
	public static void main(String[] args){
		
		Test182 ob = new Test182();
		ob.process(System.in);
	}
}/*===============================================
       ■■■ 객체 직렬화(Object Serialization) ■■■
================================================*/
/*
○	객체 직렬화(Object Serialization)는

	메모리에 생성된 클래스 객체의 멤버 변수의 현재 상태를
	그대로 보존해서 파일에 저장하거나
	네트워크를 통해 전달할 수 있는 기능으로
	멤버 변수의 값을 보존한다거나
	다른 네트워크에 있는 호스트에 값을 보낼 경우 사용하게 된다.
	
	즉, 객체 직렬화는 내용물을 바이트 단위로 변환하여
	파일 또는 네트워크를 통해 송수신(스트림)이 가능하게
	만들어주는 것으로 이때, 객체란 멤버 변수의 메모리만으로 구성된 것을 말한다.
	
	따라서, 메소드와 생성자는 객체 직렬화의 대상에서 제외된다.
	
○	객체 직렬화(Object Serialization)의 장점

	객체 자체의 내용을 입출력 형식에 구애받지 않고
	객체를 파일에 저장함으로써 영속성을 제공할 수 있으며
	객체 자체를 네트워크를 통해 손쉽게 교환할 수 있게 된다.
	
	객체 직렬화는 자바 1.1 이후에 도입되었는데
	그 이유는 RMI 와 Bean 때문이었다.
	RMI는 원칙적으로 객체 통신을 지원해야 하기 떄문에
	객체가 그대로(특정 상태를 유지한 채로) 이동할 수 있어야 한다.
	따라서 이를 지원하기 위해서는 객체 직렬화가 필수적이었다.
	
	또한, Bean 은 설계 시 상태에 대한 정보를 저장할 때
	이 객체 직렬화를 사용하게 되면 편하고 안정적으로 객체 상태를 저장할 수 있다.
	
○	Serializable 인터페이스

	객체 직렬화를 수행하기 위해 먼저 객체 직렬화가 가능하도록
	java.io.Serializable 인터페이스를 구현해 주어야 한다.
	이 인터페이스는 객체 직렬화가 제공되어야 한다는 사실을
	JVM에 알려주는 역할을 수행한다
	또한, Serializable 인터페이스는
	다른 인터페이스와 달리 구현해야 할 메소드가 없기 떄문에
	단지 선언만 해주면 된다.
	
	형식)
	①
	public class 클래스명 implements Serializable
	{
				//...

	}
	
	②
	Serializable 인터페이스를 구현한 후
	ObjectInputStream 클래스와 ObjectOutputStream 클래스를 이용하여
	객체 단위로 입출력을 수행하게 된다.
	
	※ 멤버 변수가 static 으로 선언된 경우(즉, 클래스 변수일 경우)
	  객체 직렬화의 대상에서 제외된다.
	  
○	Object Stream

	java.io.ObjectInputStream
	ObjectInputStream 클래스는 ObjectOutputStream 클래스에 의해
	파일에 저장되어 있는 객체나 네트워크를 통해 전달된 객체의
	직렬화를 해제하는 기능을 제공한다.
	단, java.io.Serializable 인터페이스와 java.io.Externalizble 인터페이스를
	지원해주는 객체데 대해서만 사용이 가능하다
	즉, Serializable 인터페이스와 Externalizable 인터페이스를
	구현한 객체에서만 사용이 가능하다는 것이다.
	이 때, readObject() 메소드를 이용하여
	스트림으로부터 직렬화된 객체를 읽을 수 있으며
	이렇게 읽은 객체는 배열, 문자열 또는 각 객체 등
	원래의 형(Type)으로 캐스팅 해 주어야 한다.
*/
//import java.util.Properties;
//import java.util.Iterator;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;
import java.io.File;
import java.util.Hashtable;

import java.io.FileInputStream;
import java.io.ObjectInputStream;
import java.util.Enumeration;

public class Test183{
	public static void main(String[] args) throws Exception
		{
		
		/*
		String appDir = System.getProperty("user.dir");
		
		//테스트(확인)
		System.out.println(appDir);
		*/
		/*
		Properties prop = System.getProperties();
		//-- 『Properties』 : Map → 키, 값
		
		String key, value;
		
		Iterator<?> it = prop.keySet().iterator();
		while (it.hasNext())
		{
			key = (String)it.next();
			value = prop.getProperty(key);
			System.out.println(key + " : " + value);
		}
		*/
		
		String appDir = System.getProperty("user.dir");
		//-- 시스템 자원으로부터 사용중인 디렉터리 정보 얻어오기
		
		// 파일 객체 생성
		File f0 = new File(appDir, "\\data\\test.ser");				// 확장자 『*.ser』
		//-- appDir → C:\JavaStudy\JavaStudy
		//-- appDir 위치를 기준으로 "\\data\\test.ser"의 파일을 구성하겠다는 의미.
		//	 결과적으로 『C:\JavaStudy\JavaStudy\data\test.ser』 구성.
		
		// 테스트(확인)
		//System.out.println(f0.getParentFile().exists());
		//--==>> false
		//-- 『test.ser』 파일이 만들어진 디렉터리 경로가 구성되어 있지 않다.
		//	즉, 『C:\JavaStudy\JavaStudy\data\』 이와 같은 디렉터리 구조가 만들어져 있지 않다.
		
		// ※ 『C:\JavaStudy\JavaStudy』경로에 『data』 디렉터리 생성 후 다시 확인
		
		// 테스트(확인)
		//System.out.println(f0.getParentFile().exists());
		//--==>> true
		
		// 『test.ser』 파일이 생성될 디렉터리 경로가 구성되어 있다면...
		//if (f0.getParentFile().exists())
		//					↓
		// 『test.ser』 파일이 생성될 디렉터리 경로가 구성되어 있지 않다면...
		if (!f0.getParentFile().exists())
		{
			// 디렉터리 구조 생성
			f0.getParentFile().mkdirs();
		}
		
		
		// Hashtable 자료구조 인스턴스 생성
		Hashtable<String, String> h1 = new Hashtable<String, String>();
		
		// 생성한 h1 이라는 Hashtable 자료구조에 요소 추가
		h1.put("2409123","김민승");
		h1.put("2409225","문제정");
		h1.put("2409250","안예지");
		h1.put("2409120","공찬민");
		
		// 테스트(확인)
		//System.out.println(h1.get("2409250"));
		//--==>> 안예지
		
		
		
		// 파일 전용 출력 스트림 생성(파일을 내보낼 수 있는 수도꼭지 열기)
		FileOutputStream fos = new FileOutputStream(f0);
		//-- 파일 전용 출력 스트림(물줄기)에
		//   f0 라는 파일 객체를 띄우겠다.
		//   InputStreamReader isr = new InputStreamReader(System.in);
		
		// 객체 전용 출력 스트림 생성(객체를 내보낼 수 있도록 처리)
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		//-- 객체 전용 출력 스트림(물줄기)으로
		//	 fos 라는 파일 전용 출력 스트림을 감싸겠다.
		// BufferedReader br = new BufferedRedaer(isr);
		
		// 위의 line 154 ~ 160 과 동일한 구문
		// → ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(f0));
		
		// 위의 line 165 과 동일한 구문
		//	BufferedReader br = new BufferedRedaer(new InputStreamReader(System.in));
		
		
		//	※ ObjectOutputStream 클래스는
		//	객체들을 출력하는 기능을 제공하는 클래스로
		//	출력 스트림에 출력하기 전에
		//	내부적으로 객체 직렬화를 수행하게 된다.
		//	자바 기본형 데이터 또는 객체들을
		//	파일에 저장하거나 네트워크를 통해 전달하기 위해
		//	전달할 객체를 직렬화하는 기능을 제공하는 것이다.
		
		
		//	생성된 스트림(물줄기)에 내보낼 객체를 기록(→ 종이배 띄우기)
		oos.writeObject(h1);
		//-- 『out.write(ch)』와 같은 개념의 구문
		
		
		
		// 객체 전용 리소스 반납
		oos.close();
		//-- ObjectOutputStream 리소스 반납
		
		// 파일 전용 리소스 반납
		fos.close();
		//-- FileOutputStream 리소스 반납
		
		
		// 여기까지 수행하면 (객체를 직렬화하여 파일로)내보내기 끝!
		//------------------------------------------------------------------
		

		// (객체를 직렬화하여 내보낸 파일)읽어들이기 시작~!!
		
		// f0 파일 객체가 존재한다면...
		if (f0.exists())
		{
			// f0 파일을 파일 입력 스트림(fis, FileInputStream)으로 읽어들이고
			FileInputStream fis = new FileInputStream(f0);
			
			
			// fis 파일 입력 스트림으로부터
			// 객체 입력 스트림(ois, ObjectInputStream)을 얻어내기
			ObjectInputStream ois = new ObjectInputStream(fis);
			
			// 객체 입력 스트림(ois, ObjectInputStream)으로부터 읽어들인 객체(Object) 를
			// 원래의 형(Type)으로 캐스팅하여 h2라는 Hashtable 자료구조에 담아내기
			
			//Object obj = ois.readObject();
			Hashtable h2 = (Hashtable)ois.readObject();
			
			ois.close();
			//-- ois, ObjectInputStream 리소스 반납
			
			fis.close();
			//-- fis, FileInputStream 리소스 반납
			
			// 여기까지 수행하면 읽어들이는 작업 끝
			//--------------------------------------------------------------------------
			
			// 읽어들인 h2 객체의 내용 확인
			
			String key;
			String value;
			
			Enumeration e = h2.keys();
			
			while (e.hasMoreElements())
			{
				key = (String)e.nextElement();
				//-- h2 라는 Hashtable 자료구조를 대상으로 key 를 읽어들이는 과정
				
				// 테스트(확인)
				//System.out.println(key);
				//--==>> 2409225
				//		 2409120
				//		 2409250
				//		 2409123
				
				value = (String)h2.get(key);
				//-- h2라는 Hashtable 자료구조를 대상으로
				//	 읽어들인 key 를 활용하여 value 를 얻어내는 과정
				
				System.out.println(key + " → " + value);
				//--==>> 2409225 → 문제정
				//		 2409120 → 공찬민
				//		 2409250 → 안예지
				//		 2409123 → 김민승
				
				
			}
		}
		
		else
		{
			System.out.println("읽어들일 파일이 존재하지 않습니다");
		}

	}
}