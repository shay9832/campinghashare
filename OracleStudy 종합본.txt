--○ 현재 오라클 서버에 접속한 자신의 계정 조회
SHOW USER;
--==>>USER이(가) "SYS"입니다.
-- SQLPLUS 상태일 때 사용하는 명령어

SELECT USER
FROM DUAL;
--==>> SYS




SELECT 1+2
FROM DUAL;
--==>> 3

SELECT 1 + 2
FROM DUAL;
--==>> 3

Select 1+2
from DUAL;
--==>> 3


SELECT '쌍용강북교육센터F강의장'
FROM DUAL;
--==>>쌍용강북교육센터F강의장


SELECT "아직은 지루한 오라클 수업"
FROM DUAL;
--==>> 에러발생
/*
ORA-00972: identifier is too long
00972. 00000 -  "identifier is too long"
*Cause:    An identifier with more than 128 bytes was specified,
           or a password identifier longer than 30 bytes was specified.
*Action:   Specify at most 128 bytes for identifiers,
           and at most 30 bytes for password identifiers.
31행, 8열에서 오류 발생
*/




SELECT 3.14 + 1.36
FROM DUAL;
--==>> 4.5




SELECT 1.2345 + 2.34565
FROM DUAL;
--==>>3.58015



SELECT 10* 5
FROM DUAL;
--==>> 50



SELECT 1000 / 23
FROM DUAL;
--==>>43.47826086956521739130434782608695652174


SELECT '김태완' + '문제정'
FROM DUAL;
--==>> 에러발생
/*
ORA-01722: invalid number
01722. 00000 -  "invalid number"
*Cause:    The specified number was invalid.
*Action:   Specify a valid number.
*/


--○ 오라클 서버에 존재하는 사용자계정 상태 조회
SELECT USERNAME, ACCOUNT_STATUS
FROM DBA_USERS;
--==>>
/*
SYS	OPEN
SYSTEM	OPEN
ANONYMOUS	OPEN
HR	OPEN
APEX_PUBLIC_USER	LOCKED
FLOWS_FILES	LOCKED
APEX_040000	LOCKED
OUTLN	EXPIRED & LOCKED
DIP	EXPIRED & LOCKED
ORACLE_OCM	EXPIRED & LOCKED
XS$NULL	EXPIRED & LOCKED
MDSYS	EXPIRED & LOCKED
CTXSYS	EXPIRED & LOCKED
DBSNMP	EXPIRED & LOCKED
XDB	EXPIRED & LOCKED
*/

SELECT USERNAME, USER_ID, ACCOUNT_STATUS, PASSWORD, LOCK_DATE
FROM DBA_USERS;

SELECT USERNAME,ACCOUNT_STATUS
FROM DBA_USERS;


--> 『DBA_』로 시작하는 Oracle Data Dictionary View 는
--  오로지 관리자 권한으로 접속했을 때만 조회가 가능하다.
--  아직은 데이터 딕셔너리 개념을 잡지 못해도 상관없다.



--○ 『hr』 사용자 계정을 잠금 상태로 설정
ALTER USER HR ACCOUNT LOCK;
--==>> User HR이(가) 변경되었습니다.


--○ 다시 사용자 계정 정보 조회
SELECT USERNAME, ACCOUNT_STATUS
FROM DBA_USERS;
--==>>
/*
SYS	                    OPEN
SYSTEM	                OPEN
ANONYMOUS	            OPEN
APEX_PUBLIC_USER	    LOCKED
FLOWS_FILES	            LOCKED
APEX_040000	            LOCKED
HR	                    LOCKED
OUTLN	                EXPIRED & LOCKED
DIP	                    EXPIRED & LOCKED
ORACLE_OCM	            EXPIRED & LOCKED
XS$NULL	                EXPIRED & LOCKED
MDSYS	                EXPIRED & LOCKED
CTXSYS	                EXPIRED & LOCKED
DBSNMP	                EXPIRED & LOCKED
XDB	                    EXPIRED & LOCKED
APPQOSSYS	            EXPIRED & LOCKED
*/


--○ 『HR』 사용자 계정을 잠금 해제 상태로 설정

ALTER USER HR ACCOUNT UNLOCK;
--==>> User HR이(가) 변경되었습니다


-- ○ 다시 사용자 계정 정보 조회
SELECT *
FROM DBA_USERS;

SELECT USERNAME, ACCOUNT_STATUS
FROM DBA_USERS;
/*
    :
HR	    OPEN
    :
*/


-----------------------------------------------------------------------------

--○ TABLESPACE 생성

--※ TABLESPACE 란?
--   세그먼트(테이블, 인덱스, ...) 를 담아두는 (저장해두는)
--   오라클의 논리적인 저장 구조를 의미한다.


CREATE TABLESPACE TBS_EDUA                      -- CREATE 유형 개체명
DATAFILE 'C:\TESTORADATA\TBS_EDUA01.DBF'        -- 물리적으로 연결되는 데이터 파일
SIZE 4M                                         -- 물리적 데이터 파일의 용량
EXTENT MANAGEMENT LOCAL                         -- 오라클 서버가 세그먼트를 알아서 관리
SEGMENT SPACE MANAGEMENT AUTO;                  -- 세그먼트 공간 관리도 자동으로 오라클 서버가...

-- ※ 테이블 스페이스 생성 구문을 실행하기 전에
--    물리적인 경로에 디렉터리(C:\TESTORADATA) 생성할 것



--○ 생성된 테이블스페이스 조회
--   테이블스페이스명 : TBS-EDUA

SELECT *
FROM DBA_TABLESPACES;

/*
SYSTEM	8192	65536		1	2147483645	2147483645		65536	ONLINE	PERMANENT	LOGGING	NO	LOCAL	SYSTEM	NO	MANUAL	DISABLED	NOT APPLY	NO	HOST	NO	
SYSAUX	8192	65536		1	2147483645	2147483645		65536	ONLINE	PERMANENT	LOGGING	NO	LOCAL	SYSTEM	NO	AUTO	DISABLED	NOT APPLY	NO	HOST	NO	
UNDOTBS1	8192	65536		1	2147483645	2147483645		65536	ONLINE	UNDO	LOGGING	NO	LOCAL	SYSTEM	NO	MANUAL	DISABLED	NOGUARANTEE	NO	HOST	NO	
TEMP	8192	1048576	1048576	1		2147483645	0	1048576	ONLINE	TEMPORARY	NOLOGGING	NO	LOCAL	UNIFORM	NO	MANUAL	DISABLED	NOT APPLY	NO	HOST	NO	
USERS	8192	65536		1	2147483645	2147483645		65536	ONLINE	PERMANENT	LOGGING	NO	LOCAL	SYSTEM	NO	AUTO	DISABLED	NOT APPLY	NO	HOST	NO	
TBS_EDUA	8192	65536		1	2147483645	2147483645		65536	ONLINE	PERMANENT	LOGGING	NO	LOCAL	SYSTEM	NO	AUTO	DISABLED	NOT APPLY	NO	HOST	NO	
*/



--○ 물리적인 파일 이름조회

SELECT *
FROM DBA_DATA_FILES;

/*
C:\ORACLEXE\APP\ORACLE\ORADATA\XE\USERS.DBF	4	USERS	104857600	12800	AVAILABLE	4	YES	11811160064	1441792	1280	103809024	12672	ONLINE
C:\ORACLEXE\APP\ORACLE\ORADATA\XE\SYSAUX.DBF	2	SYSAUX	692060160	84480	AVAILABLE	2	YES	34359721984	4194302	1280	691011584	84352	ONLINE
C:\ORACLEXE\APP\ORACLE\ORADATA\XE\UNDOTBS1.DBF	3	UNDOTBS1	398458880	48640	AVAILABLE	3	YES	524288000	64000	640	397410304	48512	ONLINE
C:\ORACLEXE\APP\ORACLE\ORADATA\XE\SYSTEM.DBF	1	SYSTEM	377487360	46080	AVAILABLE	1	YES	629145600	76800	1280	376438784	45952	SYSTEM
C:\TESTORADATA\TBS_EDUA01.DBF	5	TBS_EDUA	4194304	512	AVAILABLE	5	NO	0	0	0	3145728	384	ONLINE
*/




--○ 오라클 사용자 계정 생성
CREATE USER pjh IDENTIFIED BY java006$
DEFAULT TABLESPACE TBS_EDUA;
--> PJH 라는 사용자를 만들겠다. (생성하겠다.)
--  패스워드는 JAVA006$로 하겠다.
--  이 계정을 통해 생성하는 오라클 객체는(세그먼트들은)
--  기본적으로(defualt) TBS_EDUA 라는 테이블스페이스에
--  생성할 수 있도록 설정하겠다.

--==>> User PJH이(가) 생성되었습니다.



-- ※ 생성된 오라클 사용자 계정(pjh)을 통해
--    접속 시도
--    → 접속 불가(실패) → 『CREATE SESSION』 권한이 없기 때문에...



--○ 생성된 오라클 사용자 계정(pjh)에
--   서버 접속이 가능할 수 있도록
--   『CREATE SESSION』 권한 부여 → SYS 가...

GRANT CREATE SESSION TO PJH;
--==>>Grant을(를) 성공했습니다.


--※ 생성된 오라클 사용자 계정(pjh)을 통해
--   테이블을 생성하는 과정에서 에러 발생


--○ 생성된 오라클 사용자 계정(pjh)의
--   시스템 관련 권한 조회

SELECT *
FROM DBA_SYS_PRIVS;
/*
            :
   PJH	CREATE SESSION	NO
            :
*/

SELECT *
FROM DBA_SYS_PRIVS
WHERE GRANTEE = 'PJH';
--==>> PJH	CREATE SESSION	NO


--○ 생성된 오라클 사용자 계정(PJH)에
--   테이블 생성이 가능할 수 있도록 CREATE TABLE  권한 부여

-- GRANT CREATE TABLE, 다른권한, 다른권한 할수있음!
 GRANT CREATE TABLE TO PJH;
 --==>>Grant을(를) 성공했습니다.

--※ 생성된 오라클 사용자 계정(pjh)을 통해
--   테이블을 생성하는 과정에서 에러 발생


--○ 생성된 오라클 사용자 계정(pjh)에
--   테이블스페이스(TBS_EDUA)에서 사용할 수 있는
--   공간(할당량) 크기 지정. → 무제한(UNLIMITED)




--QUOTA 용량 ON TBS_EDUNA; (QUOTA = 할당)
ALTER USER PJH
QUOTA UNLIMITED ON TBS_EDUA;
--==>>User PJH이(가) 변경되었습니다.























--1. 줄 주석문 처리(단일행 주석문 처리)

/*
여러줄
(다중행)
주석문
처리
*/SELECT USER
FROM DUAL;
--==>> HRSELECT USER
FROM DUAL;
--==>> SYS

--○ 오라클 사용자 계정 생성(SCOTT)
CREATE USER SCOTT
IDENTIFIED BY tiger;
--==>> User SCOTT이(가) 생성되었습니다.

--○ 생성된 오라클 사용자 계정(SCOTT)에 권한 부여
GRANT CONNECT,RESOURCE,UNLIMITED TABLESPACE TO SCOTT;
--==>> Grant을(를) 성공했습니다.

--○ 생성된 오라클 사용자 계정(SCOTT)에 기본 테이블스페이스 설정
ALTER USER SCOTT DEFAULT TABLESPACE USERS;
--==>> User SCOTT이(가) 변경되었습니다.

--○ 생성된 오라클 사용자 계정(SCOTT)에 임시 테이블스페이스 설정
ALTER USER SCOTT TEMPORARY TABLESPACE TEMP;
--==>> User SCOTT이(가) 변경되었습니다.
SELECT USER
FROM DUAL;
--==>> SCOTT


--○ 테이블 생성
-- 테이블명 : DEPT
CREATE TABLE DEPT
( DEPTNO NUMBER(2) CONSTRAINT PK_DEPT PRIMARY KEY
, DNAME VARCHAR2(14)
, LOC VARCHAR2(13) 
) ;
--==>> Table DEPT이(가) 생성되었습니다.


--○ 테이블 생성
-- 테이블명:EMP
CREATE TABLE EMP
( EMPNO NUMBER(4) CONSTRAINT PK_EMP PRIMARY KEY
, ENAME VARCHAR2(10)
, JOB VARCHAR2(9)
, MGR NUMBER(4)
, HIREDATE DATE
, SAL NUMBER(7,2)
, COMM NUMBER(7,2)
, DEPTNO NUMBER(2) CONSTRAINT FK_DEPTNO REFERENCES DEPT
);
--==>> Table EMP이(가) 생성되었습니다.


--○ 데이터 입력(DEPT)
INSERT INTO DEPT VALUES	(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT VALUES (20,'RESEARCH','DALLAS');
INSERT INTO DEPT VALUES	(30,'SALES','CHICAGO');
INSERT INTO DEPT VALUES	(40,'OPERATIONS','BOSTON');
--==>> 1 행 이(가) 삽입되었습니다. * 4







--○ 데이터 입력(EMP)

INSERT INTO EMP VALUES
(7369,'SMITH','CLERK',7902,to_date('17-12-1980','dd-mm-yyyy'),800,NULL,20);
INSERT INTO EMP VALUES
(7499,'ALLEN','SALESMAN',7698,to_date('20-2-1981','dd-mm-yyyy'),1600,300,30);
INSERT INTO EMP VALUES
(7521,'WARD','SALESMAN',7698,to_date('22-2-1981','dd-mm-yyyy'),1250,500,30);
INSERT INTO EMP VALUES
(7566,'JONES','MANAGER',7839,to_date('2-4-1981','dd-mm-yyyy'),2975,NULL,20);
INSERT INTO EMP VALUES
(7654,'MARTIN','SALESMAN',7698,to_date('28-9-1981','dd-mm-yyyy'),1250,1400,30);
INSERT INTO EMP VALUES
(7698,'BLAKE','MANAGER',7839,to_date('1-5-1981','dd-mm-yyyy'),2850,NULL,30);
INSERT INTO EMP VALUES
(7782,'CLARK','MANAGER',7839,to_date('9-6-1981','dd-mm-yyyy'),2450,NULL,10);
INSERT INTO EMP VALUES
(7788,'SCOTT','ANALYST',7566,to_date('13-7-1987','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO EMP VALUES
(7839,'KING','PRESIDENT',NULL,to_date('17-11-1981','dd-mm-yyyy'),5000,NULL,10);
INSERT INTO EMP VALUES
(7844,'TURNER','SALESMAN',7698,to_date('8-9-1981','dd-mm-yyyy'),1500,0,30);
INSERT INTO EMP VALUES
(7876,'ADAMS','CLERK',7788,to_date('13-7-1987','dd-mm-yyyy'),1100,NULL,20);
INSERT INTO EMP VALUES
(7900,'JAMES','CLERK',7698,to_date('3-12-1981','dd-mm-yyyy'),950,NULL,30);
INSERT INTO EMP VALUES
(7902,'FORD','ANALYST',7566,to_date('3-12-1981','dd-mm-yyyy'),3000,NULL,20);
INSERT INTO EMP VALUES
(7934,'MILLER','CLERK',7782,to_date('23-1-1982','dd-mm-yyyy'),1300,NULL,10);
--==>> 1 행 이(가) 삽입되었습니다. * 14


--○ 테이블 생성
--  테이블명 : BONUS
CREATE TABLE BONUS
( ENAME VARCHAR2(10)
, JOB VARCHAR2(9)
, SAL NUMBER
, COMM NUMBER
);
--==>> Table BONUS이(가) 생성되었습니다.


--○ 테이블 생성
--  테이블명 : SALGRADE
CREATE TABLE SALGRADE
( GRADE NUMBER
, LOSAL NUMBER
, HISAL NUMBER 
);
--==>> Table SALGRADE이(가) 생성되었습니다.


--○ 데이터 입력(SALGRADE)
INSERT INTO SALGRADE VALUES (1,700,1200);
INSERT INTO SALGRADE VALUES (2,1201,1400);
INSERT INTO SALGRADE VALUES (3,1401,2000);
INSERT INTO SALGRADE VALUES (4,2001,3000);
INSERT INTO SALGRADE VALUES (5,3001,9999);
--==>> 1 행 이(가) 삽입되었습니다. * 5

--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ 현재 SCOTT 오라클 계정 사용자가 소유하고 있는 테이블 조회
SELECT *
FROM TAB;
--==>>
/*
BONUS	        TABLE	
DEPT	        TABLE	
EMP	            TABLE	
SALGRADE	    TABLE	
*/


--○ 어떤 테이블스페이스에 저장되어 있는지 조회
SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES;
--==>>
/*
DEPT	            USERS
EMP	                USERS
BONUS	            USERS
SALGRADE	        USERS
*/

--○ 테이블 생성
-- 테이블명 : TBL_EXAMPLE1

CREATE TABLE TBL_EXAMPLE1
(   NO      NUMBER
,   NAME    VARCHAR2(10)
,   ADDR    VARCHAR2(20)
);
--==>> Table TBL_EXAMPLE1이(가) 생성되었습니다.


--○ 테이블 생성
-- 테이블명 : TBL_EXAMPLE2

CREATE TABLE TBL_EXAMPLE2
(   NO      NUMBER
,   NAME    VARCHAR2(10)
,   ADDR    VARCHAR2(20)
) TABLESPACE TBS_EDUA;
--==>> Table TBL_EXAMPLE2이(가) 생성되었습니다.


--○ TBL_EXAMPLE1 과 TBL_EXAMPLE2 테이블이
--   어떤 테이블스페이스에 저장되어 있는지 조회
SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES;
--==>>
/*
DEPT	        USERS
EMP	            USERS
BONUS	        USERS
SALGRADE	    USERS
TBL_EXAMPLE1	USERS
TBL_EXAMPLE2	TBS_EDUA
*/


-------------------------------------------------------------------------------


--■■■ 관계형 데이터베이스 ■■■--

-- 데이터를 테이블의 형태로 저장시켜 놓은 것.
-- 그리고 이들 각 테이블들 간의 관계를 설정하는 것.


/*===================================
★ SELECT 문의 처리(PARSING) 순서 ★

    SELECT 컬럼명           --⑤ // 필수로 들어가야하는 구문
    FROM 테이블명           --① ┐
    WHERE 조건절            --② ┘1차적으로 메모리에 올라감(조건에 맞을시)
    GROUP BY 절             --③
    HAVING 절               --④ // GROUP BY 에 대한 조건절
    ORDER BY 절             --⑥ // 정렬기능
    
=====================================*/


--○ 현재 접속된 오라클 사용자(SCOTT) 소유의
--   테이블(TABLE), 뷰(VIEW)의 목록을 조회

SELECT *
FROM TAB;

/*
BONUS	        TABLE	→ 보너스 데이터 테이블
DEPT	        TABLE	→ DEPARTMENTS(부서) 데이터 테이블
EMP	            TABLE	→ EMPLOYEES(사원) 데이터 테이블
SALGRADE	    TABLE	→ SAL(급여) GRADE(등급) 데이터 테이블
TBL_EXAMPLE1	TABLE	
TBL_EXAMPLE2	TABLE	
*/


--○ 각 테이블의 데이터 조회
SELECT *
FROM BONUS;
--==>> 데이터 존재하지 않음(테이블의 구조만 확인 가능)

SELECT *
FROM DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/

SELECT *
FROM EMP;
--==>>
/*
7369	SMITH	CLERK	    7902	80/12/17	800		20
7499	ALLEN	SALESMAN	7698	81/02/20	1600	300	    30
7521	WARD	SALESMAN	7698	81/02/22	1250	500	    30
7566	JONES	MANAGER	    7839	81/04/02	2975		    20
7654	MARTIN	SALESMAN	7698	81/09/28	1250	1400	30
7698	BLAKE	MANAGER	    7839	81/05/01	2850		    30
7782	CLARK	MANAGER	    7839	81/06/09	2450		    10
7788	SCOTT	ANALYST	    7566	87/07/13	3000		    20
7839	KING	PRESIDENT		    81/11/17	5000		    10
7844	TURNER	SALESMAN	7698	81/09/08	1500	0	    30
7876	ADAMS	CLERK	    7788	87/07/13	1100		    20
7900	JAMES	CLERK	    7698	81/12/03	950		30
7902	FORD	ANALYST	    7566	81/12/03	3000		    20
7934	MILLER	CLERK	    7782	82/01/23	1300		    10
*/




--○ 접속한 사용자 조회
SELECT USER
FROM DUAL;
--==>> SCOTT

SELECT *
FROM SALGRADE;
--==>>
/*
1	700	    1200
2	1201	1400
3	1401	2000
4	2001	3000
5	3001	9999
*/

SELECT *
FROM EMP;




--○ DEPT 테이블에 존재하는 컬럼의 정보(구조) 조회
DESCRIBE DEPT;
--==>>
/*
이름     널?       유형           
------ -------- ------------ 
DEPTNO NOT NULL NUMBER(2)    
DNAME           VARCHAR2(14) 
LOC             VARCHAR2(13) 
*/

DESCRIBE EMP;
/*
이름       널?       유형           
-------- -------- ------------ 
EMPNO    NOT NULL NUMBER(4)    
ENAME             VARCHAR2(10) 
JOB               VARCHAR2(9)  
MGR               NUMBER(4)    
HIREDATE          DATE         
SAL               NUMBER(7,2)  
COMM              NUMBER(7,2)  
DEPTNO            NUMBER(2)   
*/

DESC DEPT;
--==>>
/*
이름     널?       유형           
------ -------- ------------ 
DEPTNO NOT NULL NUMBER(2)    
DNAME           VARCHAR2(14) 
LOC             VARCHAR2(13) 
*/

DESC EMP;
/*
이름       널?       유형           
-------- -------- ------------ 
EMPNO    NOT NULL NUMBER(4)    
ENAME             VARCHAR2(10) 
JOB               VARCHAR2(9)  
MGR               NUMBER(4)    
HIREDATE          DATE         
SAL               NUMBER(7,2)  
COMM              NUMBER(7,2)  
DEPTNO            NUMBER(2)    
*/


-- DEPTNO       DANME       LOC
-- 부서번호     부서명      부서위치
-- NOT NULL     NULL허용    NULL허용

-- EMPNO        ENAME       JOB         MGR         HIREDATE        SAL         COMM        DEPTNO
-- 사원번호     사원명      직종명      관리자      입사일          급여        수당        부서번호
-- NOT NULL     NULL허용    NULL허용    NULL허용    NULL허용        NULL허용    NULL허용    NULL허용

-- EX)
-- 80           인사부                             → 데이터 입력 허용
-- 80                       인천                   → 데이터 입력 허용
--                          인천                   → 데이터 입력 불가



--○ 유형 → 입력 가능한 데이터의 범위 → 데이터타입 → 자료형


/*
1.숫자형
   NUMBER           → -10 38승-1 ~ 10의 38승
   NUMBER(2)        → -99 ~ 99
   NUMBER(3)        → -999 ~ 999
   NUMBER(4)        → -9999 ~ 9999
   NUMBER(4,1)      → -999.9 ~ 999.9
비교) MS-SQL 서버의 정수 표현
     TINYINT    →   0 ~ 255             1Byte
     SMALLINT   →   -32768 ~ 32767      2Byte
     INT        →   -21억 ~ 21억        4Byte
     BIGINT     →   -920경 ~ 920경      8Byte
   
비교) MS-SQL 서버의 실수 표현
      FLOAT, REAL
      
비교) MS-SQL 서버의 문자 표현
      CHAR, VARCHAR, NVARCHAR
      
      
      
2. 문자형
    CHAR, NCHAR, VARCHAR2, NVARCHAR2
    
    CHAR                -- 고정형 크기   (괄호 없으면 1BYTE)
    CHAR(10)
    CHAR(10) ← '포도'             4Byte  이지만 10Byte 를 소모
    CHAR(10) ← '바나나'           6Byte  이지만 10Byte 를 소모
    CHAR(10) ← '몽키바나나'       10Byte 
    CHAR(10) ← '드래곤후루츠'     10Byte 를 초과하므로 입력 불가
    
    
    
    
    VARCHAR2            -- 가변형 크기   (괄호 없으면 전체크기)
    VARCHAR2(10) ← '포도'             4Byte
    VARCHAR2(10) ← '바나나'           6Byte
    VARCHAR2(10) ← '몽키바나나'       10Byte 
    VARCHAR2(10) ← '드래곤후루츠'     10Byte 를 초과하므로 입력 불가
    
    
    
    NCHAR           -- 유니코드 기반(글자수) 고정형 크기
    NCHAR(10)       -- 10글자
    
    NVARCHAR2       -- 유니코드 기반(글자수) 가변형 크기
    NVARCHAR2(10)   -- 10글자
    
    
3. 날짜형
    DATE
        
        
*/

SELECT SYSDATE
FROM DUAL;
--==>>24/11/18                              →날짜 타입


SELECT LOCALTIMESTAMP
FROM DUAL;
--==>> 24/11/18 10:21:49.024000000          →날짜 타입

SELECT '안녕하세요'                         
FROM DUAL;
--==>>안녕하세요                            → 문자타입

SELECT 10 + 20.4
FROM DUAL;
--==>>30.4                                  → 숫자타입



--○ EMP 테이블에서 사원번호, 사원명, 급여, 커미션 항목만 조회

SELECT *
FROM EMP;

SELECT DEPTNO,ENAME,SAL,COMM
FROM EMP;
--==>>\
/*
20	SMITH	800	
30	ALLEN	1600	300
30	WARD	1250	500
20	JONES	2975	
30	MARTIN	1250	1400
30	BLAKE	2850	
10	CLARK	2450	
20	SCOTT	3000	
10	KING	5000	
30	TURNER	1500	0
20	ADAMS	1100	
30	JAMES	950	
20	FORD	3000	
10	MILLER	1300	
*/

--○ EMP 테이블에서 부서번호가 20번인 직원들의 정보 중
--   사원번호, 사원명, 직종명, 급여, 부서번호 조회

SELECT *
FROM EMP;


SELECT DEPTNO,ENAME,JOB,SAL,EMPNO
FROM EMP
WHERE DEPTNO==20;
--==>> 에러 발생
/*
ORA-00936: missing expression
00936. 00000 -  "missing expression"
*Cause:    
*Action:
199행, 14열에서 오류 발생
*/

SELECT DEPTNO,ENAME,JOB,SAL,EMPNO
FROM EMP
WHERE DEPTNO=20;
--==>>
/*
20	SMITH	CLERK	800	    7369
20	JONES	MANAGER	2975	7566
20	SCOTT	ANALYST	3000	7788
20	ADAMS	CLERK	1100	7876
20	FORD	ANALYST	3000	7902
*/

DESCRIBE EMP;
DESC EMP;
/*
이름       널?       유형           
-------- -------- ------------ 
EMPNO    NOT NULL NUMBER(4)    
ENAME             VARCHAR2(10) 
JOB               VARCHAR2(9)  
MGR               NUMBER(4)    
HIREDATE          DATE         
SAL               NUMBER(7,2)  
COMM              NUMBER(7,2)  
DEPTNO            NUMBER(2)         ◀◀◀
*/


SELECT DEPTNO,ENAME,JOB,SAL,EMPNO
FROM EMP
WHERE DEPTNO=20;

--※ 테이블을 조회하는 과정에서 각 컬럼(항목)에 별칭(ALIAS)를 부여할 수 있다.
SELECT DEPTNO AS "사원번호",ENAME"사원명",JOB"직종",SAL "급 여",EMPNO "부서번호"
FROM EMP
WHERE DEPTNO=20;

--※ 테이블을 조회하는 과정에서 생긴(ALIAS)의 기본 구문은
--   『AS "별칭이름"』의 형태로 작성되며
--   이때, 『AS』는 생략이 가능하다.
--   또한, 『""』도 생략이 가능하다.
--   하지만 『""』를 생략하게 되면 별칭이름에 공백은 사용할 수 없다.
--   공백은 해당 컬럼에 대한 기술의 종결을 의미하므로
--   이름 내부에 공백을 사용할 경우 『""』를 사용하여
--   별칭을 부여할 수 있도록 처리해야 한다.

-- ○ EMP 테이블에서 부서번호가 20번과 30번 직원들의 데이터를
--    사원번호, 사원명, 직종명, 급여, 부서번호 항목으로 조회한다.
--    단, 별칭(ALIAS)을 사용한다

SELECT *
FROM EMP;

SELECT DEPTNO"사원번호",ENAME"사원명",JOB"직종명",SAL"급여",EMPNO"부서번호"
FROM EMP
WHERE DEPTNO=20 OR DEPTNO =30;
--==>>
/*
20	SMITH	CLERK	800	7369
30	ALLEN	SALESMAN	1600	7499
30	WARD	SALESMAN	1250	7521
20	JONES	MANAGER	2975	7566
30	MARTIN	SALESMAN	1250	7654
30	BLAKE	MANAGER	2850	7698
20	SCOTT	ANALYST	3000	7788
30	TURNER	SALESMAN	1500	7844
20	ADAMS	CLERK	1100	7876
30	JAMES	CLERK	950	7900
20	FORD	ANALYST	3000	7902
*/



SELECT DEPTNO"사원번호",ENAME"사원명",JOB"직종명",SAL"급여",EMPNO"부서번호"
FROM EMP
WHERE DEPTNO IN (20, 30);
-->> IN 연산자를 활용하여 이와 같이 처리할 수 있으며
--   앞서 OR 로 처리한 구문과 같은 결과를 반환하게 된다.
--==>>
/*
20	SMITH	CLERK	800	7369
30	ALLEN	SALESMAN	1600	7499
30	WARD	SALESMAN	1250	7521
20	JONES	MANAGER	2975	7566
30	MARTIN	SALESMAN	1250	7654
30	BLAKE	MANAGER	2850	7698
20	SCOTT	ANALYST	3000	7788
30	TURNER	SALESMAN	1500	7844
20	ADAMS	CLERK	1100	7876
30	JAMES	CLERK	950	7900
20	FORD	ANALYST	3000	7902
*/



--○ EMP 테이블에서 직종이 CLERK 인 사원들의 정보를 모두 조회한다.

SELECT *
FROM EMP
WHERE JOB LIKE 'CLERK';

SELECT *
FROM EMP
WHERE JOB = 'CLERK';
--==>>
/*
7369	SMITH	CLERK	7902	80/12/17	800		20
7876	ADAMS	CLERK	7788	87/07/13	1100		20
7900	JAMES	CLERK	7698	81/12/03	950		30
7934	MILLER	CLERK	7782	82/01/23	1300		10
*/

SELECT *
FROM EMP
WHERE JOB = 'clerk';
--==>> 조회 결과 없음(대소문자 구분)

--※ 오라클에서 입력된 데이터(값) 만큼은
--   반드시 대소문자 구분을 한다.

--○  emp 테이블에서 직종이 CLERK 인 사원들 중
--    20번 부서에 근무하는 사원들의
--    사원번호, 사원명, 직종명, 급여, 부서번호 항목을 조회한다.

SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종명",SAL"급여",DEPTNO"부서번호"
FROM EMP
WHERE JOB='CLERK' AND DEPTNO IN (20);
--==>>
/*
7369	SMITH	CLERK	800	    20
7876	ADAMS	CLERK	1100	20
*/



--○  EMP 테이블에서 10번 부서에 근무하는 직원들 중
--    급여가 2500 이상인 사원들의
--    사원명, 직종명, 급여, 부서번호 항목을 조회한다.

SELECT ENAME"사원명",JOB"직종",SAL"급여",DEPTNO"부서번호"
FROM EMP
WHERE DEPTNO IN (10) AND SAL>=2500;
--==>>
/*
KING	PRESIDENT	5000	10
*/



-- ※ 테이블 복사
--> 내부적으로 대상 테이블 내부에 있는 데이터의 내용만 복사하는 과정

DESCRIBE EMP;
DESC EMP;
--==>>
/*
이름       널?       유형           
-------- -------- ------------ 
EMPNO    NOT NULL NUMBER(4)    
ENAME             VARCHAR2(10) 
JOB               VARCHAR2(9)  
MGR               NUMBER(4)    
HIREDATE          DATE         
SAL               NUMBER(7,2)  
COMM              NUMBER(7,2)  
DEPTNO            NUMBER(2)    
*/

CREATE TABLE EMPCOPY
(EMPNO          NUMBER(4)
,ENAME          VARCHAR2(10)
,JOB            VARCHAR2(9)
,MGR            NUMBER(4)
,HIREDATE       DATE
,SAL            NUMBER(7,2)
,COMM           NUMBER(7,2)
,DEPTNO         NUMBER(2)
);
--==>> Table EMPCOPY이(가) 생성되었습니다.

SELECT *
FROM EMPCOPY;

SELECT *
FROM EMP;

INSERT INTO EMPCOPY VALUES(7369, 'SMITH', 'CLERK' , 7902, TO_DATE('1980-12-17', 'YYYY-MM-DD'),800,NULL,20);
--==>>1 행 이(가) 삽입되었습니다.

SELECT *
FROM EMPCOPY;

SELECT *
FROM EMP;


CREATE TABLE TBL_EMP
AS
SELECT *
FROM EMP;
--==>> Table TBL_EMP이(가) 생성되었습니다.


--○ 확인
SELECT *
FROM TBL_EMP;

DESC TBL_EMP;




--○ 테이블 복사(데이터 위주)
CREATE TABLE TBL_DEPT
AS
SELECT *
FROM DEPT;
--==>>Table TBL_DEPT이(가) 생성되었습니다.


--○ 복사한 테이블 확인
SELECT *
FROM TBL_EMP;
SELECT *
FROM TBL_DEPT;



--○ 커멘트(COMMENT) - 주석
SELECT *
FROM USER_TAB_COMMENTS;
--==>>
/*
DEPT	        TABLE	
EMP	            TABLE	
BONUS	        TABLE	
SALGRADE	    TABLE	
TBL_EXAMPLE1	TABLE	
``*/



--○  테이블의 커멘트 정보 입력

COMMENT ON TABLE TBL_EMP IS '사원데이터';
--==>>Comment이(가) 생성되었습니다.


--○ 커멘트 정보 입력 이후 다시 확인
SELECT *
FROM USER_TAB_COMMENTS;
--==>>
/*
TBL_DEPT	        TABLE	
TBL_EMP	            TABLE	사원데이터
EMPCOPY	            TABLE	
TBL_EXAMPLE2	    TABLE	
TBL_EXAMPLE1	    TABLE	
SALGRADE	        TABLE	
BONUS	            TABLE	
EMP	                TABLE	
DEPT	            TABLE	
*/


--○  테이블 레벨의 커멘트 정보 입력(TBL_DEPT → 부서데이터)
COMMENT ON TABLE TBL_DEPT IS '부서데이터';
--==>> Comment이(가) 생성되었습니다.


--○  커멘트 정보 입력 이후 다시 확인
SELECT *
FROM USER_TAB_COMMENTS;
/*
TBL_DEPT	        TABLE	부서데이터
TBL_EMP	            TABLE	사원데이터
EMPCOPY	            TABLE	
TBL_EXAMPLE2	    TABLE	
TBL_EXAMPLE1	    TABLE	
SALGRADE	        TABLE	
BONUS	            TABLE	
EMP	                TABLE	
DEPT	            TABLE	
*/


--○  컬럼 레벨의 커멘트 정보 확인
SELECT *
FROM USER_COL_COMMENTS;
--==>>
/*
TBL_DEPT	DEPTNO	
TBL_EXAMPLE1	ADDR	
BONUS	SAL	
DEPT	LOC	
TBL_EXAMPLE2	ADDR	
EMPCOPY	ENAME	
TBL_EMP	HIREDATE	
TBL_EXAMPLE2	NO	
SALGRADE	GRADE	
TBL_DEPT	DNAME	
BONUS	ENAME	
SALGRADE	LOSAL	
BONUS	JOB	
EMP	SAL	
TBL_EXAMPLE1	NO	
BONUS	COMM	
TBL_EMP	MGR	
EMP	ENAME	
TBL_EXAMPLE2	NAME	
EMPCOPY	EMPNO	
TBL_EMP	JOB	
EMPCOPY	COMM	
TBL_DEPT	LOC	
EMP	JOB	
EMP	HIREDATE	
EMP	DEPTNO	
EMP	COMM	
EMPCOPY	SAL	
TBL_EXAMPLE1	NAME	
EMPCOPY	HIREDATE	
DEPT	DNAME	
EMP	EMPNO	
EMPCOPY	MGR	
TBL_EMP	SAL	
SALGRADE	HISAL	
TBL_EMP	COMM	
TBL_EMP	ENAME	
EMPCOPY	JOB	
TBL_EMP	EMPNO	
EMPCOPY	DEPTNO	
EMP	MGR	
TBL_EMP	DEPTNO	
DEPT	DEPTNO	
*/

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME='TBL_DEPT';
--==>>
/*
TBL_DEPT	DEPTNO	
TBL_DEPT	DNAME	
TBL_DEPT	LOC	
*/


--○  테이블에 소속된(포함된) 컬럼 레벨의 커멘트 정보 입력(설정)
COMMENT ON COLUMN TBL_DEPT.DEPTNO IS '부서번호';
--==>> Comment이(가) 생성되었습니다.

COMMENT ON COLUMN TBL_DEPT.DNAME IS '부서이름';
--==>> Comment이(가) 생성되었습니다.

COMMENT ON COLUMN TBL_DEPT.LOC IS '부서위치';
--==>> Comment이(가) 생성되었습니다.

--○ 커멘트 데이터가 입력된 테이블의 컬럼 레벨의 데이터 확인
SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME='TBL_DEPT';
--==>>
/*
TBL_DEPT	DEPTNO	부서번호
TBL_DEPT	DNAME	부서이름
TBL_DEPT	LOC	    부서위치
*/

DESC TBL_EMP;
--==>>
/*
이름       널? 유형           
-------- -- ------------ 
EMPNO       NUMBER(4)           → 사원번호
ENAME       VARCHAR2(10)        → 사원명
JOB         VARCHAR2(9)         → 직종명
MGR         NUMBER(4)           → 관리자사원번호
HIREDATE    DATE                → 입사일
SAL         NUMBER(7,2)         → 급여
COMM        NUMBER(7,2)         → 수당
DEPTNO      NUMBER(2)           → 부서번호
*/

COMMENT ON COLUMN TBL_EMP.EMPNO IS '사원번호';
COMMENT ON COLUMN TBL_EMP.ENAME IS '사원명';
COMMENT ON COLUMN TBL_EMP.JOB IS '직종명';
COMMENT ON COLUMN TBL_EMP.MGR IS '관리자사원번호';
COMMENT ON COLUMN TBL_EMP.HIREDATE IS '입사일';
COMMENT ON COLUMN TBL_EMP.SAL IS '급여';
COMMENT ON COLUMN TBL_EMP.COMM IS '수당';
COMMENT ON COLUMN TBL_EMP.DEPTNO IS '부서번호';

SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME = 'TBL_EMP';
--==>>
/*
TBL_EMP	EMPNO	    사원번호
TBL_EMP	ENAME	    사원명
TBL_EMP	JOB	        직종명
TBL_EMP	MGR	        관리자사원번호
TBL_EMP	HIREDATE	입사일
TBL_EMP	SAL	        급여
TBL_EMP	COMM	    수당
TBL_EMP	DEPTNO	    부서번호
*/



--○  커멘트 데이터가 입력된 테이블의 컬럼 레벨의 정보 확인
SELECT *
FROM USER_COL_COMMENTS
WHERE TABLE_NAME ='TBL_EMP';
--==>>
/*
TBL_EMP	EMPNO	        사원번호
TBL_EMP	ENAME	        사원명
TBL_EMP	JOB	            직종명
TBL_EMP	MGR	            관리자사원번호
TBL_EMP	HIREDATE	    입사일
TBL_EMP	SAL	            급여
TBL_EMP	COMM	        수당
TBL_EMP	DEPTNO	        부서번호
*/

--■■■ 기존 테이블에 컬럼 구조의 추가 및 제거 ■■■--

SELECT *
FROM TBL_EMP;

--○ TBL_EMP 테이블에 주민등록번호 데이터를 담을 수 있는 컬럼 추가
ALTER TABLE TBL_EMP
ADD SSN CHAR(13);
--==>> Table TBL_EMP이(가) 변경되었습니다.


--※ 맨 앞에 0이 들어올 가능성이 있는 숫자가 조합된 데이터일 경우
--   숫자형이 아닌 문자형으로 데이터타입을 처리해야 한다




SELECT 0012123
FROM DUAL;
--==>> 12123

SELECT '0012123'
FROM DUAL;
--==>> 0012123



--○ 확인
DESC TBL_EMP;
--==>>
/*
이름       널? 유형           
-------- -- ------------ 
EMPNO       NUMBER(4)    
ENAME       VARCHAR2(10) 
JOB         VARCHAR2(9)  
MGR         NUMBER(4)    
HIREDATE    DATE         
SAL         NUMBER(7,2)  
COMM        NUMBER(7,2)  
DEPTNO      NUMBER(2)    

Comment이(가) 생성되었습니다.


Comment이(가) 생성되었습니다.


Comment이(가) 생성되었습니다.


Comment이(가) 생성되었습니다.


Comment이(가) 생성되었습니다.


Comment이(가) 생성되었습니다.


Comment이(가) 생성되었습니다.


Comment이(가) 생성되었습니다.


Table TBL_EMP이(가) 변경되었습니다.

이름       널? 유형           
-------- -- ------------ 
EMPNO       NUMBER(4)    
ENAME       VARCHAR2(10) 
JOB         VARCHAR2(9)  
MGR         NUMBER(4)    
HIREDATE    DATE         
SAL         NUMBER(7,2)  
COMM        NUMBER(7,2)  
DEPTNO      NUMBER(2)    
SSN         CHAR(13)     ◀◀◀
*/


SELECT *
FROM TBL_EMP;
--==>>
/*
7369	SMITH	CLERK	    7902	    80/12/17	800		        20	
7499	ALLEN	SALESMAN	7698	    81/02/20	1600	300	    30	
7521	WARD	SALESMAN	7698	    81/02/22	1250	500	    30	
7566	JONES	MANAGER	    7839	    81/04/02	2975		    20	
7654	MARTIN	SALESMAN	7698	    81/09/28	1250	1400	30	
7698	BLAKE	MANAGER	    7839	    81/05/01	2850		    30	
7782	CLARK	MANAGER	    7839	    81/06/09	2450		    10	
7788	SCOTT	ANALYST	    7566	    87/07/13	3000		    20	
7839	KING	PRESIDENT		        81/11/17	5000		    10	
7844	TURNER	SALESMAN	7698	    81/09/08	1500	0	    30	
7876	ADAMS	CLERK	    7788	    87/07/13	1100		    20	
7900	JAMES	CLERK	    7698	    81/12/03	950		30	
7902	FORD	ANALYST	    7566	    81/12/03	3000		    20	
7934	MILLER	CLERK	    7782	    82/01/23	1300		    10	
*/

-->> SSN 컬럼이 정상적으로 추가된 상황임을 확인

SELECT EMPNO,ENAME,SSN,JOB,MGR,HIREDATE,SAL,COMM,DEPTNO 
FROM TBL_EMP;


--> 테이블 내에서 컬럼의 순서는 구조적으로 의미 없음


--○ TBL_EMP 테이블에서 추가한 SSN(주민등록번호) 컬럼 제거
ALTER TABLE TBL_EMP
DROP COLUMN SSN;
--==>>Table TBL_EMP이(가) 변경되었습니다.


--○ 확인
DESC TBL_EMP;
--==>>
/*

이름       널? 유형           
-------- -- ------------ 
EMPNO       NUMBER(4)    
ENAME       VARCHAR2(10) 
JOB         VARCHAR2(9)  
MGR         NUMBER(4)    
HIREDATE    DATE         
SAL         NUMBER(7,2)  
COMM        NUMBER(7,2)  
DEPTNO      NUMBER(2)    

*/

SELECT *
FROM TBL_EMP;
--==>>

/*
7369	SMITH	CLERK	    7902	80/12/17	800		        20
7499	ALLEN	SALESMAN	7698	81/02/20	1600	300	    30
7521	WARD	SALESMAN	7698	81/02/22	1250	500	    30
7566	JONES	MANAGER	    7839	81/04/02	2975		    20
7654	MARTIN	SALESMAN	7698	81/09/28	1250	1400	30
7698	BLAKE	MANAGER	    7839	81/05/01	2850		    30
7782	CLARK	MANAGER	    7839	81/06/09	2450		    10
7788	SCOTT	ANALYST	    7566	87/07/13	3000		    20
7839	KING	PRESIDENT		    81/11/17	5000		    10
7844	TURNER	SALESMAN	7698	81/09/08	1500	0	    30
7876	ADAMS	CLERK	    7788	87/07/13	1100		    20
7900	JAMES	CLERK	    7698	81/12/03	950		30
7902	FORD	ANALYST	    7566	81/12/03	3000		    20
7934	MILLER	CLERK	    7782	82/01/23	1300		    10
*/


DELETE
FROM TBL_EMP
WHERE EMPNO=7369;
--==>>1 행 이(가) 삭제되었습니다.


SELECT *
FROM TBL_EMP;

DELETE TBL_EMP;             -- 당분간 권장하지 않음

SELECT *
FROM TBL_EMP;

DELETE
FROM TBL_EMP
WHERE EMPNO=7369;

DELETE
FROM TBL_EMP;               -- 당분간 권장함


--○ 확인
SELECT *
FROM TBL_EMP;
--==>> 조회결과 없음
--> 테이블의 구조는 그대로 남아있는 상태에서
--  데이터 모두 소실(삭제)된 상황임을 확인

--○ 테이블을 구조적으로 제거
DROP TABLE TBL_EMP;
--==>>Table TBL_EMP이(가) 삭제되었습니다.

SELECT *
FROM TBL_EMP;
--==>> 에러발생
/*
ORA-00942: table or view does not exist
00942. 00000 -  "table or view does not exist"
*Cause:    
*Action:
825행, 6열에서 오류 발생
*/


--○ 테이블 다시 생성(EMP 테이블 복사)

CREATE TABLE TBL_EMP
AS
SELECT *
FROM EMP;

--------------------------------------------------------------------------------

--■■■NULL 의 처리 ■■■--


SELECT 5"COL1", 10+5"COL2", 10-5"COL3", 10*5"COL4", 10/5"COL5"
FROM DUAL;

SELECT NULL, NULL+5, NULL-5, NULL*5, NULL/5, 10+NULL, 10-NULL, 10*NULL, 10/NULL
FROM DUAL;
--==>> (null) (null) (null) (null) (null) (null) (null) (null) (null)


-- ※ 관찰 결과
--    NULL은 상태에 값을 의미하며, 실제 존재하지 않는 값이기 때문에
--    이러한 NULL 이 연산에 포함될 경우 그 결과는 무조건 NULL 이다.

SELECT *
FROM TBL_EMP;




--○ TBL_EMP 테이블에서 커미션(COMM, 수당)이 NULL 인 직원의
--   사원명, 직종명, 급여, 커미션 항목을 조회한다.


SELECT ENAME"사원명",JOB"직종명",SAL"급여",COMM"커미션"
FROM EMP
WHERE COMM ='NULL';
--==>> 에러발생
/*
ORA-01722: invalid number
01722. 00000 -  "invalid number"
*Cause:    The specified number was invalid.
*Action:   Specify a valid number.
*/

DESC TBL_EMP;
/*
이름       널? 유형           
-------- -- ------------ 
EMPNO       NUMBER(4)    
ENAME       VARCHAR2(10) 
JOB         VARCHAR2(9)  
MGR         NUMBER(4)    
HIREDATE    DATE         
SAL         NUMBER(7,2)  
COMM        NUMBER(7,2)  ◀◀◀
DEPTNO      NUMBER(2)    
--> COMM 컬럼은 숫자형 데이터 타입을 취하고 있음을 확인

--※ NULL은 실제 존재하지 않는 값이기 떄문에 일반적인 연산자를 활용하여 비교할 수 없다.
--   즉, 산술적인 비교 연산을 수행할 수 없다는 의미이다.
--   NULL 을 대상으로 사용할 수 없는 연산자들...
--   >=, <=, >,<,=,!=,^=,<>
*/



SELECT ENAME"사원명",JOB"직종명",SAL"급여",COMM"커미션"
FROM EMP
WHERE COMM IS NULL;
--==>>
/*
SMITH	CLERK	    800	
JONES	MANAGER	    2975	
BLAKE	MANAGER	    2850	
CLARK	MANAGER	    2450	
SCOTT	ANALYST	    3000	
KING	PRESIDENT	5000	
ADAMS	CLERK	    1100	
JAMES	CLERK	    950	
FORD	ANALYST	    3000	
MILLER	CLERK	    1300	
*/

--○ TBL_EMP 테이블에서 20번 부서에 근무하지 않는 직원들의
--   사원번호, 사원명, 직종명, 부서번호 항목을 조회한다.



SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종명",DEPTNO"부서번호"
FROM TBL_EMP
WHERE DEPTNO != 20;

SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종명",DEPTNO"부서번호"
FROM TBL_EMP
WHERE DEPTNO <> 20;

SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종명",DEPTNO"부서번호"
FROM TBL_EMP
WHERE DEPTNO ^= 20;
--==>>
/*
7499	ALLEN	SALESMAN	30
7521	WARD	SALESMAN	30
7654	MARTIN	SALESMAN	30
7698	BLAKE	MANAGER	    30
7782	CLARK	MANAGER	    10
7839	KING	PRESIDENT	10
7844	TURNER	SALESMAN	30
7900	JAMES	CLERK	    30
7934	MILLER	CLERK	    10
*/


--○ TBL_EMP 테이블에서 커미션(수당,COMM)이 NULL 이 아닌 직원들의
--   사원명, 직종명, 급여, 커미션 항목을 조회한다.


SELECT ENAME,JOB,SAL,COMM
FROM TBL_EMP
WHERE COMM IS NOT NULL;

SELECT ENAME,JOB,SAL,COMM
FROM TBL_EMP
WHERE NOT COMM IS NULL;
--==>>
/*
ALLEN	SALESMAN	1600	300
WARD	SALESMAN	1250	500
MARTIN	SALESMAN	1250	1400
TURNER	SALESMAN	1500	0
*/



-- ○ TBL_EMP 테이블에서 모든 사원들의
--  사원명, 사원번호, 급여, 커미션, 연봉 항목을 조회한다.
--  단, 급여(SAL)는 매월 지급한다.
--  또한, 수당(COMM)은 매년 지급한다.


SELECT ENAME"사원명",DEPTNO"사원번호",SAL"급여",COMM"커미션",SAL*12+NVL(COMM,0)"연봉"
FROM TBL_EMP;



--○ NVL()
SELECT NULL "COL1", NVL(NULL, 10)"COL2", NVL(5, 10)"COL3"
FROM DUAL;
--==>>(null)  10	5
-- 첫 번째 파라미터 값이 NULL 이면, 두 번째 파라미터 값을 반환한다.
-- 첫 번째 파라미터 값이 NULL 이 아니면, 그 값(첫 번째 파라미터)을 그대로 반환한다.

/*
SMITH	20	800		        9600
ALLEN	30	1600	300	    19500
WARD	30	1250	500	    15500
JONES	20	2975		    35700
MARTIN	30	1250	1400	16400
BLAKE	30	2850		    34200
CLARK	10	2450		    29400
SCOTT	20	3000		    36000
KING	10	5000		    60000
TURNER	30	1500	0	    18000
ADAMS	20	1100		    13200
JAMES	30	950		        11400
FORD	20	3000		    36000
MILLER	10	1300		    15600
*/

SELECT COMM "COL1", NVL(COMM,0) "COL2"
FROM TBL_EMP
WHERE EMPNO=7566;



--○ NVL2()
--> 첫 번째 파라미터 값이 NULL 이 아닌 경우, 두 번째 파라미터 값을 반환하고,
--  첫 번째 파라미터 값이 NULL 인 경우, 세 번째 파라미터 값을 반환한다.

SELECT ENAME, COMM, NVL2(COMM, '청기올려','백기올려') "결과확인"
FROM TBL_EMP;


SELECT ENAME"사원명",DEPTNO"사원번호",SAL"급여",COMM"커미션",SAL*12+NVL2(COMM,SAL*12+COMM,SAL*12)"연봉"
FROM TBL_EMP;

SELECT ENAME"사원명",DEPTNO"사원번호",SAL"급여",COMM"커미션",SAL*12+NVL2(COMM,COMM,0)"연봉"
FROM TBL_EMP;
--==>>
/*
SMITH	20	800		        9600
ALLEN	30	1600	300	    19500
WARD	30	1250	500	    15500
JONES	20	2975		    35700
MARTIN	30	1250	1400	16400
BLAKE	30	2850		    34200
CLARK	10	2450		    29400
SCOTT	20	3000		    36000
KING	10	5000		    60000
TURNER	30	1500	0	    18000
ADAMS	20	1100		    13200
JAMES	30	950		        11400
FORD	20	3000		    36000
MILLER	10	1300		    15600
*/



--○ COALESCE()
--> 매개변수 제한이 없는 형태로 인지하고 활용한다.
--  맨 앞에 있는 매개변수로부터 차례로 NULL 인지 아닌지 확인하여
--  NULL 이 아닐 경우 적용(반환,처리) 하고,
--  NULL 인 경우에는 그 다음 매개변수 값으로 적용(반환,처리)한다.
--  NVL() 이나 NVL2() 와 비교하여..
--  모~~든 경우의 수를 고려할 수 있는 특징을 갖고 있다.

SELECT NULL "기본확인"
            , COALESCE(NULL,NULL,NULL,10)"결과확인1"
            , COALESCE(NULL,NULL,NULL,NULL,NULL,NULL,100)"결과확인2"
            , COALESCE(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,150)"결과확인3"
            , COALESCE(NULL,NULL,NULL,10,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,150)"결과확인4"
FROM DUAL;
--==>>(null)  10	100	150	10



--○ 실습환경 조성을 위한 데이터 입력
INSERT INTO TBL_EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,DEPTNO)
VALUES(8000,'정혀니','SALESMAN',7839,SYSDATE,10);

INSERT INTO TBL_EMP(EMPNO,ENAME,JOB,MGR,HIREDATE,COMM,DEPTNO)
VALUES(8001,'미듬이','SALESMAN',7839,SYSDATE,100,10);


SELECT *
FROM TBL_EMP;

SELECT *
FROM EMP;


--○ 커밋
COMMIT;
--==>>커밋 완료.



SELECT ENAME"사원명",DEPTNO"사원번호",SAL"급여",COMM"커미션",COALESCE(SAL*12+COMM,COMM,SAL*12,0)"연봉"
FROM TBL_EMP;


--------------------------------------------------------------------------------

--※  날짜와 시간에 대한 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>>Session이(가) 변경되었습니다.



SELECT *
FROM TBL_EMP;


SELECT SYSDATE
FROM DUAL;
--==>> 24/11/18
--==>> 2024-11-18 17:44:00 (세션 변경 후)



--○ 현재 날짜 및 시간을 반환하는 함수

SELECT SYSDATE, CURRENT_DATE, LOCALTIMESTAMP
FROM DUAL;
--==>>
/*
2024-11-18 17:44:52	
2024-11-18 17:44:52	
24/11/18 17:44:52.000000000
*/


--※ 날짜와 시간에 대한 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


-- ○ 변경 이후 다시 조회
SELECT SYSDATE, CURRENT_DATE, LOCALTIMESTAMP
FROM DUAL;
--==>> 
/*
2024-11-18	
2024-11-18
24/11/18 17:46:37.000000000
*/

SELECT USER
FROM DUAL;
--==>>SCOTT

SELECT SYSDATE
FROM DUAL;
--==>> 24/11/19


--※ 날짜와 시간에 대한 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.

SELECT SYSDATE
FROM DUAL;
--==>> 2024-11-19


--○ 컬럼과 컬럼의 연결(결합)
--   문자 타입과 문자 타입의 연결
--   『+』연산자를 통한 결합 수행은 불가능  『||』
SELECT 1 + 1
FROM DUAL;
--==>>2

SELECT '안석창','임성산'
FROM DUAL;


SELECT '안석창'+'임성산'
FROM DUAL;
--==>>
/*
ORA-01722: invalid number
01722. 00000 -  "invalid number"
*Cause:    The specified number was invalid.
*Action:   Specify a valid number.
*/


SELECT '안석창'||'임성산'
FROM DUAL;
--==>> 안석창임성산



SELECT ENAME, JOB
FROM TBL_EMP;
--==>>
/*
SMITH	CLERK
ALLEN	SALESMAN
WARD	SALESMAN
JONES	MANAGER
MARTIN	SALESMAN
BLAKE	MANAGER
CLARK	MANAGER
SCOTT	ANALYST
KING	PRESIDENT
TURNER	SALESMAN
ADAMS	CLERK
JAMES	CLERK
FORD	ANALYST
MILLER	CLERK
정혀니	SALESMAN
미듬이	SALESMAN
*/


SELECT ENAME || JOB "결과확인"
FROM TBL_EMP;
--==>>
/*
SMITHCLERK
ALLENSALESMAN
WARDSALESMAN
JONESMANAGER
MARTINSALESMAN
BLAKEMANAGER
CLARKMANAGER
SCOTTANALYST
KINGPRESIDENT
TURNERSALESMAN
ADAMSCLERK
JAMESCLERK
FORDANALYST
MILLERCLERK
정혀니SALESMAN
미듬이SALESMAN
*/


DESC TBL_EMP;
--==>>
/*
EMPNO       NUMBER(4)           -- 숫자 타입
ENAME       VARCHAR2(10)        -- 문자 타입
                :
                :
*/
SELECT EMPNO || ENAME "결과확인"
FROM TBL_EMP;
--==>>
/*
7369SMITH
7499ALLEN
7521WARD
7566JONES
7654MARTIN
7698BLAKE
7782CLARK
7788SCOTT
7839KING
7844TURNER
7876ADAMS
7900JAMES
7902FORD
7934MILLER
8000정혀니
8001미듬이
*/

--     문자타입   날짜타입 문자타입    숫자타입   문자타입
--     ---------- -------  -------       ---    ------------
SELECT '믿음이는', SYSDATE, '에 연봉',  500,'억을 원한다.' "결과확인"
FROM DUAL;
--==>> 믿음이는	2024-11-19	에 연봉	500	억을 원한다.



--     문자타입   날짜타입 문자타입      숫자타입   문자타입
--     ---------- -------  -------         ---    ------------
SELECT '믿음이는'|| SYSDATE|| '에 연봉'||  500||'억을 원한다.' "결과확인"
FROM DUAL;
--==>> 믿음이는2024-11-19에 연봉500억을 원한다.

--※ 오라클에서는 문자 타입의 형태로 타입을 변환하는 별도의 과정 없이
--   위에서 처리한 내용처럼 『||』만 삽입해주면 간단히 컬럼과 컬럼을
--   (서로 다른 종류의 데이터) 결합하는 것이 가능하다.
--   이와 비교하여 MS-SQL 에서는 모든 데이터를 문자 타입으로 CONVERT 해야 한다.

SELECT *
FROM TBL_EMP;


-- ○ TBL_EMP 테이블의 데이터를 활용하여
--    모든 직원들의 데이터에 대해
--    다음과 같은 결과를 얻을 수 있도록 쿼리문을 구성한다.

--    SMITH 의 현재 연봉은 9600인데, 희망 연봉은 19200이다.
--    ALLEN 의 현재 연봉은 19500 인데, 희망 연봉은 39000이다.
--                          :
--                          :

--    실습 진행 전에 정혀니 사원과 미듬이 사원 제거

SELECT * 
FROM TBL_EMP
WHERE EMPNO=8000 OR EMPNO=8001;

DELETE
FROM TBL_EMP
WHERE EMPNO IN (8000,8001);


SELECT *
FROM TBL_EMP;
--> 원하는 데이터가 제대로 제거되었음을 확인

--커밋
COMMIT;
--==>> 커밋 완료


-- ○ TBL_EMP 테이블의 데이터를 활용하여
--    모든 직원들의 데이터에 대해
--    다음과 같은 결과를 얻을 수 있도록 쿼리문을 구성한다.

--    SMITH 의 현재 연봉은 9600인데, 희망 연봉은 19200이다.
--    ALLEN 의 현재 연봉은 19500 인데, 희망 연봉은 39000이다.
--                          :
--                          :

--    실습 진행 전에 정혀니 사원과 미듬이 사원 제거


SELECT *
FROM TBL_EMP;



-- 방식 1
SELECT ENAME || '의 현재 연봉은 ' || NVL(SAL*12+COMM,SAL*12) || '인데,' || '희망 연봉은 ' || NVL((SAL*12+COMM)*2,(SAL*12)*2) || '이다.' "결과 확인"
FROM TBL_EMP;


-- 방식2
SELECT ENAME || '의 현재 연봉은 ' || NVL2(COMM, SAL*12+COMM, SAL*12) || '인데,' || '희망 연봉은 ' || NVL2(COMM, SAL*12+COMM, SAL*12)*2 || '이다.' "결과 확인"
FROM TBL_EMP;


-- 방식3
SELECT ENAME || '의 현재 연봉은 ' || COALESCE(SAL*12+COMM, SAL*12, COMM,0) || '인데,' || '희망 연봉은 ' || COALESCE(SAL*12+COMM,SAL*12,COMM,0)*2 || '이다.' "결과 확인"
FROM TBL_EMP;




-- SMITH's 입사일은 1980-12-17이다. 그리고 급여는 800 이다.
-- ALLEN'S 입사일은 1981-02-20이다. 그리고 급여는 1600 이다.


SELECT *
FROM TBL_EMP;


SELECT ENAME||'''s'||'입사일은 '||HIREDATE||'이다. '||' 그리고 급여는 '||SAL|| '이다.'
FROM TBL_EMP;


--※  문자열을 나타내는 홀따옴표 사이에서(시작과 끝)
--    홀따옴표 두 대가 홀따옴표 하나(어퍼스트로피)를 의미한다.
--    홀따옴표 『'』하나는 문자열의 시작을 나타내고
--    홀따옴표 『''』두개는 문자열 영역 안에서 어퍼스토로피를 나타내며
--    다시 등장하는 홀따옴표 『'』하나가 문자열 영역의 종료를 의미하게 되는 것이다.


SELECT *
FROM EMP
WHERE JOB = 'SALESMAN';
--==>>
/*
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	30
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	30
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	30
*/

SELECT *
FROM EMP
WHERE JOB = 'salesman';
--==>> 조회 결과 없음



-- ○ UPPER(), LOWER(), INITCAP()
SELECT 'oRaCLe'"1", UPPER('oRaCLe')"2",LOWER('oRaCLe')"3",INITCAP('oRaCLe')"4"
FROM DUAL;
--==>> oRaCLe	ORACLE	oracle	Oracle
--> UPPER() 는 모두 대문자로 변환하여 반환
--  LOWER() 는 모두 소문자로 변환하여 반환
--  INITCAP()는 첫  글자만 대문자로 하고 나머지는 모두 소문자로 변환하여 반환


-- 'salesman' ,'SaLesMaN','SAlesmAN'

SELECT *
FROM TBL_EMP
WHERE JOB = UPPER('SALesmAN');


--※ 실습 환경 구성을 위한 추가 데이터 입력
INSERT INTO TBL_EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(8000, '정영훈', 'saLesMAN',7698,SYSDATE,2000,200,30);
INSERT INTO TBL_EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(8001, '박제훈', 'SaLesMan',7698,SYSDATE,2000,200,30);
INSERT INTO TBL_EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(8002, '공찬민', 'salesman',7698,SYSDATE,2000,200,30);
INSERT INTO TBL_EMP (EMPNO, ENAME, JOB, MGR, HIREDATE, SAL, COMM, DEPTNO)
VALUES(8003, '안예지', 'SALESman',7698,SYSDATE,2000,200,30);
--==>>1 행 이(가) 삽입되었습니다. *4


--○ 확인

SELECT *
FROM TBL_EMP;
--==>>

/*
7369	SMITH	CLERK	    7902	1980-12-17	800		20
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10
7788	SCOTT	ANALYST	7   566	    1987-07-13	3000		    20
7839	KING	PRESIDENT		    1981-11-17	5000		    10
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20
7900	JAMES	CLERK	    7698	1981-12-03	950		        30
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10
8000	정영훈	saLesMAN	7698	2024-11-19	2000	200	    30
8001	박제훈	SaLesMan	7698	2024-11-19	2000	200	    30
8002	공찬민	salesman	7698	2024-11-19	2000	200	    30
8003	안예지	SALESman	7698	2024-11-19	2000	200	    30
*/


--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ TBL_EMP 테이블에서 대소문자 구분없이 세일즈맨 직종인 사원의
--   사원번호, 사원명, 직종, 입사일, 부서번호 항목을 조회한다.


SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종",HIREDATE"입사일",DEPTNO"부서번호"
FROM TBL_EMP
WHERE UPPER(JOB) = 'SALESMAN';
/*
7499	ALLEN	SALESMAN	1981-02-20	30
7521	WARD	SALESMAN	1981-02-22	30
7654	MARTIN	SALESMAN	1981-09-28	30
7844	TURNER	SALESMAN	1981-09-08	30
8000	정영훈	saLesMAN	2024-11-19	30
8001	박제훈	SaLesMan	2024-11-19	30
8002	공찬민	salesman	2024-11-19	30
8003	안예지	SALESman	2024-11-19	30
*/

SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종",HIREDATE"입사일",DEPTNO"부서번호"
FROM TBL_EMP
WHERE LOWER(JOB) = 'salesman';
/*
7499	ALLEN	SALESMAN	1981-02-20	30
7521	WARD	SALESMAN	1981-02-22	30
7654	MARTIN	SALESMAN	1981-09-28	30
7844	TURNER	SALESMAN	1981-09-08	30
8000	정영훈	saLesMAN	2024-11-19	30
8001	박제훈	SaLesMan	2024-11-19	30
8002	공찬민	salesman	2024-11-19	30
8003	안예지	SALESman	2024-11-19	30
*/

SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종",HIREDATE"입사일",DEPTNO"부서번호"
FROM TBL_EMP
WHERE INITCAP(JOB) = 'Salesman';
/*
7499	ALLEN	SALESMAN	1981-02-20	30
7521	WARD	SALESMAN	1981-02-22	30
7654	MARTIN	SALESMAN	1981-09-28	30
7844	TURNER	SALESMAN	1981-09-08	30
8000	정영훈	saLesMAN	2024-11-19	30
8001	박제훈	SaLesMan	2024-11-19	30
8002	공찬민	salesman	2024-11-19	30
8003	안예지	SALESman	2024-11-19	30
*/




--○ TBL_EMP 테이블에서 입사일이 1981년 9월 28일 입사한 직원의
--   사원명, 직종명, 입사일 항목을 조회한다.


SELECT *
FROM TBL_EMP;


SELECT ENAME"사원명",JOB"직종명",HIREDATE"입사일"
FROM TBL_EMP
WHERE HIREDATE = '1981-09-28';
--==>> MARTIN	SALESMAN	1981-09-28

DESC TBL_EMP;
--==>>
/*
        :
HIREDATE    DATE
        :
*/


--○ TO_DATE()

SELECT 2024-11-19"COL1"
        ,'2024-11-19'"COL2"
        ,TO_DATE('2024-11-19','YYYY-MM-DD')"COL3"
FROM DUAL;
--==>> 1994	2024-11-19	2024-11-19

SELECT TO_DATE('2024-13-01', 'YYYY-MM-DD')"RESULT"
FROM DUAL;
--==>> 에러발생
/*
ORA-01843: not a valid month
01843. 00000 -  "not a valid month"
*Cause:    
*Action:
*/

SELECT TO_DATE('2024-11-31', 'YYYY-MM-DD')"RESULT"
FROM DUAL;
--==>> 에러발생
/*
ORA-01839: date not valid for month specified
01839. 00000 -  "date not valid for month specified"
*Cause:    
*Action:
*/

SELECT TO_DATE('2025-02-29', 'YYYY-MM-DD')"RESULT"
FROM DUAL;
--==>> 에러 발생
/*
ORA-01839: date not valid for month specified
01839. 00000 -  "date not valid for month specified"
*Cause:    
*Action:
*/



--○ TBL_EMP 테이블에서 입사일이 1981년 9월 28일 이후(해당일 포함)
--   입사한 직원의 사원명, 직종명, 입사일 항목을 조회한다.


SELECT *
FROM TBL_EMP;



SELECT ENAME"사원명",JOB"직종명",HIREDATE"입사일"
FROM TBL_EMP
WHERE HIREDATE >=TO_DATE('1981-09-28','YYYY-MM-DD');
/*
MARTIN	SALESMAN	1981-09-28
SCOTT	ANALYST	    1987-07-13
KING	PRESIDENT	1981-11-17
ADAMS	CLERK	    1987-07-13
JAMES	CLERK	    1981-12-03
FORD	ANALYST	    1981-12-03
MILLER	CLERK	    1982-01-23
정영훈	saLesMAN	2024-11-19
박제훈	SaLesMan	2024-11-19
공찬민	salesman	2024-11-19
안예지	SALESman	2024-11-19
*/

--※ 오라클에서는 날짜 데이터의 크기 비교가 가능하다
--   오라클에서 날짜 데이터에 대한 크기 비교 시
--   과거보다 미래를 더 큰 값으로 간주한다.


--○  TBL_EMP 테이블에서 입사일이 1981년 4월 2일 부터
--    1981년 9월 28일 사이에 입사한 직원들의
--    사원번호, 사원명, 직종명, 입사일 항목을 조회한다. (해당일 포함)



SELECT EMPNO,ENAME,JOB,HIREDATE
FROM TBL_EMP
WHERE HIREDATE >= TO_DATE('1981-04-02','YYYY-MM-DD')
AND   HIREDATE <= TO_DATE('1981-09-28','YYYY-MM-DD');
/*
7566	JONES	MANAGER	    1981-04-02
7654	MARTIN	SALESMAN	1981-09-28
7698	BLAKE	MANAGER	    1981-05-01
7782	CLARK	MANAGER	    1981-06-09
7844	TURNER	SALESMAN	1981-09-08
*/


--○ BETWEEN A AND B → 날짜를 대상으로 적용
SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종명",HIREDATE"입사일"
FROM TBL_EMP
WHERE HIREDATE BETWEEN TO_DATE('1981-04-02','YYYY-MM-DD')
               AND     TO_DATE('1981-09-28','YYYY-MM-DD');
/*
7566	JONES	MANAGER	    1981-04-02
7654	MARTIN	SALESMAN	1981-09-28
7698	BLAKE	MANAGER	    1981-05-01
7782	CLARK	MANAGER	    1981-06-09
7844	TURNER	SALESMAN	1981-09-08
*/

--○ BETWEEN A AND B → 숫자를 대상으로 적용

SELECT EMPNO,ENAME,SAL
FROM TBL_EMP
WHERE SAL BETWEEN 1600 AND 2850;
--==>>
/*
7499	ALLEN	1600
7698	BLAKE	2850
7782	CLARK	2450
8000	정영훈	2000
8001	박제훈	2000
8002	공찬민	2000
8003	안예지	2000
*/


--○ BETWEEN A AND B → 문자를 대상으로 적용
SELECT EMPNO,ENAME,JOB,SAL
FROM TBL_EMP
WHERE ENAME BETWEEN 'C' AND 'S';
--==>> 사전식 배열로 인해 'S' 뒤에있는 인원들은 포함되어있지않음
/*
7566	JONES	MANAGER	    2975
7654	MARTIN	SALESMAN	1250
7782	CLARK	MANAGER	    2450
7839	KING	PRESIDENT	5000
7900	JAMES	CLERK	     950
7902	FORD	ANALYST	    3000
7934	MILLER	CLERK	    1300
*/


-- ※ BETWEEN ⓐ AND ⓑ 는 날짜형,숫자형,문자형 데이터 모두를 대상으로 사용할 수 있다.
--    단, 문자형일 경우 아스키코드 순서를 따르기 떄문에(사전식 배열)
--    대문자가 앞쪽에 위치하고, 소문자가 뒤쪽에 위치하며
--     BETWEEN ⓐ AND ⓑ 는 쿼리문이 수행되는 시점에서
--    오라클 내부적으로는 부등호 연산자의 형태로 바뀌어 연산이 처리된다.



--○ ASCII()

SELECT ASCII('A') "COL1", ASCII('B') "COL2"
      ,ASCII('a') "COL3", ASCII('b') "COL3"
FROM DUAL;
--==>>65	66	97	98



DELETE
FROM TBL_EMP
WHERE EMPNO BETWEEN 8000 AND 8003;
--==>> 4개 행 이(가) 삭제되었습니다.


--○ 확인
SELECT *
FROM TBL_EMP;
--==>>

/*
7369	SMITH	CLERK	    7902	1980-12-17	800		        20
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30
7566	JONES	MANAGER 	7839	1981-04-02	2975		    20
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20
7839	KING	PRESIDENT		    1981-11-17	5000		    10
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20
7900	JAMES	CLERK	    7698	1981-12-03	950		        30
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10
*/  


COMMIT;
--==>> 커밋 완료.


--○  TBL_EMP  테이블에서 직종이 SALESMAN 과 CLERK 인 사원의
--    사원번호, 사원명, 직종, 급여 항목을 조회한다.





SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종",SAL"급여"
FROM TBL_EMP
WHERE JOB IN ('SALESMAN','CLERK');
--==>>
/*
7369	SMITH	CLERK	    800
7499	ALLEN	SALESMAN	1600
7521	WARD	SALESMAN	1250
7654	MARTIN	SALESMAN	1250
7844	TURNER	SALESMAN	1500
7876	ADAMS	CLERK	    1100
7900	JAMES	CLERK	    950
7934	MILLER	CLERK	    1300
*/



SELECT EMPNO"사원번호",ENAME"사원명",JOB"직종",SAL"급여"
FROM TBL_EMP
WHERE JOB =ANY ('SALESMAN','CLERK');            --『=ALL』
--==>>
/*
7369	SMITH	CLERK	    800
7499	ALLEN	SALESMAN	1600
7521	WARD	SALESMAN	1250
7654	MARTIN	SALESMAN	1250
7844	TURNER	SALESMAN	1500
7876	ADAMS	CLERK	    1100
7900	JAMES	CLERK	    950
7934	MILLER	CLERK	    1300
*/


-- ※ 위의 3가지 유형의 쿼리문은 모두 같은 결과를 반환한다.
--     하지만, 맨위의 쿼리문이 가장 빠르게 처리된다.
--     물론, 메모리에 대한 내용이 아니라 CPU에 대한 내용이므로
--     이 부분까지 감안해서 쿼리문의 내용을 구분하여 구성하는 일은 많지 않다.
--     → 『IN』과 『=ANY』는 같은 연산자 효과를 가진다.
--     모두 내부적으로는 『OR』 구조로 변경되어 연산 처리된다.

--------------------------------------------------------------------------------

--※ 추가 실습 환경 구성을 위한 테이블 생성(TBL_SAWON)

CREATE TABLE TBL_SAWON
(SANO       NUMBER(4)
,SANAME     VARCHAR2(30)
,JUBUN      CHAR(13)
,HIREDATE   DATE        DEFAULT SYSDATE
,SAL        NUMBER(10)
);
--==>>Table TBL_SAWON이(가) 생성되었습니다.

SELECT *
FROM TBL_SAWON;
--==>> 조회결과 없음

DESC TBL_SAWON;
--==>>
/*
이름       널? 유형           
-------- -- ------------ 
SANO        NUMBER(4)    
SANAME      VARCHAR2(30) 
JUBUN       CHAR(13)     
HIREDATE    DATE         
SAL         NUMBER(10) 
*/


--○ 데이터입력
INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1001, '김정현','9804111234567',TO_DATE('2011-01-03','YYYY-MM-DD'),3000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1002, '정승민','0021114234567',TO_DATE('2017-11-05','YYYY-MM-DD'),2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1003, '정영훈','9709061234567',TO_DATE('2005-08-16','YYYY-MM-DD'),5000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1004, '문제정','9608051234567',TO_DATE('1999-08-16','YYYY-MM-DD'),4000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1005, '이은솔','9104282234567',TO_DATE('1998-02-10','YYYY-MM-DD'),6000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1006, '곽유진','9901192234567',TO_DATE('2002-07-15','YYYY-MM-DD'),2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1007, '이상이','8512161234567',TO_DATE('1999-08-16','YYYY-MM-DD'),2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1008, '이이경','8904051234567',TO_DATE('2009-06-05','YYYY-MM-DD'),1000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1009, '아이유','9302022234567',TO_DATE('2012-07-13','YYYY-MM-DD'),3000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1010, '미노이','9704252234567',TO_DATE('2007-12-10','YYYY-MM-DD'),2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1011, '선동열','7012181234567',TO_DATE('1990-10-10','YYYY-MM-DD'),3000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1012, '선우용녀','7005132234567',TO_DATE('1998-08-10','YYYY-MM-DD'),2000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1013, '선우선','0203044234567',TO_DATE('2012-07-13','YYYY-MM-DD'),1000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1014, '남희석','0502033234567',TO_DATE('2012-07-13','YYYY-MM-DD'),1000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1015, '남궁선','0512124234567',TO_DATE('2015-08-14','YYYY-MM-DD'),3000);

INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1016, '남진','7108051234567',TO_DATE('1990-10-10','YYYY-MM-DD'),2000);
--==>> 1 행 이(가) 삽입되었습니다. * 16

/*
1002	정승민	    002111  4234567	2017-11-05	2000
1003	정영훈	    970906  1234567	2005-08-16	5000
1004	문제정	    960805  1234567	1999-08-16	4000
1005	이은솔	    910428  2234567	1998-02-10	6000
1006	곽유진	    990119  2234567	2002-07-15	2000
1007	이상이	    851216  1234567	1999-08-16	2000
1008	이이경	    890405  1234567	2009-06-05	1000
1009	아이유	    930202  2234567	2012-07-13	3000
1010	미노이	    970425  2234567	2007-12-10	2000
1011	선동열	    701218  1234567	1990-10-10	3000
1012	선우용녀	700513  2234567	1998-08-10	2000
1013	선우선	    020304  4234567	2012-07-13	1000
1014	남희석	    050203  3234567	2012-07-13	1000
1015	남궁선	    051212  4234567	2015-08-14	3000
1016	남진	    710805  1234567	1990-10-10	2000
1001	김정현	    980411  1234567	2011-01-03	3000
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.




--○ 확인
SELECT *
FROM TBL_SAWON;




--○ TBL_SAWON 테이블에서 김정현 사원의 정보를 모두 조회한다.
SELECT *
FROM TBL_SAWON
WHERE SANAME = '김정현';
--==>> 1001	김정현	9804111234567	2011-01-03	3000


-- ※ LIKE : 동사 → 좋아하다
--           부사 → ~와 같이, ~처럼        CHECK!

-- ※ WILD CARD(CHARACTER) → 『%』 
--    『LIKE』와 함께 사용되는 『%』는 모든 글자를 의미한다.
--    『LIKE』와 함께 사용되는 『_』는 아무 글자 한 개를 의미한다.



--○ TBL_SAWON 테이블에서 성씨가 『정』씨인 사원의
--   사원명,주민번호,급여 항목을 조회한다.

SELECT 사원명, 주민번호, 급여
FROM TBL_SAWON
WHERE 성씨가 『정』;

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME = '정';
--==>> 조회 결과 없음

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '정__';
--==>>
/*
정승민	0021114234567	2000
정영훈	9709061234567	5000
*/

--○ 데이터 추가 입력
INSERT INTO TBL_SAWON(SANO, SANAME, JUBUN, HIREDATE, SAL)
VALUES(1017, '정우','8502031234567',TO_DATE('1999-10-10','YYYY-MM-DD'),2000);


--○ 확인
SELECT *
FROM TBL_SAWON;
--==>>
/*
1002	정승민	    0021114234567	2017-11-05	2000
1003	정영훈	    9709061234567	2005-08-16	5000
1004	문제정	    9608051234567	1999-08-16	4000
1005	이은솔	    9104282234567	1998-02-10	6000
1006	곽유진	    9901192234567	2002-07-15	2000
1007	이상이	    8512161234567	1999-08-16	2000
1008	이이경	    8904051234567	2009-06-05	1000
1009	아이유	    9302022234567	2012-07-13	3000
1010	미노이	    9704252234567	2007-12-10	2000
1011	선동열	    7012181234567	1990-10-10	3000
1012	선우용녀	7005132234567	1998-08-10	2000
1013	선우선	    0203044234567	2012-07-13	1000
1014	남희석	    0502033234567	2012-07-13	1000
1015	남궁선	    0512124234567	2015-08-14	3000
1016	남진	    7108051234567	1990-10-10	2000
1001	김정현	    9804111234567	2011-01-03	3000
1017	정우	    8502031234567	1999-10-10	2000
*/

COMMIT;
--==>> 커밋 완료.

SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '정__';
--==>>
/*
정승민	0021114234567	2000
정영훈	9709061234567	5000
*/


SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '정_';
--==>>
/*
정우	8502031234567	2000
*/


SELECT SANAME, JUBUN, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '정%';
--==>>
/*
정승민	0021114234567	2000
정영훈	9709061234567	5000
정우	8502031234567	2000
*/


--○ TBL_SAWON 테이블에서 이름의 마지막 글자가 『이』로
--   끝나는 사원의 사원명, 주민번호, 입사일, 급여 항목을 조회한다.



SELECT SANAME"사원명",JUBUN"주민번호",HIREDATE"입사일",SAL"급여"
FROM TBL_SAWON
WHERE SANAME LIKE '%이';
--==>>
/*
이상이	8512161234567	1999-08-16	2000
미노이	9704252234567	2007-12-10	2000
*/

SELECT SANAME"사원명",JUBUN"주민번호",HIREDATE"입사일",SAL"급여"
FROM TBL_SAWON
WHERE SANAME LIKE '__이';
/*
이상이	8512161234567	1999-08-16	2000
미노이	9704252234567	2007-12-10	2000
*/


SELECT SANAME"사원명",JUBUN"주민번호",HIREDATE"입사일",SAL"급여"
FROM TBL_SAWON
WHERE SANAME LIKE '_이_';
/*
이이경	8904051234567	2009-06-05	1000
아이유	9302022234567	2012-07-13	3000
*/


SELECT SANAME"사원명",JUBUN"주민번호",HIREDATE"입사일",SAL"급여"
FROM TBL_SAWON
WHERE SANAME LIKE '_이%';
--==>>
/*
이이경	8904051234567	2009-06-05	1000
아이유	9302022234567	2012-07-13	3000
*/




--○ TBL_SAWON 테이블에서 이름에 『이』라는 글자가
--   하나라도 포함되어있으면 그 사원의
--   사원명,주민번호,입사일,급여 항목을 조회한다.



SELECT SANAME, JUBUN, HIREDATE, SAL
FROM TBL_SAWON
WHERE SANAME LIKE '%이%';
/*
이은솔	9104282234567	1998-02-10	6000
이상이	8512161234567	1999-08-16	2000
이이경	8904051234567	2009-06-05	1000
아이유	9302022234567	2012-07-13	3000
미노이	9704252234567	2007-12-10	2000
*/




--○ TBL_SAWON 테이블에서 이름이 『이』라는 글자가
--   연속으로 두 번 포함되어 있으면 그 사원의
--   사원명, 주민번호, 입사일, 급여 항목을 조회한다.


SELECT SANAME,JUBUN,HIREDATE,SAL
FROM TBL_SAWON
WHERE SANAME LIKE '%이이%';
/*
이이경	8904051234567	2009-06-05	1000
*/




--○ TBL_SAWON 테이블에서 이름이 『이』라는 글자가
--   연속적이지 않더라도 두 번 포함되어 있으면 그 사원의
--   사원명, 주민번호, 입사일, 급여 항목을 조회한다.


SELECT SANAME,JUBUN,HIREDATE,SAL
FROM TBL_SAWON
WHERE SANAME LIKE '이%이%';
/*
이상이	8512161234567	1999-08-16	2000
이이경	8904051234567	2009-06-05	1000
*/




--○ TBL_SAWON 테이블에서 성씨가 『선』씨인 사원의
--   사원명, 주민번호, 입사일, 급여 항목을 조회한다.


--○ TBL_SAWON 테이블에서 성씨가 『남』씨인 사원의
--   사원명, 주민번호, 입사일, 급여 항목을 조회한다.


SELECT SANAME,JUBUN,HIREDATE,SAL
FROM TBL_SAWON
WHERE SANAME LIKE '선%%';
/*
선동열	    7012181234567	1990-10-10	3000
선우용녀	7005132234567	1998-08-10	2000
선우선	    0203044234567	2012-07-13	1000
*/


-- ※ 데이터베이스 설계 시 성과 이름을 분리해서 처리해야 할
--    업무 계획이 있다면(지금 당장은 아니더라도...)
--    테이블에서 성 컬럼과 이름 컬럼을 분리하여 구성해야 한다.




--○ TBL_SAWON 테이블에서 여직원들의 사원명, 주민번호, 급여 항목을 조회한다.



SELECT *
FROM TBL_SAWON
WHERE JUBUN LIKE '______2%' OR JUBUN LIKE '______4%';
/*
1002	정승민	    0021114234567	2017-11-05	2000
1005	이은솔	    9104282234567	1998-02-10	6000
1006	곽유진	    9901192234567	2002-07-15	2000
1009	아이유	    9302022234567	2012-07-13	3000
1010	미노이	    9704252234567	2007-12-10	2000
1012	선우용녀	7005132234567	1998-08-10	2000
1013	선우선	    0203044234567	2012-07-13	1000
1015	남궁선	    0512124234567	2015-08-14	3000
*/



--○ 실습 테이블 생성
-- 테이블명 : TBL_WATCH
CREATE TABLE TBL_WATCH
(WATCH_NAME VARCHAR2(20)
,BIGO       VARCHAR2(100)
);
--==>> Table TBL_WATCH이(가) 생성되었습니다.



--○ 테이블 입력
INSERT INTO TBL_WATCH(WATCH_NAME, BIGO)
VALUES('금시계','순금 99.99% 함유된 최고급 시계');

INSERT INTO TBL_WATCH(WATCH_NAME, BIGO)
VALUES('은시계','고객 만족도 99.99점을 획득한 시계');
--==>> 1 행 이(가) 삽입되었습니다. *2


--○ 확인
SELECT *
FROM TBL_WATCH;
--==>>
/*
금시계	순금 99.99% 함유된 최고급 시계
은시계	고객 만족도 99.99점을 획득한 시계
*/

--○ 커밋
COMMIT;
--==>> 커밋 완료.

--○ TBL_WATCH 테이블의 BIGO(비고) 컬럼에
--   『99.99%』라는 글자가 들어있는 행(레코드)의 정보를 조회한다.


SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '99.99%';
--==>> 조회 결과 없음

SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '%99.99%';
--==>>
/*
금시계	순금 99.99% 함유된 최고급 시계
은시계	고객 만족도 99.99점을 획득한 시계
*/

SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '%99.99\%%' ESCAPE '\';
--==>> 금시계	순금 99.99% 함유된 최고급 시계

SELECT *
FROM TBL_WATCH
WHERE BIGO LIKE '%99.99~%%' ESCAPE '~';
--==>> 금시계	순금 99.99% 함유된 최고급 시계




--※ ESCAPE 로 정한 문자의 다음 한 글자는 와일드카드에서 탈출시키도록 처리하는 구문
--  『ESCAPE '\'』
--   일반적으로 키워드 아닌, 연산자 아닌, 사용빈도가 낮은 특수문자(특수기호)를 사용.

--------------------------------------------------------------------------------

--■■■ COMMIT / ROLLBACK ■■■--


SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/


--○ 데이터입력
INSERT INTO TBL_DEPT VALUES(50, '개발부', '서울');
--==>>1 행 이(가) 삽입되었습니다.

--○ 확인

SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	CHICAGO
40	OPERATIONS	BOSTON
50	개발부	서울
*/
-- 50   개발부     서울
-- 이 데이터는 TBL_DEPT 테이블이 저장되어 있는
-- 하드디스크상에 물리적으로 적용되어 저장된 것이 아니라
-- 메모리(RAM) 상에 입력된 것이다.


--○ 롤백
ROLLBACK;
--==>> 롤백 완료.

--○ 롤백 이후 다시 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/
--> 50  개발부 소실
--  에 대한 데이터가 소실되었음을 확인(존재하지 않음)


--○ 다시 데이터입력
INSERT INTO TBL_DEPT VALUES(50, '개발부', '서울');
--==>>1 행 이(가) 삽입되었습니다.


--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/
--> 메모리 상에 입력된 이 데이터를 실제 하드디스크상에 물리적으로 저장하기 위해서는
--  COMMIT 을 수행해야 한다.

--○ 커밋
COMMIT;
--==>> 커밋 완료.


--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/


--○ 롤백
ROLLBACK;


--○ 롤백 이후 다시 확인
SELECT*
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/
--> 롤백(ROLLBACK)을 수행했음에도 불구하고
--  50   개발부   서울 데이터는 소실되지 않았음을 확인




--○ COMMIT 을 실행한 이후로 DML 구문(INSERT,UPDATE,DELETE 등)을 통해
--   변경된 데이터만 취소할 수 있는 것일 뿐
--   DML(INSERT,UPDATE,DELETE 등) 명령을 사용한 후 COMMIT 하고나서
--   ROLLBACK 을 실행해봐야... 이전 상태로 되돌릴 수 없다.(아무 소용이 없다.)





--○ 데이터 수정(TBL_DEPT)
UPDATE TBL_DEPT
SET DNAME='연구부', LOC='경기'
WHERE DEPTNO=50;
--==>>1 행 이(가) 업데이트되었습니다.


--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	연구부	    경기
*/

--○ 롤백
ROLLBACK;
--==>> 롤백 완료.

--○ 롤백 이후 다시 확인

SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/
--> 수정(UPDATE)을 수행하기 이전 상태로 복원되었음을 확인


--○ 데이터 삭제

SELECT *
FROM TBL_DEPT
WHERE DEPTNO = 50;
--==>>50	개발부	서울

DELETE
FROM TBL_DEPT
WHERE DEPTNO = 50;
--==>> 1 행 이(가) 삭제되었습니다.


--○ 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
*/

--○ 롤백
ROLLBACK;
--==>> 롤백 완료.

--○ 롤백 이후 다시 확인
SELECT *
FROM TBL_DEPT;
--==>>
/*
10	ACCOUNTING	NEW YORK
20	RESEARCH	DALLAS
30	SALES	    CHICAGO
40	OPERATIONS	BOSTON
50	개발부	    서울
*/
--> 삭제(DELETE) 구문을 수행하기 이전 상태로 복원되었음을 확인


-------------------------------------------------------------------------------

--■■■정렬 (ORDER BY) ■■■--

SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP;
/*
SMITH	20	CLERK	    800	    9600
ALLEN	30	SALESMAN	1600	19500
WARD	30	SALESMAN	1250	15500
JONES	20	MANAGER	    2975	35700
MARTIN	30	SALESMAN	1250	16400
BLAKE	30	MANAGER	    2850	34200
CLARK	10	MANAGER	    2450	29400
SCOTT	20	ANALYST	    3000	36000
KING	10	PRESIDENT	5000	60000
TURNER	30	SALESMAN	1500	18000
ADAMS	20	CLERK	    1100	13200
JAMES	30	CLERK	    950	    11400
FORD	20	ANALYST	    3000	36000
MILLER	10	CLERK	    1300	15600
*/


SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY DEPTNO ASC;                -- DEPTNO → 부서번호 기준 정렬
                                    -- ASC    → 오름차순 정렬
--==>>
/*
CLARK	10	MANAGER	    2450	29400
KING	10	PRESIDENT	5000	60000
MILLER	10	CLERK	    1300	15600
JONES	20	MANAGER	    2975	35700
FORD	20	ANALYST	    3000	36000
ADAMS	20	CLERK	    1100	13200
SMITH	20	CLERK	    800	     9600
SCOTT	20	ANALYST	    3000	36000
WARD	30	SALESMAN	1250	15500
TURNER	30	SALESMAN	1500	18000
ALLEN	30	SALESMAN	1600	19500
JAMES	30	CLERK	    950	    11400
BLAKE	30	MANAGER	    2850	34200
MARTIN	30	SALESMAN	1250	16400
*/



SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY DEPTNO;                -- DEPTNO → 부서번호 기준 정렬
                                -- ASC → 오름차순 정렬 → 생략 가능   
/*
CLARK	10	MANAGER	    2450	29400
KING	10	PRESIDENT	5000	60000
MILLER	10	CLERK	    1300	15600
JONES	20	MANAGER	    2975	35700
FORD	20	ANALYST	    3000	36000
ADAMS	20	CLERK	    1100	13200
SMITH	20	CLERK	    800	     9600
SCOTT	20	ANALYST	    3000	36000
WARD	30	SALESMAN	1250	15500
TURNER	30	SALESMAN	1500	18000
ALLEN	30	SALESMAN	1600	19500
JAMES	30	CLERK	    950	    11400
BLAKE	30	MANAGER	    2850	34200
MARTIN	30	SALESMAN	1250	16400
*/

SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY DEPTNO DESC ;                -- DEPTNO → 부서번호 기준 정렬
                                      -- DESC → 내림차순 정렬 → 생략 가능   
--==>>
/*
BLAKE	30	MANAGER	    2850	34200
TURNER	30	SALESMAN	1500	18000
ALLEN	30	SALESMAN	1600	19500
MARTIN	30	SALESMAN	1250	16400
WARD	30	SALESMAN	1250	15500
JAMES	30	CLERK	    950	    11400
SCOTT	20	ANALYST	    3000	36000
JONES	20	MANAGER	    2975	35700
SMITH	20	CLERK	    800	    9600
ADAMS	20	CLERK	    1100	13200
FORD	20	ANALYST	    3000	36000
KING	10	PRESIDENT	5000	60000
MILLER	10	CLERK	    1300	15600
CLARK	10	MANAGER	    2450	29400
*/


SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY SAL DESC ;             -- SAL → 급여 기준 정렬
                                -- DESC → 내림차순 정렬
--==>>
/*
KING	10	PRESIDENT	5000	60000
FORD	20	ANALYST	    3000	36000
SCOTT	20	ANALYST	    3000	36000
JONES	20	MANAGER	    2975	35700
BLAKE	30	MANAGER	    2850	34200
CLARK	10	MANAGER	    2450	29400
ALLEN	30	SALESMAN	1600	19500
TURNER	30	SALESMAN	1500	18000
MILLER	10	CLERK	    1300	15600
WARD	30	SALESMAN	1250	15500
MARTIN	30	SALESMAN	1250	16400
ADAMS	20	CLERK	    1100	13200
JAMES	30	CLERK	     950	11400
SMITH	20	CLERK	     800	 9600
*/

SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY 연봉 DESC ;
--==>>
/*
KING	10	PRESIDENT	5000	60000
FORD	20	ANALYST	    3000	36000
SCOTT	20	ANALYST	    3000	36000
JONES	20	MANAGER	    2975	35700
BLAKE	30	MANAGER	    2850	34200
CLARK	10	MANAGER	    2450	29400
ALLEN	30	SALESMAN	1600	19500
TURNER	30	SALESMAN	1500	18000
MARTIN	30	SALESMAN	1250	16400
MILLER	10	CLERK	    1300	15600
WARD	30	SALESMAN	1250	15500
ADAMS	20	CLERK	    1100	13200
JAMES	30	CLERK	     950	11400
SMITH	20	CLERK	     800	9600
*/
-->> ORDER BY 절보다 SELECT 절이 먼저 처리되기 때문에
--   테이블의 컬럼명 대신 SELECT 절에서 부여한 ALIAS(별칭)을
--   ORDER BY 절에서 사용해도 문제가 발생하지 않는다.(가능하다.)


SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY 부서 번호 DESC ;
/*
ORA-00933: SQL command not properly ended
00933. 00000 -  "SQL command not properly ended"
*Cause:    
*Action:
1,378행, 113열에서 오류 발생
*/

SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY "부서번호" DESC ;
/*
BLAKE	30	MANAGER	    2850	34200
TURNER	30	SALESMAN	1500	18000
ALLEN	30	SALESMAN	1600	19500
MARTIN	30	SALESMAN	1250	16400
WARD	30	SALESMAN	1250	15500
JAMES	30	CLERK	    950	    11400
SCOTT	20	ANALYST	    3000	36000
JONES	20	MANAGER	    2975	35700
SMITH	20	CLERK	    800	    9600
ADAMS	20	CLERK	    1100	13200
FORD	20	ANALYST	    3000	36000
KING	10	PRESIDENT	5000	60000
MILLER	10	CLERK	    1300	15600
CLARK	10	MANAGER	    2450	29400
*/

SELECT ENAME"사원명",DEPTNO"부서번호",JOB"직종",SAL"급여"
       ,SAL*12+NVL(COMM, 0) "연봉"
FROM TBL_EMP
ORDER BY 2;             -- DEPTNO ASC

/*
CLARK	10	MANAGER	    2450	29400
KING	10	PRESIDENT	5000	60000
MILLER	10	CLERK	    1300	15600
JONES	20	MANAGER	    2975	35700
FORD	20	ANALYST	    3000	36000
ADAMS	20	CLERK	    1100	13200
SMITH	20	CLERK	    800	    9600
SCOTT	20	ANALYST	    3000	36000
WARD	30	SALESMAN	1250	15500
TURNER	30	SALESMAN	1500	18000
ALLEN	30	SALESMAN	1600	19500
JAMES	30	CLERK	    950	    11400
BLAKE	30	MANAGER	    2850	34200
MARTIN	30	SALESMAN	1250	16400
*/
--> TBL_EMP 테이블이 갖고있는 테이블의 고유한 컬럼 순서가 아니라
--  SELECT 처리되는 과정에서 두 번째 컬럼(즉,DEPTNO)을 기준으로
--  정렬이 수행되는 것을 확인
--  ASC 생략한 상태 → 오름차순 정렬되는 것을 확인

SELECT ENAME,DEPTNO,JOB,SAL
FROM TBL_EMP
ORDER BY 2, 4;              -- DEPTNO 기준 1차 정렬, SAL 기준 2차 정렬... ASC
/*
MILLER	10	CLERK	    1300
CLARK	10	MANAGER	    2450
KING	10	PRESIDENT	5000
SMITH	20	CLERK	    800
ADAMS	20	CLERK	    1100
JONES	20	MANAGER	    2975
SCOTT	20	ANALYST	    3000
FORD	20	ANALYST	    3000
JAMES	30	CLERK	    950
MARTIN	30	SALESMAN	1250
WARD	30	SALESMAN	1250
TURNER	30	SALESMAN	1500
ALLEN	30	SALESMAN	1600
BLAKE	30	MANAGER	    2850
*/

SELECT ENAME, DEPTNO, JOB, SAL
FROM TBL_EMP
ORDER BY 2,3,4 DESC;
--> ① DEPTNO(부서번호) 기준 오름차순 정렬
--  ② JOB(직종명) 기준 오름차순 정렬
--  ③ SAL(급여) 기준 내림차순 정렬
--  (3차 정렬 수행)
/*
MILLER	10	CLERK	    1300
CLARK	10	MANAGER	    2450
KING	10	PRESIDENT	5000
SCOTT	20	ANALYST	    3000
FORD	20	ANALYST	    3000
ADAMS	20	CLERK	    1100
SMITH	20	CLERK	     800
JONES	20	MANAGER	    2975
JAMES	30	CLERK	     950
BLAKE	30	MANAGER	    2850
ALLEN	30	SALESMAN	1600
TURNER	30	SALESMAN	1500
MARTIN	30	SALESMAN	1250
WARD	30	SALESMAN	1250
*/


--------------------------------------------------------------------------------

--○ CONCAT() → 문자열 결합 함수

SELECT '윤영식' || '안석창' "COL1"
       ,CONCAT('윤영식','안석창')"COL2"
FROM DUAL;
--==>>윤영식안석창	윤영식안석창

SELECT ENAME || JOB "COL1"
       ,CONCAT(ENAME, JOB) "COL2"
FROM TBL_EMP;
--==>>
/*
SMITHCLERK	    SMITHCLERK
ALLENSALESMAN	ALLENSALESMAN
WARDSALESMAN	WARDSALESMAN
JONESMANAGER	JONESMANAGER
MARTINSALESMAN	MARTINSALESMAN
BLAKEMANAGER	BLAKEMANAGER
CLARKMANAGER	CLARKMANAGER
SCOTTANALYST	SCOTTANALYST
KINGPRESIDENT	KINGPRESIDENT
TURNERSALESMAN	TURNERSALESMAN
ADAMSCLERK	    ADAMSCLERK
JAMESCLERK	    JAMESCLERK
FORDANALYST	    FORDANALYST
MILLERCLERK	    MILLERCLERK
*/

SELECT ENAME || JOB || DEPTNO "COL1"
       , CONCAT(ENAME, JOB, DEPTNO) "COL2"
FROM TBL_EMP;
--==>> 에러 발생
/*
ORA-00909: invalid number of arguments
00909. 00000 -  "invalid number of arguments"
*Cause:    
*Action:
1,513행, 10열에서 오류 발생
*/
--> 2개의 문자열을 결합시켜주는 기능을 가진 함수
--  오로지 2개만 결합시킬 수 있다.

SELECT ENAME || JOB || DEPTNO "COL1"
       , CONCAT(CONCAT(ENAME, JOB), DEPTNO) "COL2"
FROM TBL_EMP;
/*
SMITHCLERK20	    SMITHCLERK20
ALLENSALESMAN30	    ALLENSALESMAN30
WARDSALESMAN30	    WARDSALESMAN30
JONESMANAGER20	    JONESMANAGER20
MARTINSALESMAN30	MARTINSALESMAN30
BLAKEMANAGER30	    BLAKEMANAGER30
CLARKMANAGER10	    CLARKMANAGER10
SCOTTANALYST20	    SCOTTANALYST20
KINGPRESIDENT10	    KINGPRESIDENT10
TURNERSALESMAN30	TURNERSALESMAN30
ADAMSCLERK20	    ADAMSCLERK20
JAMESCLERK30	    JAMESCLERK30
FORDANALYST20	    FORDANALYST20
MILLERCLERK10	    MILLERCLERK10
*/


--> 내부적인 형 변환이 일어나며  결합을 수행하게 된다.
--  CONCAT() 은 문자타입과 문자타입을 대상으로 결합을 수행하는 함수이지만
--  내부적으로 숫자나 날짜를 문자 타입으로 바꿔주는 과정이 포함되어 있다.


--CF) JAVA 의 String.subString()
/*
    obj.subString();
    ---
     |
    문자열.subString(n, m);        → 문자열 추출
                    ------
                    n 부터 m-1 까지(0부터 시작하는 인덱스 적용)
*/


--○ SUBSTR() 갯수 기반 / SUBSTRB() 바이트 기반 → 문자열 추출 함수
SELECT ENAME "COL1"
      ,SUBSTR(ENAME, 1, 2) "COL2"
      ,SUBSTR(ENAME, 2, 2) "COL3"
      ,SUBSTR(ENAME, 3, 2) "COL4"
      ,SUBSTR(ENAME, 2) "COL5"
FROM TBL_EMP;
--> 문자열을 추출하는 기능을 가진 함수
--  첫 번째 파라미터 값은 대상 문자열(추출의 대상)
--  두 번째 파라미터 값은 추출을 시작하는 위치(단, 인덱스는 1부터 시작)
--  세 번째 파라미터 값은 추출할 문자열의 갯수(생략 시... 시작위치부터 끝까지)
/*
SMITH	SM
ALLEN	AL
WARD	WA
JONES	JO
MARTIN	MA
BLAKE	BL
CLARK	CL
SCOTT	SC
KING	KI
TURNER	TU
ADAMS	AD
JAMES	JA
FORD	FO
MILLER	MI
*/



--○  TBL_SAWON 테이블에서 남직원들만
--    사원번호, 사원명, 주민번호, 급여 항목을 조회한다.
--    단, SUBSTR() 함수를 활용하여 처리할 수 있도록 하며,
--    급여 기준 내림차순 정렬을 수행할 수 있도록 한다.




SELECT SANO,SANAME,JUBUN,SAL
FROM TBL_SAWON
WHERE SUBSTR(JUBUN,7,1) = '1'
   OR SUBSTR(JUBUN,7,1) = '3'
ORDER BY SAL DESC;
/*
1003	정영훈	9709061234567	5000
1004	문제정	9608051234567	4000
1011	선동열	7012181234567	3000
1001	김정현	9804111234567	3000
1017	정우	8502031234567	2000
1016	남진	7108051234567	2000
1007	이상이	8512161234567	2000
1014	남희석	0502033234567	1000
1008	이이경	8904051234567	1000
*/



--○ LENGTH() / LENGTHB()

SELECT ENAME "COL1"
      ,LENGTH(ENAME) "COL2"
      ,LENGTHB(ENAME) "COL3"
FROM TBL_EMP;
--> LENGTH() 는 글자 수를 반환, LENGTHB()는 바이트 수를 반환
--==>>
/*
SMITH	5	5
ALLEN	5	5
WARD	4	4
JONES	5	5
MARTIN	6	6
BLAKE	5	5
CLARK	5	5
SCOTT	5	5
KING	4	4
TURNER	6	6
ADAMS	5	5
JAMES	5	5
FORD	4	4
MILLER	6	6
*/



--○ 확인
SELECT *
FROM NLS_DATABASE_PARAMETERS;
--==>>
/*
NLS_LANGUAGE	AMERICAN
NLS_TERRITORY	AMERICA
NLS_CURRENCY	$
NLS_ISO_CURRENCY	AMERICA
NLS_NUMERIC_CHARACTERS	.,
NLS_CHARACTERSET	AL32UTF8
NLS_CALENDAR	GREGORIAN
NLS_DATE_FORMAT	DD-MON-RR
NLS_DATE_LANGUAGE	AMERICAN
NLS_SORT	BINARY
NLS_TIME_FORMAT	HH.MI.SSXFF AM
NLS_TIMESTAMP_FORMAT	DD-MON-RR HH.MI.SSXFF AM
NLS_TIME_TZ_FORMAT	HH.MI.SSXFF AM TZR
NLS_TIMESTAMP_TZ_FORMAT	DD-MON-RR HH.MI.SSXFF AM TZR
NLS_DUAL_CURRENCY	$
NLS_COMP	BINARY
NLS_LENGTH_SEMANTICS	BYTE
NLS_NCHAR_CONV_EXCP	FALSE
NLS_NCHAR_CHARACTERSET	AL16UTF16
NLS_RDBMS_VERSION	11.2.0.2.0
*/




--※ 한글 데이터를 처리할 경우
--   바이트 기반으로 처리해야만 하는 상황이라면
--   항상 인코딩 방식을 잘 체크하고 사용해야 한다.

--○ INSTR()
SELECT 'ORACLE ORAHOME BIORA' "COL1"
        ,INSTR('ORACLE ORAHOME BIORA', 'ORA',1,1)"COL2"
        ,INSTR('ORACLE ORAHOME BIORA', 'ORA',1,2)"COL3"
        ,INSTR('ORACLE ORAHOME BIORA', 'ORA',2,1)"COL4"
        ,INSTR('ORACLE ORAHOME BIORA', 'ORA',2)"COL5"
        ,INSTR('ORACLE ORAHOME BIORA', 'ORA',2,2)"COL6"
FROM DUAL;
--==>> ORACLE ORAHOME BIORA	1	8	8	8	18
--> 첫 번째 파라미터 값에 해당하는 문자열에서...(대상 문자열)
--  두 번째 파라미터 값을 통해 넘겨준 문자열이 등장하는 위치를 찾아라!
--  세 번째 파라미터 값은 찾기 시작하는 (즉, 스캔을 시작하는) 위치
--  네 번째 파라미터 값은 몇 번재 등장하는 값을 찾을 것인지에 대한 설정(1은 생략 가능)

SELECT '나의오라클 집으로오라 합니다' "COL1"
       ,INSTR('나의오라클 집으로오라 합니다','오라',1)"COL2"       --3
       ,INSTR('나의오라클 집으로오라 합니다','오라',2)"COL3"       --3
       ,INSTR('나의오라클 집으로오라 합니다','오라',10)"COL4"      --10
       ,INSTR('나의오라클 집으로오라 합니다','오라',11)"COL5"      --0
FROM DUAL;
--==>> 나의오라클 집으로오라 합니다	3	3	10	0
--> 네 번째 파라미터(마지막 파라미터)를 생략한 형태로 사용! → 1 


--○ REVERSE()
SELECT 'ORACLE' "COL1"
      ,REVERSE('ORACLE') "COL2"
      ,REVERSE('오라클') "COL3"
FROM DUAL;
--> 대상 문자열(매개 변수)을 거꾸로 반환한다.(→ 한글 깨짐 유의)
--==>> ORACLE	ELCARO	???



--○  실습 테이블 생성
-- 테이블명 : TBL_FILES
CREATE TABLE TBL_FILES
(FILENO     NUMBER(3)
,FILENAME   VARCHAR2(100)
);
--==>> Table TBL_FILES이(가) 생성되었습니다.


--○ 데이터 입력
INSERT INTO TBL_FILES VALUES(1, 'C:\AAA\BBB\CCC\SALES.DOC');
INSERT INTO TBL_FILES VALUES(2, 'C:\AAA\PANMAE.XLSX');
INSERT INTO TBL_FILES VALUES(3, 'D:\RESEARCH.PPT');
INSERT INTO TBL_FILES VALUES(4, 'C:\DOCUMENTS\STUDY\STUDY.HWP');
INSERT INTO TBL_FILES VALUES(5, 'C:\DOCUMENTS\TEMP\SIST\TEST.PNG');
INSERT INTO TBL_FILES VALUES(6, 'D:\SHARE\F\EXAMPLE.JPG');
INSERT INTO TBL_FILES VALUES(7, 'C:\USER\CLASSF\PROJECT\20241103_JAVA.PPTX');
INSERT INTO TBL_FILES VALUES(8, 'C:\ORACLESTUDY\20241119_01_SCOTT.SQL');

SELECT *
FROM TBL_FILES;

COMMIT;









SELECT USER
FROM DUAL;
--==>> SCOTT


SELECT *
FROM TBL_FILES;
--==>> 
/*
1	C:\AAA\BBB\CCC\SALES.DOC
2	C:\AAA\PANMAE.XLSX
3	D:\RESEARCH.PPT
4	C:\DOCUMENTS\STUDY\STUDY.HWP
5	C:\DOCUMENTS\TEMP\SIST\TEST.PNG
6	D:\SHARE\F\EXAMPLE.JPG
7	C:\USER\CLASSF\PROJECT\20241103_JAVA.PPTX
8	C:\ORACLESTUDY\20241119_01_SCOTT.SQL
*/

SELECT FILENO "파일번호",FILENAME"파일명"
FROM TBL_FILES;
/*
파일번호  파일명
----    -----------------------
1	    C:\AAA\BBB\CCC\SALES.DOC
2	    C:\AAA\PANMAE.XLSX
3	    D:\RESEARCH.PPT
4	    C:\DOCUMENTS\STUDY\STUDY.HWP
5	    C:\DOCUMENTS\TEMP\SIST\TEST.PNG
6	    D:\SHARE\F\EXAMPLE.JPG
7	    C:\USER\CLASSF\PROJECT\20241103_JAVA.PPTX
8	    C:\ORACLESTUDY\20241119_01_SCOTT.SQL
*/
/*
파일번호  파일명
----    -----------------------
1	    SALES.DOC
2	    PANMAE.XLSX
3	    RESEARCH.PPT
4	    STUDY.HWP
5	    TEST.PNG
6	    EXAMPLE.JPG
7	    20241103_JAVA.PPTX
8	    20241119_01_SCOTT.SQL

--○  TBL_FILES 테이블을 대상으로
--    위와 같이 조회될 수 있도록 쿼리문을 구성한다.
--    (파일명,확장자)
*/


SELECT REVERSE(SUBSTR(REVERSE(FILENAME),1,(INSTR(REVERSE(FILENAME), '\',1,1)-1)))"파일명"
FROM TBL_FILES;



SELECT 
SUBSTR(REVERSE(FILENAME),INSTR(REVERSE(FILENAME),'\',1,1),INSTR((REVERSE(FILENAME)),'.',1,1))
--INSTR(REVERSE(FILENAME),'\',1,1)
--INSTR((REVERSE(FILENAME)),'.',1,1)
FROM TBL_FILES;




SELECT FILENO"파일번호",FILENAME"경로포함파일명"
        ,REVERSE(FILENAME)"거꾸로된경로포함파일명"
FROM TBL_FILES;
--==>> 에러발생(ALIAS가 너무길어서 발생한 오류)
/*
ORA-00972: identifier is too long
00972. 00000 -  "identifier is too long"
*Cause:    An identifier with more than 128 bytes was specified,
           or a password identifier longer than 30 bytes was specified.
*Action:   Specify at most 128 bytes for identifiers,
           and at most 30 bytes for password identifiers.
68행, 9열에서 오류 발생
*/


SELECT FILENO"파일번호",FILENAME"경로포함파일명"
        ,REVERSE(FILENAME)"거꾸로된경로포함파일"
FROM TBL_FILES;
/*
1	C:\AAA\BBB\CCC\SALES.DOC	                COD.SELAS\CCC\BBB\AAA\:C
2	C:\AAA\PANMAE.XLSX	                        XSLX.EAMNAP\AAA\:C
3	D:\RESEARCH.PPT	                            TPP.HCRAESER\:D
4	C:\DOCUMENTS\STUDY\STUDY.HWP	            PWH.YDUTS\YDUTS\STNEMUCOD\:C
5	C:\DOCUMENTS\TEMP\SIST\TEST.PNG	            GNP.TSET\TSIS\PMET\STNEMUCOD\:C
6	D:\SHARE\F\EXAMPLE.JPG	                    GPJ.ELPMAXE\F\ERAHS\:D
7	C:\USER\CLASSF\PROJECT\20241103_JAVA.PPTX	XTPP.AVAJ_30114202\TCEJORP\FSSALC\RESU\:C
8	C:\ORACLESTUDY\20241119_01_SCOTT.SQL	    LQS.TTOCS_10_91114202\YDUTSELCARO\:C

*/


-- 최초 등장한 '/' 직전까지 추출한 예상 결과
/*
COD.SELAS               \CCC\BBB\AAA\:C                 10 (-1) → 9
XSLX.EAMNAP             \AAA\:C                         12 (-1) → 11
TPP.HCRAESER            \:D                                  :
PWH.YDUTS               \STNEMUCOD\:C                        :
GNP.TSET                \TSYS\PMET\STNEMUCOD\:C
GPJ.ELPMAXE             \F\ERAHS\:D
XTPP.AVAJ_30114202      \TCEJORP\FSSALC\RESU\:C
LQS.TTOCS_10_91114202   \YDUTSELCARO\:C
*/


-- 최초 '\'가 등장하는 위치

SELECT INSTR(REVERSE(FILENAME),'\',1)          -- 마지막 매개변수 1 생략
FROM TBL_FILES;
--==>>
/*
10
12
13
10
9
12
19
22
*/

SELECT FILENO"파일번호",FILENAME"경로포함파일명"
        , SUBSTR(REVERSE(FILENAME),1,최초 '\'가 등장하는 위치 -1)"거꾸로된파일명"
FROM TBL_FILES;

SELECT FILENO"파일번호",FILENAME"경로포함파일명"
        , SUBSTR(REVERSE(FILENAME),1,INSTR(REVERSE(FILENAME),'\',1)-1)"거꾸로된파일명"
FROM TBL_FILES;

--==>>
/*
1	C:\AAA\BBB\CCC\SALES.DOC	                COD.SELAS
2	C:\AAA\PANMAE.XLSX	                        XSLX.EAMNAP
3	D:\RESEARCH.PPT	                            TPP.HCRAESER
4	C:\DOCUMENTS\STUDY\STUDY.HWP	            PWH.YDUTS
5	C:\DOCUMENTS\TEMP\SIST\TEST.PNG	            GNP.TSET
6	D:\SHARE\F\EXAMPLE.JPG	                    GPJ.ELPMAXE
7	C:\USER\CLASSF\PROJECT\20241103_JAVA.PPTX	XTPP.AVAJ_30114202
8	C:\ORACLESTUDY\20241119_01_SCOTT.SQL	    LQS.TTOCS_10_91114202
*/


SELECT FILENO"파일번호",FILENAME"경로포함파일명"
        , REVERSE(SUBSTR(REVERSE(FILENAME),1,INSTR(REVERSE(FILENAME),'\',1)-1))"거꾸로된파일명"
FROM TBL_FILES;

/*
1	C:\AAA\BBB\CCC\SALES.DOC	                SALES.DOC
2	C:\AAA\PANMAE.XLSX	                        PANMAE.XLSX
3	D:\RESEARCH.PPT	                            RESEARCH.PPT
4	C:\DOCUMENTS\STUDY\STUDY.HWP	            STUDY.HWP
5	C:\DOCUMENTS\TEMP\SIST\TEST.PNG	            TEST.PNG
6	D:\SHARE\F\EXAMPLE.JPG	                    EXAMPLE.JPG
7	C:\USER\CLASSF\PROJECT\20241103_JAVA.PPTX	20241103_JAVA.PPTX
8	C:\ORACLESTUDY\20241119_01_SCOTT.SQL	    20241119_01_SCOTT.SQL
*/


SELECT FILENO"파일번호"
        , REVERSE(SUBSTR(REVERSE(FILENAME),1,INSTR(REVERSE(FILENAME),'\',1)-1))"거꾸로된파일명"
FROM TBL_FILES;

/*
1	SALES.DOC
2	PANMAE.XLSX
3	RESEARCH.PPT
4	STUDY.HWP
5	TEST.PNG
6	EXAMPLE.JPG
7	20241103_JAVA.PPTX
8	20241119_01_SCOTT.SQL
*/



--○ LPAD()
--> Byte 공간을 확보하여 왼쪽부터 문자로 채우는 기능을 가진 함수
SELECT 'ORACLE'"COL1"
        ,LPAD('ORACLE',10,'*')"COL2"   --두번째 파라미터 부터 보자!!
FROM DUAL;
--==>> ORACLE	****ORACLE

--> ① 10Byte 공간을 확보한다.                                                  → 두 번째 파라미터 값에 의해...
--  ② 확보한 공간에 'ORACLE' 문자열을 담는다.                                  → 첫 번째 파라미터 값에 의해...
--  ③ 남아있는 Byte 공간(4Byte)을 왼쪽부터 세 번째 파라미터 값으로 채운다.
--  ④ 이렇게 구성된 최종 결과값을 반환한다.


--○ RPAD()
--> Byte 공간을 확보하여 오른쪽부터 문자로 채우는 기능을 가진 함수
SELECT 'ORACLE'"COL1"
        ,RPAD('ORACLE',10,'*')"COL2"   --두번째 파라미터 부터 보자!!
FROM DUAL;
--==>>ORACLE	ORACLE****
--> ① 10Byte 공간을 확보한다.                                                  → 두 번째 파라미터 값에 의해...
--  ② 확보한 공간에 'ORACLE' 문자열을 담는다.                                  → 첫 번째 파라미터 값에 의해...
--  ③ 남아있는 Byte 공간(4Byte)을 오른쪽부터 세 번째 파라미터 값으로 채운다.
--  ④ 이렇게 구성된 최종 결과값을 반환한다.



--○ LTRIM()
SELECT 'ORAORAORACLEORACLE'"COL1"                           --오라 오라 오라클 오라클
        ,LTRIM('ORAORAORACLEORACLE', 'ORA')"COL2"           --단위가 문장이아닌 한개의 문자단위
        ,LTRIM('AAAORAORAORACLEORACLE', 'ORA')"COL3"
        ,LTRIM('ORAoRAORACLEORACLE', 'ORA')"COL4"
        ,LTRIM('ORA RAORACLEORACLE', 'ORA')"COL5"
        ,LTRIM('                        ORAORACLEORACLE', ' ')"COL6"
        ,LTRIM('                        ORAORACLEORACLE')"COL7"     -- 왼쪽 공백 제거 함수로 활용(두 번째 파라미터 생략)
FROM DUAL;
--==>>
/*
ORAORAORACLEORACLE	
CLEORACLE	
CLEORACLE	
oRAORACLEORACLE	 
 RAORACLEORACLE	
ORAORACLEORACLE	
ORAORACLEORACLE
*/
--> 첫 번째 파라미터 값에 해당하는 문자열을 대상으로
--  왼쪽부터 연속적으로 두 번째 파라미터 값에서 지정한 문자와 같은 문자가 등장할 경우
--  이를 제거한 결과값을 반환하게 된다.
--  단, 완성형으로 처리되지 않는다.



--○ RTRIN()

SELECT 'ORAORAORACLEORACLE'"COL1"                           --오라 오라 오라클 오라클
        ,RTRIM('ORAORAORACLEORACLE', 'ORA')"COL2"           --단위가 문장이아닌 한개의 문자단위
        ,RTRIM('AAAORAORAORACLEORACLE', 'ORA')"COL3"
        ,RTRIM('ORAoRAORACLEORACLE', 'ORA')"COL4"
        ,RTRIM('ORA RAORACLEORACLE', 'ORA')"COL5"
        ,RTRIM('                        ORAORACLEORACLE', ' ')"COL6"
        ,RTRIM('                        ORAORACLEORACLE')"COL7"     -- 왼쪽 공백 제거 함수로 활용(두 번째 파라미터 생략)
FROM DUAL;
--==>>
/*
ORAORAORACLEORACLE	
ORAORAORACLEORACLE	
AAAORAORAORACLEORACLE	
ORAoRAORACLEORACLE	
ORA RAORACLEORACLE	                        
                        ORAORACLEORACLE	                        
                        ORAORACLEORACLE
*/
--> 첫 번째 파라미터 값에 해당하는 문자열을 대상으로
--  오른쪽부터 연속적으로 두 번째 파라미터 값에서 지정한 문자와 같은 문자가 등장할 경우
--  이를 제거한 결과값을 반환하게 된다.
--  단, 완성형으로 처리되지 않는다.


SELECT LTRIM('김김김윤안박김문곽이엄임안박정정박공','김윤안박')"결과확인"
FROM DUAL;
--==>> 문곽이엄임안박정정박공




--○ TRANSLATE()
--> 1 : 1 로 바꾸는 과정을 수행한다.

SELECT TRANSLATE('MY ORACLE SERVER'
                , 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
                , 'abcdefghijklmnopqrstuvwxyz')"결과확인"
FROM DUAL;
--==>> my oracle server


SELECT TRANSLATE('010-2866-3928'
                    ,'0123456789'
                    ,'영일이삼사오육칠팔구')"결과확인"
FROM DUAL;
--==>> 영일영-이팔육육-삼구이팔


--○ REPLACE()
SELECT REPLACE('MY ORACLE ORAHOME','ORA','오라')"결과확인"
FROM DUAL;
--==>> MY 오라CLE 오라HOME


--------------------------------------------------------------------------------

--○ ROUND() 반올림을 처리해 주는 함수(두번째 파라미터는 해당하는 숫자 자리만큼 표현하라는뜻)
SELECT 48.678"COL1"                         --48.678
        , ROUND(48.678, 2) "COL2"           --48.68             --EX) 소수점 이하 둘째자리까지 표현(셋째 자리에서 반올림)
        , ROUND(48.674, 2) "COL3"           --48.67
        , ROUND(48.674, 1) "COL4"           --48.7
        , ROUND(48.674, 0) "COL5"           --49                -- 0 은 정수만 반환하기 떄문에 소숫점 첫번째 자리에서 반올림
        , ROUND(48.674) "COL6"              --49                -- 두 번째 파라미터 값이 0 일 경우 생략 가능
        , ROUND(48.674, -1) "COL7"          --50                -- 십의자리(48중에서 8)를 반올림  하라는 뜻
        , ROUND(48.674, -2) "COL8"          -- 0                -- 백의자리(48중에서 없음)를 반올림  하라는 뜻
        , ROUND(48.674, -3) "COL9"          -- 0                -- 천의자리(48중에서 없음)를 반올림  하라는 뜻
FROM DUAL;


--○  TRUNC() 절삭을 처리해 주는 함수


SELECT 48.678"COL1"                         --48.678
        , TRUNC(48.678, 2) "COL2"           --48.67            -- 소수점 이하 둘째자리까지 표현(셋째 자리에서 절삭)
        , TRUNC(48.674, 2) "COL3"           --48.67
        , TRUNC(48.674, 1) "COL4"           --48.6
        , TRUNC(48.674, 0) "COL5"           --48                
        , TRUNC(48.674) "COL6"              --48                
        , TRUNC(48.674, -1) "COL7"          --40                
        , TRUNC(48.674, -2) "COL8"          -- 0                
        , TRUNC(48.674, -3) "COL9"          -- 0                
FROM DUAL;



--○ MOD() 나머지를 반환하는 함수 → %
SELECT MOD(5,2)"결과확인"
FROM DUAL;
--==>>1
--> 5를 2로 나눈 나머지 결과값 반환

--○ POWER() 제곱의 결과를 반환하는 함수
SELECT POWER(5,3)"결과확인"
FROM DUAL;
--==>>125
--> 5의 3제곱(5의 3승)을 결과값을 반환


--○ SQRT() 루트 결과값을 반환하는 함수
SELECT SQRT(2)"결과확인"
FROM DUAL;
--==>>1.41421356237309504880168872420969807857
--> 루트 2에 대한 결과값을 반환


--○ LOG() 로그 함수
SELECT LOG(10,100)"COL1"
      ,LOG(10,20)"COL2"
FROM DUAL;
--==>> 2	1.30102999566398119521373889472449302677
-- ○ 오라클은 상용로그만 지원하는 반면, MS-SQL은 상용로그와 자연로그 모두 지원한다.



--○ 삼각함수
SELECT SIN(1), COS(1), TAN(1)
FROM DUAL;
--==>>
/*
0.8414709848078965066525023216302989996233	
0.5403023058681397174009366074429766037354	
1.55740772465490223050697480745836017308
*/
--  싸인,코싸인, 탄젠트 결과값을 반환한다.



--○ 삼각함수의 역함수(범위 : -1 ~ 1)
SELECT ASIN(0.5),ACOS(0.5),ATAN(0.5)
FROM DUAL;
--==>>
/*
0.52359877559829887307710723054658381405	
1.04719755119659774615421446109316762805	
0.4636476090008061162142562314612144020295
*/
--> 어싸인,어코싸인,어탄젠트 결과값을 반환한다.



--○ SIGN()     서명, 부호, 특징
--   연산 결과값이 양수면 1, 0이면 0, 음수이면 -1을 반환한다.
SELECT SIGN(5-2) "COL1"
      ,SIGN(5-5) "COL2"
      ,SIGN(5-7) "COL3"
FROM DUAL;
--> 매출이나 수지와 관련하여 적자 및 흑자의 개념을 표현할 때 주로 사용한다.




--○ ASCII(), CHR()  → 서로 대응하는 개념의 함수
SELECT ASCII('A')"COL1"
      ,CHR(65) "COL2"
FROM DUAL;
--==>> 65	A
-- ASCII() : 매개변수로 넘겨받은 문자의 아스키코드 값을 반환한다.
-- CHR()   : 매개변수로 남겨받은 숫자를 아스키코드 값으로 취하는 문자를 반환한다.



--------------------------------------------------------------------------------


--※ 날짜 관련 세션 설정
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.

--※ 날짜연산의 기본 단위는 DAY(일수)이다

SELECT SYSDATE "COL1"               -- 2024-11-20 11:41:00      → 현재
        , SYSDATE + 1 "COL2"        -- 2024-11-21 11:41:00      → 1일 후
        , SYSDATE - 2 "COL3"        -- 2024-11-18 11:41:00      → 2일 전
        , SYSDATE + 3 "COL4"        -- 2024-11-23 11:41:00      → 3일 후
FROM DUAL;

--○ 시간 단위 연산
SELECT SYSDATE "COL1"                   -- 현재
        ,SYSDATE + 1/24 "COL2"          -- 1시간 후
        ,SYSDATE - 2/24 "COL3"          -- 2시간 전
FROM DUAL;
--==>> 2024-11-20 11:43:52	2024-11-20 12:43:52	2024-11-20 09:43:52

--○ 현재시간과... 현재 시간 기준 1일 2시간 3분 4초 후를 조회하는 쿼리문을 구성한다

/*
--------------------------------------------------------------------
             현재시간                         연산후시간
--------------------------------------------------------------------
        2024-11-20  11:44:30            2024-11-20 11:44:30
--------------------------------------------------------------------
*/

--방법1

SELECT SYSDATE "현재시간"
        , SYSDATE + (2/24) + (3/(24/60)) + (4/(24*60*60))"연산후 시간"
FROM DUAL;
--==>>
/*
2024-11-20 12:04:43	
2024-11-28 02:04:47
*/

--방법2
SELECT SYSDATE "현재시간"
        , SYSDATE + ((24*60*60) + (2*60*60) + (3*60) + 4) / (24*60*60)"연산후시간"
FROM DUAL;
/*
2024-11-20 12:06:33	
2024-11-21 14:09:37
*/


--내가 한 연산
SELECT SYSDATE "COL1"
        , SYSDATE + 1 + 2/24 + 3/1440 + 4/86400
FROM DUAL;


--○ 날짜 - 날짜 = 일수(DAY)
-- EX) (2025-04-23) - (2024-11-20)
--        수료일         현재일


--※ 데이터 타입의 변환
SELECT TO_DATE('2025-04-23', 'YYYY-MM-DD')      -- 날짜 타입으로 변환
FROM DUAL;
--==>> 2025-04-23 00:00:00

SELECT TO_DATE('2025-04-33', 'YYYY-MM-DD')
FROM DUAL;
--==>>에러발생
/*
ORA-01847: day of month must be between 1 and last day of month
01847. 00000 -  "day of month must be between 1 and last day of month"
*Cause:    
*Action:
*/


SELECT TO_DATE('2025-13-23', 'YYYY-MM-DD')
FROM DUAL;
--==>>
/*
ORA-01843: not a valid month
01843. 00000 -  "not a valid month"
*Cause:    
*Action:
*/


--※ TO_DATE() 함수를 통해 문자 타입을 날짜 타입으로 변환을 수행할 때
--   내부적으로 해당 날짜에 대한 유효성 검사가 이루어진다.


--○ ADD_MONTHS() 개월 수를 더해주는 함수
SELECT SYSDATE"COL1"
        ,ADD_MONTHS(SYSDATE,2)"COL2"
        ,ADD_MONTHS(SYSDATE,3)"COL3"
        ,ADD_MONTHS(SYSDATE,-2)"COL4"
        ,ADD_MONTHS(SYSDATE,-3)"COL5"
FROM DUAL;
--==>>
/*
2024-11-20 12:14:03	        -- 현재
2025-01-20 12:14:03	        -- 2개월 후
2025-02-20 12:14:03	        -- 3개월 후
2024-09-20 12:14:03	        -- 2개월 전
2024-08-20 12:14:03         -- 3개월 전
*/
--> 개월 수를 더하고 빼기

--※ 닐짜 관련 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>>Session이(가) 변경되었습니다.



--○ MONTHS_BETWEEN()
--   첫 번째 인자값에서 두 번째 인자값을 뺀 개월 수를 반환
SELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('2002-05-31','YYYY-MM-DD'))
FROM DUAL;
--==>>269.661745445041816009557945041816009558
-->  개월 수의 차이를 반환하는 함수
--※ 결과값의 부호가 『-』(음수)로 반환되었을 경우에는
--   첫 번째 인자값에 해당하는 날짜보다
--   두 번째 인자값에 해당하는 날짜가 『미래』라는 의미로 확인할 수 있다.

SELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('2025-04-23','YYYY-MM-DD'))
FROM DUAL;
--==>> -5.0801821983273596176821983273596176822


--○ NEXT_DAY()
--   첫 번째 인자값을 기준 날짜로 돌아오는 가장 빠른 "요일" 반환
SELECT NEXT_DAY(SYSDATE,'토')"COL1"
        ,NEXT_DAY(SYSDATE,'수')"COL1"
FROM DUAL;
--==>>2024-11-23	2024-11-27



--○ 추가 세션 설정
ALTER SESSION SET NLS_DATE_LANGUAGE = 'ENGLISH';
--==>>Session이(가) 변경되었습니다.

--○ 세션 설정 변경 이후 위의 쿼리문을 그대로 다시 실행
SELECT NEXT_DAY(SYSDATE,'토')"COL1"
        ,NEXT_DAY(SYSDATE,'수')"COL1"
FROM DUAL;
--==>> 에러발생
/*
ORA-01846: not a valid day of the week
01846. 00000 -  "not a valid day of the week"
*Cause:    
*Action:
*/

SELECT NEXT_DAY(SYSDATE,'SAT')"COL1"
        ,NEXT_DAY(SYSDATE,'SUN')"COL1"
FROM DUAL;
--==>> 2024-11-23	2024-11-24




--○ 추가 세션 설정
ALTER SESSION SET NLS_DATE_LANGUAGE = 'KOREAN';
--==>> Session이(가) 변경되었습니다.




SELECT NEXT_DAY(SYSDATE,'SAT')"COL1"
        ,NEXT_DAY(SYSDATE,'SUN')"COL1"
FROM DUAL;
--==>> 에러발생
/*
ORA-01846: not a valid day of the week
01846. 00000 -  "not a valid day of the week"
*Cause:    
*Action:
*/



--○ LAST_DAY()
--   해당 날짜가 포함되어 있는 그 달의 마지막 날을 반환한다.
SELECT LAST_DAY(SYSDATE)"결과확인"
FROM DUAL;
--==>> 2024-11-30



--○ 오늘부로...지우가...군대에 또 끌려(?)간다.
--   복무기간은 22개월로 한다.

--   1.전역 일자를 구한다.

SELECT ADD_MONTHS(SYSDATE,22) "전역일자"
FROM DUAL;

--   2. 하루 꼬박꼬박 3끼 식사를 해야 한다고 가정하면
--      지우가 몇 끼를 먹어야 집에 보내줄까...

-- 복무기간 * 3 
-- --------
-- (전역일자 - 현재일자)

-- (전역일자 - 현재일자) * 3

SELECT (ADD_MONTHS(SYSDATE,22) - SYSDATE) * 3
FROM DUAL;
--==>> 2007

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>>Session이(가) 변경되었습니다.

--○ 현재 날짜 및 시간을 기준으로...
--   수료일(2025-04-23 18:00:00)까지 남은 기간을...
--   다음과 같은 형태로 조회할 수 있도록 쿼리문을 구성한다.
/*
----------------------------------------------------------------------------
현재시각                |수료일                |      일| 시간|    분|  초|
----------------------------------------------------------------------------
2024-11-20 12:46:50     |2025-04-23 18:00:00   |        |     |      |    |
----------------------------------------------------------------------------
*/
--내가 한 풀이(못품 ;;)
SELECT   SYSDATE"현재시각",TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')"수료일"
        ,ROUND(TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS') - SYSDATE)"일"
        ,TRUNC(SUBSTR(TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS') - 
         SYSDATE,INSTR(TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS') - SYSDATE,'.',1))*24,0)"시간"
FROM DUAL;

--『1일 2시간 3분 4초』를... 『초』로 환산하면...
SELECT (1*24*60*60) + (2*60*60) + (3*60) + (4)
FROM DUAL;
--==>> 93784

-- 『93784초』를 다시 『일,시간,분,초』로 환산하면...
SELECT   TRUNC(TRUNC(TRUNC(93784/60)/60)/24)"시간"
        ,MOD(TRUNC(TRUNC(93784/60)/60),24)"시간"
        ,MOD(TRUNC(93784/60),60)"분"
        ,MOD(93784,60)"초"
FROM DUAL;
--==>>
/*

                일           시간          분           초
        ---------- -------------- ----------- ------------
                 1              2          3             4
*/

-- 수료일까지 남은 기간 확인(날짜 기준) → 단위 : 일수


SELECT TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')"수료일자"
FROM DUAL;
--==>> 2025-04-23 18:00:00 → 날짜 형식

SELECT TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')-SYSDATE"수료일자"
FROM DUAL;
--==>> 154.105532407407407407407407407407407407


-- 수료일까지 남은 기간 확인(날짜 기준) → 단위 : 초
SELECT (수요일까지 남은 일수) * (24*60*60)
FROM DUAL;
--> 수요일까지 남아있는 전체 초

SELECT (TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')-SYSDATE) * (24*60*60)
FROM DUAL;
--==>> 13313993.00000000000000000000000000000003



SELECT   TRUNC(TRUNC(TRUNC((TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')-SYSDATE) * (24*60*60)/60)/60)/24)"시간"
        ,MOD(TRUNC(TRUNC((TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')-SYSDATE) * (24*60*60)/60)/60),24)"시간"
        ,MOD(TRUNC((TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')-SYSDATE) * (24*60*60)/60),60)"분"
        ,TRUNC(MOD((TO_DATE('2025-04-23 18:00:00','YYYY-MM-DD HH24:MI:SS')-SYSDATE) * (24*60*60),60))"초"
FROM DUAL;
--==>> 154	2	19	3





--○ 과제
--   본인이 태어나서 현재까지...
--   얼마만큼의 일, 시간, 분, 초를 살고 있는지
--   조회하는 쿼리문을 구성한다.
/*
----------------------------------------------------------------------------
현재시각                |태어난시각            |      일| 시간|    분|  초|
----------------------------------------------------------------------------
2024-11-20 12:46:50     |2025-04-23 18:00:00   |        |     |      |    |
----------------------------------------------------------------------------
*/


SELECT SYSDATE - TO_DATE('1995-06-12 10:00:00','YYYY-DD-MM HH24:MI:SS')
FROM DUAL;

--이때까지 살아온걸 초 로 환산
SELECT (SYSDATE - TO_DATE('1995-06-12 10:00:00' ,'YYYY-DD-MM HH24:MI:SS'))*24*60*60
FROM DUAL;

-- 나머지값을 활용한 시간계산 로직(초 부터 계산하면 편함 ㅎ_ㅎ)
SELECT   TRUNC(TRUNC(TRUNC(96966/60)/60)/24) -- 일 나머지 값이 아닌 24로 나누게되면 일수가 된다(몫은 일 나머지는 시간인셈)
        ,MOD(TRUNC(TRUNC(96977/60)/60),24)  --시 , 나눈 분에서 24를 나누고 나머지값은 시간이 된다.
        ,MOD(TRUNC(96977/60),60) --분 , 전체 초에서 60을 나누고 그값을 또 60으로 나눈 나머지값은 분이된다.
        ,MOD(96977,60) -- 초  , 전체 초에서 60을 나눈 나머지값은 초가 된다.
FROM DUAL;

-- 로직에 내가 만들어놓은 초를 그대로 대입하기
SELECT  SYSDATE"현재시간",TO_DATE('1995-06-12 10:00:00' ,'YYYY-DD-MM HH24:MI:SS')"태어난시각"
        ,TRUNC(TRUNC(TRUNC((SYSDATE - TO_DATE('1995-06-12 10:00:00' ,'YYYY-DD-MM HH24:MI:SS'))*24*60*60/60)/60)/24)"일"
        ,MOD(TRUNC(TRUNC((SYSDATE - TO_DATE('1995-06-12 10:00:00' ,'YYYY-DD-MM HH24:MI:SS'))*24*60*60/60)/60),24)"시간"
        ,MOD(TRUNC((SYSDATE - TO_DATE('1995-06-12 10:00:00' ,'YYYY-DD-MM HH24:MI:SS'))*24*60*60/60),60)"분"
        ,TRUNC(MOD((SYSDATE - TO_DATE('1995-06-12 10:00:00' ,'YYYY-DD-MM HH24:MI:SS'))*24*60*60,60))"초"
FROM DUAL;

--       현재시각               태어난시각          총일수    시간     분    초
      -------------------   -------------------     -----     ----    ---- -----
--==>>2024-11-20 16:09:54	1995-12-06 10:00:00	    10577	    6	    9	 54



--○ 날짜 형식 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.



--※ 날짜 데이터를 대상으로 반올림, 절삭을 수행할 수 있다.

--○ 날짜 반올림
SELECT SYSDATE"COL1"                        -- 2024-11-20       → 기본 현재 날짜
       ,ROUND(SYSDATE, 'YEAR')"COL2"        -- 2025-01-01       → 년도까지 유효한 데이터(상반기,하반기 기준)
       ,ROUND(SYSDATE, 'MONTH')"COL3"       -- 2024-12-01       → 월까지 유효한 데이터(15일 기준)
       ,ROUND(SYSDATE, 'DD')"COL4"          -- 2024-11-21       → 날짜까지 유효한 데이터(정오 기준)
       ,ROUND(SYSDATE, 'DAY')"COL5"         -- 2024-11-24       → 날짜까지 유효한 데이터(수요일기준)
FROM DUAL;

--○ 날짜 절삭
SELECT SYSDATE "COL1"                       -- 2024-11-20       → 기본 현재 날짜
       ,TRUNC(SYSDATE, 'YEAR') "COL2"       -- 2024-01-01       → 년도까지 유효한 데이터
       ,TRUNC(SYSDATE, 'MONTH')"COL3"       -- 2024-11-01       → 월까지 유효한 데이터
       ,TRUNC(SYSDATE, 'DD')"COL4"          -- 2024-11-20       → 날짜까지 유효한 데이터
       ,TRUNC(SYSDATE, 'DAY')"COL5"         -- 2024-11-17       → 날짜까지 유효한 데이터  →   지난주 일요일
FROM DUAL;





--------------------------------------------------------------------------------

--■■■ 변환 함수 ■■■--

--TO_CHAR()     :  숫자나 날짜 데이터를 문자 타입으로 변환시켜주는 함수
--TO_DATE()     :  문자 데이터(날짜 형식)를 날짜타입으로 변환시켜주는 함수
--TO_NUMBER()   :  문자 데이터(숫자 형식)를 숫자타입으로 변환시켜주는 함수

SELECT 10 "COL1"
      ,TO_CHAR(10)"COL2"
FROM DUAL;
--==>> 10	10          숫자는 우측정렬 / 문자는 좌측정렬


--※  날짜나 통화 형식이 맞지 않을 경우
--    세션 설정값을 통해 설정할 수 있도록 한다.

ALTER SESSION SET NLS_LANGUAGE = 'KOREAN';
--==>>Session이(가) 변경되었습니다.


ALTER SESSION SET NLS_DATE_LANGUAGE = 'KOREAN';
--==>>Session이(가) 변경되었습니다.

ALTER SESSION SET NLS_CURRENCY = '\';           -- 화페단위 : 원(￦)
--==>> Session이(가) 변경되었습니다.


ALTER SESSION SET NLS_DATE_FORMAT = 'YYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


SELECT  TO_CHAR(SYSDATE,'YYYY-DD-MM')"COL1"     --2024-20-11
       ,TO_CHAR(SYSDATE, 'YYYY')                --2024
       ,TO_CHAR(SYSDATE, 'YEAR')                --TWENTY TWENTY-FOUR
       ,TO_CHAR(SYSDATE, 'MM')                  --11
       ,TO_CHAR(SYSDATE, 'MONTH')               --11월
       ,TO_CHAR(SYSDATE, 'MON')                 --11월
       ,TO_CHAR(SYSDATE, 'DD')                  --20
       ,TO_CHAR(SYSDATE, 'DAY')                 --수요일
       ,TO_CHAR(SYSDATE, 'DY')                  --수
       ,TO_CHAR(SYSDATE, 'HH24')                --17
       ,TO_CHAR(SYSDATE, 'HH')                  --05
       ,TO_CHAR(SYSDATE, 'HH AM')               --05 오후
       ,TO_CHAR(SYSDATE, 'HH PM')               --05 오후
       ,TO_CHAR(SYSDATE, 'MI')                  --11
       ,TO_CHAR(SYSDATE, 'SS')                  --50
       ,TO_CHAR(SYSDATE, 'SSSSS')               --61910     → 자정부터 시작해서 (금일)흘러온 초
       ,TO_CHAR(SYSDATE, 'Q')                   --4         → 분기
FROM DUAL;


SELECT '04'"COL1"
        ,TO_NUMBER('04')"COL2"
FROM DUAL;
--==>> 04	4       //숫자타입은 앞에 0이 생략



--○ EXTRACT()
SELECT TO_CHAR(SYSDATE, 'YYYY')"COL1"       --2024     →날짜로부터 연도를 추출해서 문자 타입으로 ┐
      ,TO_CHAR(SYSDATE, 'MM')"COL2"         --11       →날짜로부터 월을 추출해서 문자 타입으로   │ 문자타입
      ,TO_CHAR(SYSDATE, 'DD')"COL3"         --20       →날짜로부터 일을 추출해서 문자 타입으로   ┘
      ,EXTRACT(YEAR FROM SYSDATE)"COL4"     --2024     →날짜로부터 연도를 추출해서 숫자 타입으로┐
      ,EXTRACT(MONTH FROM SYSDATE)"COL5"    --11       →날짜로부터 월을 추출해서 숫자 타입으로  │숫자타입
      ,EXTRACT(DAY FROM SYSDATE)"COL6"      --20       →날짜로부터 일을 추출해서 숫자 타입으로  ┘
FROM DUAL;
--==>> 2024	11	20	2024	11	20
--> 년,월,일 이외의 다른 것은 불가



--○ TO_CHAR() 활용 추가 → 형식 맞춤 표기 결과값 반환
SELECT 80000 "COL1"                         -- 80000
      ,TO_CHAR(80000)"COL2"                 -- 80000
      ,TO_CHAR(80000, '99,999')"COL3"       -- 80,000
      ,TO_CHAR(80000, '$99,999')"COL4"      -- $80,000
      ,TO_CHAR(80000, 'L99,999')"COL5"      --           \80,000
      ,LTRIM(TO_CHAR(80000, 'L99,999'))
FROM DUAL;



--※ 날짜 세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>>Session이(가) 변경되었습니다.


--○  현재 시간을 기준으로 1일 2시간 3분 4초 후를 조회한다.
SELECT SYSDATE"현재시간"
        ,SYSDATE + 1 + (2/24) + (3/(24*60)) + (4/(24*60*60))
FROM DUAL;
--==>> 	
/*
2024-11-20 17:46:56
2024-11-21 19:50:00
*/

--○ 현재 시간을 기준으로 1년 2개월 3일 4시간 5분 6초 후를 조회한다.
--    TO_YMINTERVAL(), TO_DSINTERVAL()

SELECT SYSDATE "현재시간"
      ,SYSDATE + TO_YMINTERVAL('01-02') + TO_DSINTERVAL('003 04:05:06')"연산결과"
FROM DUAL;
--==>>
/*
2024-11-20 17:50:53	
2026-01-23 21:55:59
*/













SELECT USER
FROM DUAL;
--==>>SCOTT

--■■■CASE 구문(조건문,분기분)■■■--
/*
CASE
WHEN
THEN
ELSE
END
*/

SELECT CASE 5+2 WHEN 7 THEN '5+2=7' ELSE '5+2는몰라요'END "결과확인"
FROM DUAL;
--==>> 5+2=7

SELECT CASE 5+2 WHEN 3 THEN '5+2=7' ELSE '5+2는몰라요'END "결과확인"
FROM DUAL;
--==>> 5+2는몰라요

SELECT CASE WHEN 1+1=2 THEN'1+1=2'
            WHEN 1+1=3 THEN'1+1=3'
            WHEN 1+1=4 THEN'1+1=4'
            ELSE '몰라요'
            END"결과확인"
FROM DUAL;
--==>> 1+1=2



--○  DECODE()
SELECT DECODE(5-2, 1, '5-2=1', 2, '5-2=2', 3, '5-2=3', '5-2는 몰라')"결과확인"
FROM DUAL;
--==>>5-2=3


SELECT CASE WHEN 1+1=2 THEN'1+1=2'
            WHEN 1+1=3 THEN'1+1=3'
            WHEN 1+1=4 THEN'1+1=4'
            ELSE '몰라요'
            END"결과확인"
FROM DUAL;
--==>>1+1=2


SELECT CASE WHEN 1+1=2 THEN'1+1=2'
            WHEN 2+2=3 THEN'1+1=3'
            WHEN 3+3=4 THEN'1+1=4'
            ELSE '몰라요'
            END"결과확인"
FROM DUAL;
--==>>1+1=2


--○ CASE WHEN THEN ELSE END 구문 활용
SELECT CASE WHEN 5<2 THEN '5<2'
            WHEN 5>2 THEN '5>2'
            ELSE '5와 2는 비교불가'
            END "결과확인"
FROM DUAL;
--==>>5>2


SELECT CASE WHEN 5<2 OR 3>1THEN '영식만세'
            WHEN 5>2 OR 2=2THEN '유진만세'
            ELSE '세진만세'
            END "결과확인"
FROM DUAL;
--==>>영식만세

/*
SELECT CASE WHEN "FALSE" OR "TRUE" THEN '영식만세'
            WHEN 5>2 OR 2=2THEN '유진만세'
            ELSE '세진만세'
            END "결과확인"
FROM DUAL;
*/

-- 첫번째 결과가 트루이면 후에 오는 조건문은 반환하지 않고 처음만족한 조건문을 반환한다.

                 
SELECT CASE WHEN 3<1 AND 5<2 OR 3>1 AND 2=2 THEN '정현만세'
            WHEN 5<2 AND 2=2 THEN '태완만세'
            ELSE'성산만세'
        END"결과확인"
FROM DUAL;
--==>>정현만세
/*

SELECT CASE WHEN T THEN '정현만세'
            WHEN 5<2 AND 2=2 THEN '태완만세'
            ELSE'성산만세'
        END"결과확인"
FROM DUAL;


*/
                  
SELECT CASE WHEN 3<1 AND (5<2 OR 3>1) AND 2=2 THEN '정현만세'
            WHEN 5<2 AND 2=2 THEN '태완만세'
            ELSE'성산만세'
        END"결과확인"
FROM DUAL;
--==>> 성산만세
/*

SELECT CASE WHEN F THEN '정현만세'
            WHEN 5<2 AND 2=2 THEN '태완만세'
            ELSE'성산만세'
        END"결과확인"
FROM DUAL;

*/





ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';
--==>>Session이(가) 변경되었습니다.


SELECT *
FROM TBL_SAWON;

--○ TBL_SAWON 테이블을 활용하여 다음과 같은 항목들을 조회한다.
--   사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일
--   , 정년퇴직일, 근무일수, 남은일수(정년퇴직일까지), 급여,보너스


--   단, 현재나이는 만 나이 적용 방법이 아니라 기존의 한국 나이 계산법에 따라 연산을 수행한다.
--   또한, 정년퇴직일은 해당 직원의 나이가 한국나이로 65세가 되는 해(연도)의 
--   그 직원의 입사 월, 일로 연산을 수행한다.
--   그리고 보너스는 근무일수에 따라 책정하며 
--   근무일수가 5000일 이상 6000일 미만 근무한 사원은 그 사원의 급여 기준 30% 지급,
--   근무일수가 6000일 이상 근무한 사원은 해당 사원의 급여 기준 50% 지급을 할 수 있도록 처리한다.



SELECT SANO"사원번호",SANAME"사원명",JUBUN"주민번호"
        ,CASE SUBSTR(JUBUN,7,1) WHEN '1' THEN '남성'
                                WHEN '2' THEN '여성'
                                WHEN '3' THEN '남성'
                                WHEN '4' THEN '여성'
                            END"성별"
        
        ,CASE WHEN TO_NUMBER(SUBSTR(JUBUN,1,1))=0 THEN 2024-(TO_NUMBER(SUBSTR(JUBUN,1,2))+2000)+1
         ELSE 2024-(TO_NUMBER(SUBSTR(JUBUN,1,2))+1900)+1END"나이"
        ,HIREDATE"입사일"
        ,TRUNC(SYSDATE - HIREDATE) "근무일수"
        ,CASE WHEN TRUNC(SYSDATE - HIREDATE)>5000 OR TRUNC(SYSDATE - HIREDATE)<6000 THEN SAL*0.3 
         WHEN TRUNC(SYSDATE - HIREDATE)>6000 THEN SAL*0.5 ELSE 0 END"보너스"
FROM TBL_SAWON;





-- 65세가되면 몇년 몇월 몇일인가
-- 65에서 현재나이를 뺴면 남은 년수가 나온다
-- 65세까지의 나이를 구함
SELECT   CASE WHEN TO_NUMBER(SUBSTR(JUBUN,1,1))=0 
         THEN (TO_NUMBER(SUBSTR(JUBUN,1,2))+2000)
         ELSE (TO_NUMBER(SUBSTR(JUBUN,1,2))+1900)END"뻐킹"
FROM TBL_SAWON;





SELECT *
FROM TBL_SAWON;

-- TBL_SAWON 테이블에 존재하는 사원들의
-- 입사일(HIREDATE) 컬럼에서 월, 일만 조회하기



SELECT SANAME, HIREDATE,TO_CHAR(HIREDATE, 'MM')"월",TO_CHAR(HIREDATE,'DD')"일"
FROM TBL_SAWON;
/*
정승민	    2017-11-05	11	05
정영훈	    2005-08-16	08	16
문제정	    1999-08-16	08	16
이은솔	    1998-02-10	02	10
곽유진	    2002-07-15	07	15
이상이	    1999-08-16	08	16
이이경	    2009-06-05	06	05
아이유	    2012-07-13	07	13
미노이	    2007-12-10	12	10
선동열	    1990-10-10	10	10
선우용녀	1998-08-10	08	10
선우선	    2012-07-13	07	13
남희석	    2012-07-13	07	13
남궁선	    2015-08-14	08	14
남진	    1990-10-10	10	10
김정현	    2011-01-03	01	03
정우	    1999-10-10	10	10
*/

SELECT SANAME, HIREDATE,TO_CHAR(HIREDATE, 'MM')||'-'||TO_CHAR(HIREDATE,'DD')"월일"
FROM TBL_SAWON;
/*
정승민	    2017-11-05	11-05
정영훈	    2005-08-16	08-16
문제정	    1999-08-16	08-16
이은솔	    1998-02-10	02-10
곽유진	    2002-07-15	07-15
이상이	    1999-08-16	08-16
이이경	    2009-06-05	06-05
아이유	    2012-07-13	07-13
미노이	    2007-12-10	12-10
선동열	    1990-10-10	10-10
선우용녀	1998-08-10	08-10
선우선	    2012-07-13	07-13
남희석	    2012-07-13	07-13
남궁선	    2015-08-14	08-14
남진	    1990-10-10	10-10
김정현	    2011-01-03	01-03
정우	    1999-10-10	10-10
*/

SELECT SANAME, HIREDATE,TO_CHAR(HIREDATE, 'MM-DD')"월일"
FROM TBL_SAWON;
/*
정승민	    2017-11-05	11-05
정영훈	    2005-08-16	08-16
문제정	    1999-08-16	08-16
이은솔	    1998-02-10	02-10
곽유진	    2002-07-15	07-15
이상이	    1999-08-16	08-16
이이경	    2009-06-05	06-05
아이유	    2012-07-13	07-13
미노이	    2007-12-10	12-10
선동열	    1990-10-10	10-10
선우용녀	1998-08-10	08-10
선우선	    2012-07-13	07-13
남희석	    2012-07-13	07-13
남궁선	    2015-08-14	08-14
남진	    1990-10-10	10-10
김정현	    2011-01-03	01-03
정우	    1999-10-10	10-10
*/

--   사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일
--   , 정년퇴직일, 근무일수, 남은일수(정년퇴직일까지), 보너스


-- 사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일, 급여
SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            ,CASE WHEN THEN ELSE END"성별"
FROM TBL_SAWON;

SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            ,CASE WHEN 주민번호 7번짜리 1개가 '1' 또는 '3'THEN '남자'
                  WHEN 주민번호 7번짜리 1개가 '2' 또는 '4'THEN '여자'
            ELSE '성별확인불가' 
        END"성별"
FROM TBL_SAWON;


SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            ,CASE WHEN SUBSTR(JUBUN,7,1)가 '1' 또는 '3'THEN '남자'
                  WHEN SUBSTR(JUBUN,7,1)가 '2' 또는 '4'THEN '여자'
            ELSE '성별확인불가' 
        END"성별"
FROM TBL_SAWON;


SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            ,CASE WHEN SUBSTR(JUBUN,7,1) IN('1' ,'3')THEN '남자'
                  WHEN SUBSTR(JUBUN,7,1) IN('2', '4')THEN '여자'
            ELSE '성별확인불가' 
        END"성별"
FROM TBL_SAWON;


/*
1002	정승민	    0002114234567	여자
1003	정영훈	    9709061234567	남자
1004	문제정	    9608051234567	남자
1005	이은솔	    9104282234567	여자
1006	곽유진	    9901192234567	여자
1007	이상이	    8512161234567	남자
1008	이이경	    8904051234567	남자
1009	아이유	    9302022234567	여자
1010	미노이	    9704252234567	여자
1011	선동열	    7012181234567	남자
1012	선우용녀	7005132234567	여자
1013	선우선	    0203044234567	여자
1014	남희석	    0502033234567	남자
1015	남궁선	    0512124234567	여자
1016	남진	    7108051234567	남자
1001	김정현	    9804111234567	남자
1017	정우	    8502031234567	남자
*/



SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            ,CASE WHEN SUBSTR(JUBUN,7,1) IN('1' ,'3')THEN '남자'
                  WHEN SUBSTR(JUBUN,7,1) IN('2', '4')THEN '여자'
            ELSE '성별확인불가' 
        END"성별"
        -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
        , CASE WHEN THEN ELSE END "현재나이"
FROM TBL_SAWON;


SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            ,CASE WHEN SUBSTR(JUBUN,7,1) IN('1' ,'3')THEN '남자'
                  WHEN SUBSTR(JUBUN,7,1) IN('2', '4')THEN '여자'
            ELSE '성별확인불가' 
        END"성별"
        -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
        , CASE WHEN 1900년대 생이라면...
               THEN 현재년도 -(주민번호 앞 두자리 + 1899)
               WHEN 2000년대 생이라면...
               THEN 현재년도 -(주민번호 앞 두자리 + 1999)
               ELSE '나이확인불가'
            END "현재나이"
FROM TBL_SAWON;


SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            ,CASE WHEN SUBSTR(JUBUN,7,1) IN('1' ,'3')THEN '남자'
                  WHEN SUBSTR(JUBUN,7,1) IN('2', '4')THEN '여자'
            ELSE '성별확인불가' 
        END"성별"
        -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
        , CASE WHEN SUBSTR(JUBUN,7,1) IN ('1','2')
               THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1899)
               WHEN SUBSTR(JUBUN,7,1) IN ('3','4')
               THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1999)
               ELSE -1
            END "현재나이"
FROM TBL_SAWON;

/*
1002	정승민	    0002114234567	여자	25
1003	정영훈	    9709061234567	남자	28
1004	문제정	    9608051234567	남자	29
1005	이은솔	    9104282234567	여자	34
1006	곽유진	    9901192234567	여자	26
1007	이상이	    8512161234567	남자	40
1008	이이경	    8904051234567	남자	36
1009	아이유	    9302022234567	여자	32
1010	미노이	    9704252234567	여자	28
1011	선동열	    7012181234567	남자	55
1012	선우용녀	7005132234567	여자	55
1013	선우선	    0203044234567	여자	23
1014	남희석	    0502033234567	남자	20
1015	남궁선	    0512124234567	여자	20
1016	남진	    7108051234567	남자	54
1001	김정현	    9804111234567	남자	27
1017	정우	    8502031234567	남자	40
*/



SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
        -- 성별
            ,CASE WHEN SUBSTR(JUBUN,7,1) IN('1' ,'3')THEN '남자'
                  WHEN SUBSTR(JUBUN,7,1) IN('2', '4')THEN '여자'
            ELSE '성별확인불가' 
        END"성별"
        -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
        , CASE WHEN SUBSTR(JUBUN,7,1) IN ('1','2')
               THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1899)
               WHEN SUBSTR(JUBUN,7,1) IN ('3','4')
               THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1999)
               ELSE -1
            END "현재나이"
        -- 입사일
        ,HIREDATE"입사일"
        -- 급여
        ,SAL"급여"
FROM TBL_SAWON;



SELECT SANO"사원번호",SANAME"사원명",SAL"급여"
       , SAL*12 "연봉",연봉*2 "두배연봉", 연봉*3 "세배연봉"
FROM TBL_SAWON;


--인라인뷰 FROM절에 서브쿼리문 생성
SELECT T.사원번호, T.사원명, T.급여,T.연봉*2"두배연봉",T.연봉*3"세배연봉"
FROM
(
    SELECT SANO"사원번호",SANAME"사원명",SAL"급여",SAL*12"연봉"
    FROM TBL_SAWON
) T;
 

 SELECT 사원번호, 사원명, 연봉, 연봉*2"두배연봉"
FROM
(
    SELECT EMPNO"사원번호",ENAME"사원명",SAL*12+NVL(COMM,0)"연봉"
    FROM EMP
);





--   사원번호, 사원명, 주민번호, 성별, 현재나이, 입사일
--   , 정년퇴직일, 근무일수, 남은일수(정년퇴직일까지), 보너스

SELECT T.사원번호,T.사원명,T.주민번호,T.성별,T.현재나이,T.입사일
    -- 정년퇴직일
    -- 정년퇴직연도 → 해당 직원의 나이가 한국나이로 65세가 되는 해
    -- 현재나이가... 62세...3년 후      2024 → 2027 (남은년수 3년)
    -- 현재나이가... 35세...30년 후     2024 → 2054 (남은년수 30년)
    -- 현재일자 + 남은년수 → 정년퇴직연도
    -- ADD_MONTHS(SYSDATE, 남은년수*12)
    --                     --------
    --                   (65 - 현재나이)
    -- ADD_MONTHS(SYSDATE,(65-현재나이)*12)
    --,TO_CHAR(ADD_MONTHS(SYSDATE,(65-T.현재나이)*12),'YYYY') ---> 정년퇴직 연도만 추출
    --,TO_CHAR(T.입사월일,'MM-DD')                                   "입사월일"
    ,TO_CHAR(ADD_MONTHS(SYSDATE,(65-T.현재나이)*12),'YYYY') ||'-'|| TO_CHAR(T.입사일,'MM-DD')"정년퇴직일"
    --근무일수
    --근무일수 = 현재일 - 입사일
    ,TRUNC(SYSDATE - T.입사일)"근무일수"
    -- 남은일수
    -- 남은일수 = 정년퇴직일 - 현재일
    , TRUNC(TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,(65-T.현재나이)*12),'YYYY') ||'-'|| TO_CHAR(T.입사일,'MM-DD'),'YYYY-MM-DD') - SYSDATE )"남은일수"
    --급여
    ,T.급여"급여"
    --보너스
    -- 근무일수가 5000일 이상 6000일 미만 → 해당 사원의 급여 기준 30%
    -- 근무일수가 6000일 이상              → 해당 사원의 급여 기준 50%
    -- 나머지                             → 0
    --,CASE WHEN 근무일수가 6000일 이상 THEN 급여의 50%
    --      WHEN 근무일수가 5000일 이상 THEN 급여의 30%
    --      ELSE 0 
    --      END "보너스"
    ,CASE WHEN (SYSDATE-T.입사일)>=6000 THEN T.급여 * 0.5
          WHEN (SYSDATE-T.입사일)>=5000 THEN T.급여 * 0.3
          ELSE 0 
          END "보너스"
FROM
(
    SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
            -- 성별
                ,CASE WHEN SUBSTR(JUBUN,7,1) IN('1' ,'3')THEN '남자'
                      WHEN SUBSTR(JUBUN,7,1) IN('2', '4')THEN '여자'
                ELSE '성별확인불가' 
            END"성별"
            -- 현재나이 = 현재년도 - 태어난년도 + 1 (1900년대 생 / 2000년대 생)
            , CASE WHEN SUBSTR(JUBUN,7,1) IN ('1','2')
                   THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1899)
                   WHEN SUBSTR(JUBUN,7,1) IN ('3','4')
                   THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1999)
                   ELSE -1
                END "현재나이"
            -- 입사일
            ,HIREDATE"입사일"
            -- 급여
            ,SAL"급여"
    FROM TBL_SAWON
)T;


--==>>
/*
1002	정승민	    0002114234567	여자	25	2017-11-05	2064-11-05	2573	14593	2000	0
1003	정영훈	    9709061234567	남자	28	2005-08-16	2061-08-16	7037	13416	5000	2500
1004	문제정	    9608051234567	남자	29	1999-08-16	2060-08-16	9229	13051	4000	2000
1005	이은솔	    9104282234567	여자	34	1998-02-10	2055-02-10	9781	11037	6000	3000
1006	곽유진	    9901192234567	여자	26	2002-07-15	2063-07-15	8165	14114	2000	1000
1007	이상이	    8512161234567	남자	40	1999-08-16	2049-08-16	9229	9033	2000	1000
1008	이이경	    8904051234567	남자	36	2009-06-05	2053-06-05	5648	10422	1000	300
1009	아이유	    9302022234567	여자	32	2012-07-13	2057-07-13	4514	11921	3000	0
1010	미노이	    9704252234567	여자	28	2007-12-10	2061-12-10	6191	13532	2000	1000
1011	선동열	    7012181234567	남자	55	1990-10-10	2034-10-10	12461	3609	3000	1500
1012	선우용녀	7005132234567	여자	55	1998-08-10	2034-08-10	9600	3548	2000	1000
1013	선우선	    0203044234567	여자	23	2012-07-13	2066-07-13	4514	15208	1000	0
1014	남희석	    0502033234567	남자	20	2012-07-13	2069-07-13	4514	16304	1000	0
1015	남궁선	    0512124234567	여자	20	2015-08-14	2069-08-14	3387	16336	3000	0
1016	남진	    7108051234567	남자	54	1990-10-10	2035-10-10	12461	3974	2000	1000
1001	김정현	    9804111234567	남자	27	2011-01-03	2062-01-03	5071	13556	3000	900
1017	정우	    8502031234567	남자	40	1999-10-10	2049-10-10	9174	9088	2000	1000
*/



-- ※ 상기 내용에서...
--    특정 근무일수의 사원을 확인해야 한다거나...
--    특정 보너스 급액을 받는 사원을 확인해야 할 경우가 생겼다거나... 할수 있다.
--    이와 같은 경우...
--    해당 쿼리문을 다시 구성해야 하는 번거로움을 줄일 수 있도록
--    뷰(VIEW)를 만들어 저장해둘 수 있다.


SELECT *
FROM TBL_EMP;

CREATE VIEW VIEW_TEST
AS
SELECT EMPNO, ENAME, JOB, SAL*12+NVL(COMM,0)"YEARPAY"
FROM TBL_EMP;
--==>> 에러 발생
/*
오류 보고 -
ORA-01031: insufficient privileges (→ 권한 불충분)
01031. 00000 -  "insufficient privileges"
*Cause:    An attempt was made to perform a database operation without
           the necessary privileges.
*Action:   Ask your database administrator or designated security
           administrator to grant you the necessary privileges
*/
--> SCOTT 계정이 뷰를 생성할 수 있는 권한(CREATE VIEW)이 없기 떄문에 발생하는 에러



--※ 『20241121_02_sys.sql』에서
--   SYS 계정으로 해당 권한 부여 이후 다시 시도
CREATE VIEW VIEW_TEST
AS
SELECT EMPNO, ENAME, JOB, SAL*12+NVL(COMM,0)"YEARPAY"
FROM TBL_EMP;
--==>>View VIEW_TEST이(가) 생성되었습니다.


--○ 뷰(VIEW) 조회
SELECT *
FROM VIEW_TEST;
--==>>
/*
7369	SMITH	CLERK	    9600
7499	ALLEN	SALESMAN	19500
7521	WARD	SALESMAN	15500
7566	JONES	MANAGER	    35700
7654	MARTIN	SALESMAN	16400
7698	BLAKE	MANAGER	    34200
7782	CLARK	MANAGER	    29400
7788	SCOTT	ANALYST	    36000
7839	KING	PRESIDENT	60000
7844	TURNER	SALESMAN	18000
7876	ADAMS	CLERK	    13200
7900	JAMES	CLERK	    11400
7902	FORD	ANALYST	    36000
7934	MILLER	CLERK	    15600
*/


--○ 뷰 생성 이후 대상 테이블에 데이터 추가
INSERT INTO TBL_EMP(EMPNO,ENAME,JOB,HIREDATE,SAL,COMM,DEPTNO)
VALUES(9000, '김민승','SALESMAN',SYSDATE,5000,500,20);
--==>>1 행 이(가) 삽입되었습니다.

--○ 확인
SELECT *
FROM TBL_EMP;
/*
7369	SMITH	CLERK	    7902	1980-12-17	800		20
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300 	30
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20
7839	KING	PRESIDENT		    1981-11-17	5000		    10
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20
7900	JAMES	CLERK	    7698	1981-12-03	950		30
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10
9000	김민승	SALESMAN		    2024-11-21	5000	500	    20
*/

--○ 커밋
COMMIT;
--==>>커밋 완료.


--○ 해당 뷰 다시 조회
SELECT *
FROM VIEW_TEST;
/*
7369	SMITH	CLERK	    9600
7499	ALLEN	SALESMAN	19500
7521	WARD	SALESMAN	15500
7566	JONES	MANAGER	    35700
7654	MARTIN	SALESMAN	16400
7698	BLAKE	MANAGER	    34200
7782	CLARK	MANAGER	    29400
7788	SCOTT	ANALYST	    36000
7839	KING	PRESIDENT	60000
7844	TURNER	SALESMAN	18000
7876	ADAMS	CLERK	    13200
7900	JAMES	CLERK	    11400
7902	FORD	ANALYST	    36000
7934	MILLER	CLERK	    15600
9000	김민승	SALESMAN	60500
*/


CREATE VIEW VIEW_TEST
AS
SELECT EMPNO, ENAME, JOB, SAL*12+NVL(COMM,0)"YEARPAY",DEPTNO
FROM TBL_EMP;
--==>>
/*
오류 보고 -
ORA-00955: name is already used by an existing object
00955. 00000 -  "name is already used by an existing object"
*Cause:    
*Action:
*/

CREATE OR REPLACE VIEW VIEW_TEST
AS
SELECT EMPNO, ENAME, JOB, SAL*12+NVL(COMM,0)"YEARPAY",DEPTNO
FROM TBL_EMP;
--==>> View VIEW_TEST이(가) 생성되었습니다.





CREATE OR REPLACE VIEW VIEW_SAWON
AS
SELECT T.사원번호,T.사원명,T.주민번호,T.성별,T.현재나이,T.입사일
    ,TO_CHAR(ADD_MONTHS(SYSDATE,(65-T.현재나이)*12),'YYYY') ||'-'|| TO_CHAR(T.입사일,'MM-DD')"정년퇴직일"
    ,TRUNC(SYSDATE - T.입사일)"근무일수"
    , TRUNC(TO_DATE(TO_CHAR(ADD_MONTHS(SYSDATE,(65-T.현재나이)*12),'YYYY') ||'-'|| TO_CHAR(T.입사일,'MM-DD'),'YYYY-MM-DD') - SYSDATE )"남은일수"
    ,T.급여"급여"
    ,CASE WHEN (SYSDATE-T.입사일)>=6000 THEN T.급여 * 0.5
          WHEN (SYSDATE-T.입사일)>=5000 THEN T.급여 * 0.3
          ELSE 0 
          END "보너스"
FROM
(
    SELECT SANO "사원번호",SANAME"사원명",JUBUN"주민번호"
         
                ,CASE WHEN SUBSTR(JUBUN,7,1) IN('1' ,'3')THEN '남자'
                      WHEN SUBSTR(JUBUN,7,1) IN('2', '4')THEN '여자'
                ELSE '성별확인불가' 
            END"성별"
            , CASE WHEN SUBSTR(JUBUN,7,1) IN ('1','2')
                   THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1899)
                   WHEN SUBSTR(JUBUN,7,1) IN ('3','4')
                   THEN EXTRACT(YEAR FROM SYSDATE) -(TO_NUMBER(SUBSTR(JUBUN,1,2)) + 1999)
                   ELSE -1
                END "현재나이"
            ,HIREDATE"입사일"
            ,SAL"급여"
    FROM TBL_SAWON
)T;



SELECT *
FROM VIEW_SAWON;
/*
1002	정승민	    0002114234567	여자	25	2017-11-05	2064-11-05	2573	14593	2000	0
1003	정영훈	    9709061234567	남자	28	2005-08-16	2061-08-16	7037	13416	5000	2500
1004	문제정	    9608051234567	남자	29	1999-08-16	2060-08-16	9229	13051	4000	2000
1005	이은솔	    9104282234567	여자	34	1998-02-10	2055-02-10	9781	11037	6000	3000
1006	곽유진	    9901192234567	여자	26	2002-07-15	2063-07-15	8165	14114	2000	1000
1007	이상이	    8512161234567	남자	40	1999-08-16	2049-08-16	9229	9033	2000	1000
1008	이이경	    8904051234567	남자	36	2009-06-05	2053-06-05	5648	10422	1000	300
1009	아이유	    9302022234567	여자	32	2012-07-13	2057-07-13	4514	11921	3000	0
1010	미노이	    9704252234567	여자	28	2007-12-10	2061-12-10	6191	13532	2000	1000
1011	선동열	    7012181234567	남자	55	1990-10-10	2034-10-10	12461	3609	3000	1500
1012	선우용녀	7005132234567	여자	55	1998-08-10	2034-08-10	9600	3548	2000	1000
1013	선우선	    0203044234567	여자	23	2012-07-13	2066-07-13	4514	15208	1000	0
1014	남희석	    0502033234567	남자	20	2012-07-13	2069-07-13	4514	16304	1000	0
1015	남궁선	    0512124234567	여자	20	2015-08-14	2069-08-14	3387	16336	3000	0
1016	남진	    7108051234567	남자	54	1990-10-10	2035-10-10	12461	3974	2000	1000
1001	김정현	    9804111234567	남자	27	2011-01-03	2062-01-03	5071	13556	3000	900
1017	정우	    8502031234567	남자	40	1999-10-10	2049-10-10	9174	9088	2000	1000
*/


--○ VIEW 생성 이후 데이터 변경

UPDATE TBL_SAWON
SET HIREDATE=SYSDATE, SAL=100
WHERE SANO=1001;
--==>> 1 행 이(가) 업데이트되었습니다.

--○ 확인
SELECT *
FROM TBL_SAWON;
--==>> 변경 내용 확인

--○ 커밋
COMMIT;
--==>> 커밋 완료.


SELECT *
FROM TBL_SAWON;
-- 변경전 T → 1001 김정현  9804111234567   2011-01-03  3000
-- 변경후 T → 1001	김정현	9804111234567	2024-11-21	 100

SELECT *
FROM VIEW_SAWON;
-- 변경전 V → 1001	김정현	    9804111234567	남자	27	2011-01-03	2062-01-03	5071	13556	3000	900
-- 변경후 V → 1001	김정현	    9804111234567	남자	27	2024-11-21	2062-11-21	   0	13878	 100      0



--○ 서브쿼리를 활용하여 TBL_SAWON 테이블을 다음과 같이 조회할수 있도록 쿼리문을 구성한다.
/*
---------------------------------------------------------------
    사원명 |   성별  |   현재나이    |   급여  |   나이보너스
*/


-- 단, 나이보너스는 현재 나이가 40세 이상이면 급여의 70%
-- 30세 이상 40세 미만이면 급여의 50%
-- 20세 이상 30세 미만이면 급여의 30%로 한다.


-- 또한, 완성된 조회 구문을 기반으로
-- VIEW_SAWON2 라는 이름의 뷰(VIEW)를 생성한다.



CREATE VIEW VIEW_SAWON2
AS
SELECT  T.사원명, T.성별, T.현재나이,T.급여            --T.* 도 가능
        ,CASE WHEN T.현재나이>=40 THEN T.급여*0.7 
            WHEN T.현재나이>=30 THEN T.급여*0.5
            WHEN T.현재나이>=20 THEN T.급여*0.3
            ELSE 0
            END"나이보너스"
FROM
(
SELECT SANAME"사원명" ,SAL"급여"
      ,CASE WHEN SUBSTR(JUBUN,7,1) IN (1,3) THEN '남자' ELSE '여자'END"성별"
      ,CASE WHEN SUBSTR(JUBUN,7,1) IN ('1','2') 
            THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN,1,2))+1899)
            WHEN SUBSTR(JUBUN,7,1) IN ('3','4') 
            THEN EXTRACT(YEAR FROM SYSDATE) - (TO_NUMBER(SUBSTR(JUBUN,1,2))+1999)
      END"현재나이"
FROM TBL_SAWON
)T;


--==>> 생성된 뷰(VIEW) 확인 → VIEW_SAWON2
SELECT *
FROM VIEW_SAWON2;

--==>>
/*
정승민	    여자	25	2000	 600
정영훈	    남자	28	5000	1500
문제정	    남자	29	4000	1200
이은솔	    여자	34	6000	3000
곽유진	    여자	26	2000	 600
이상이	    남자	40	2000	1400
이이경	    남자	36	1000	 500
아이유	    여자	32	3000	1500
미노이	    여자	28	2000	 600
선동열	    남자	55	3000	2100
선우용녀	여자	55	2000	1400
선우선	    여자	23	1000	 300
남희석	    남자	20	1000	 300
남궁선	    여자	20	3000	 900
남진	    남자	54	2000	1400
김정현	    남자	27	100	      30
정우	    남자	40	2000	1400
*/




--------------------------------------------------------------------------------


--○ RANK() → 등수(순위)를 반환하는 함수

SELECT EMPNO"사원번호",ENAME"사원명",DEPTNO"부서번호",SAL"급여"
       ,RANK() OVER(ORDER BY SAL DESC)"전체급여등수"
FROM EMP;


/*
7839	KING	10	5000	1
7902	FORD	20	3000	2
7788	SCOTT	20	3000	2
7566	JONES	20	2975	4
7698	BLAKE	30	2850	5
7782	CLARK	10	2450	6
7499	ALLEN	30	1600	7
7844	TURNER	30	1500	8
7934	MILLER	10	1300	9
7521	WARD	30	1250	10
7654	MARTIN	30	1250	10
7876	ADAMS	20	1100	12
7900	JAMES	30	950	    13
7369	SMITH	20	800	    14
*/


SELECT EMPNO"사원번호",ENAME"사원명",DEPTNO"부서번호",SAL"급여"
       ,RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC )"전체급여등수"
FROM EMP;

/*
7839	KING	10	5000	1
7782	CLARK	10	2450	2
7934	MILLER	10	1300	3
7788	SCOTT	20	3000	1
7902	FORD	20	3000	1
7566	JONES	20	2975	3
7876	ADAMS	20	1100	4
7369	SMITH	20	800	    5
7698	BLAKE	30	2850	1
7499	ALLEN	30	1600	2
7844	TURNER	30	1500	3
7654	MARTIN	30	1250	4
7521	WARD	30	1250	4
7900	JAMES	30	950	    6
*/

SELECT EMPNO"사원번호",ENAME"사원명",DEPTNO"부서번호",SAL"급여"
       ,RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC )"부서내급여등수"
       ,RANK() OVER(ORDER BY SAL DESC)"전체급여등수"
FROM EMP;
--==>>
/*
7839	KING	10	5000	1	1
7902	FORD	20	3000	1	2
7788	SCOTT	20	3000	1	2
7566	JONES	20	2975	3	4
7698	BLAKE	30	2850	1	5
7782	CLARK	10	2450	2	6
7499	ALLEN	30	1600	2	7
7844	TURNER	30	1500	3	8
7934	MILLER	10	1300	3	9
7521	WARD	30	1250	4	10
7654	MARTIN	30	1250	4	10
7876	ADAMS	20	1100	4	12
7900	JAMES	30	950	    6	13
7369	SMITH	20	800 	5	14
*/

SELECT EMPNO"사원번호",ENAME"사원명",DEPTNO"부서번호",SAL"급여"
       ,RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC )"부서내급여등수"
       ,RANK() OVER(ORDER BY SAL DESC)"전체급여등수"
FROM EMP
ORDER BY 3, 4 DESC;
/*
7839	KING	10	5000	1	1
7782	CLARK	10	2450	2	6
7934	MILLER	10	1300	3	9
7902	FORD	20	3000	1	2
7788	SCOTT	20	3000	1	2
7566	JONES	20	2975	3	4
7876	ADAMS	20	1100	4	12
7369	SMITH	20	800	    5	14
7698	BLAKE	30	2850	1	5
7499	ALLEN	30	1600	2	7
7844	TURNER	30	1500	3	8
7654	MARTIN	30	1250	4	10
7521	WARD	30	1250	4	10
7900	JAMES	30	950	    6	13
*/


--○ DENSE_RANK() → 서열을 반환한느 함수
SELECT EMPNO"사원번호",ENAME"사원명",DEPTNO"부서번호",SAL"급여"
       ,DENSE_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL DESC )"부서내급여서열"
       ,DENSE_RANK() OVER(ORDER BY SAL DESC)"전체급여서열"
FROM EMP
ORDER BY 3, 4 DESC;

/*
7839	KING	10	5000	1	1
7782	CLARK	10	2450	2	5
7934	MILLER	10	1300	3	8
7902	FORD	20	3000	1	2
7788	SCOTT	20	3000	1	2
7566	JONES	20	2975	2	3
7876	ADAMS	20	1100	3	10
7369	SMITH	20	800	    4	12
7698	BLAKE	30	2850	1	4
7499	ALLEN	30	1600	2	6
7844	TURNER	30	1500	3	7
7654	MARTIN	30	1250	4	9
7521	WARD	30	1250	4	9
7900	JAMES	30	950	    5	11
*/


--○ EMP 테이블의 사원 정보를 대상으로
--   사원명, 부서번호, 연봉, 부서내 연봉순위, 전체연봉순위 항목으로 조회하는 쿼리문을 구성한다.


SELECT ENAME "사원명",DEPTNO"부서번호",SAL*12+NVL(COMM,0)"연봉"
       , RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC) "전체연봉순위"
       , RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL*12+NVL(COMM,0) DESC)"부서내 연봉순위"
FROM EMP;



SELECT T.사원명,T.부서번호,T.연봉
        ,RANK() OVER(ORDER BY T.연봉 DESC)"연봉순위"
        ,RANK() OVER(PARTITION BY T.부서번호 ORDER BY T.연봉 DESC)"전체연봉순위"
FROM
(
SELECT ENAME"사원명",DEPTNO"부서번호"
       ,SAL * 12 + NVL(COMM,0)"연봉"
FROM EMP
)T;

/*
KING	10	60000	1	1
FORD	20	36000	2	1
SCOTT	20	36000	2	1
JONES	20	35700	4	3
BLAKE	30	34200	5	1
CLARK	10	29400	6	2
ALLEN	30	19500	7	2
TURNER	30	18000	8	3
MARTIN	30	16400	9	4
MILLER	10	15600	10	3
WARD	30	15500	11	5
ADAMS	20	13200	12	4
JAMES	30	11400	13	6
SMITH	20	9600	14	5
*/


--○ EMP 테이블에서 전체연봉순위가 1등 부터 5등 까지만..
--   사원명, 부서번호, 연봉, 전체연봉순위 항목으로 조회한다.


SELECT T.*
FROM
(
SELECT ENAME"사원명",DEPTNO"부서번호",SAL*12+NVL(COMM,0)"연봉"
      ,RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC)"전체연봉"
FROM EMP
)T
WHERE T.전체연봉 <=5;

/*
KING	10	60000	1
SCOTT	20	36000	2
FORD	20	36000	2
JONES	20	35700	4
BLAKE	30	34200	5
*/


--※ 위의 내용은 RANK() OVER() 함수를 WHERE 조건절에서 사용한 경우이며
--   이 함수는 WHERE 조건절에서 사용할 수 없기 때문에 발생하는 에러이다.
--   이 경우, 우리는 INLINE VIEW 를 활용하여 문제를 해결해야 한다.



--○ EMP 테이블에서 각 부서별로 연봉 서열이 1등부터 2등까지만 조회한다.
--   사원번호, 사원명, 부서번호, 연봉, 부서내연봉서열, 전체연봉서열

SELECT F.*
FROM
(
SELECT T.*
FROM
(
SELECT EMPNO"사원번호",ENAME"사원명",DEPTNO"부서번호"
        ,SAL*12+NVL(COMM,0)"연봉"
        ,DENSE_RANK() OVER(PARTITION BY DEPTNO ORDER BY SAL*12+NVL(COMM,0) DESC)"부서내연봉서열"
        ,DENSE_RANK() OVER(ORDER BY SAL*12+NVL(COMM,0) DESC)"전체연봉서열"
FROM EMP
)T
)F
WHERE F.부서내연봉서열<=2;
/*
7839	KING	10	60000	1	1
7782	CLARK	10	29400	2	5
7902	FORD	20	36000	1	2
7788	SCOTT	20	36000	1	2
7566	JONES	20	35700	2	3
7698	BLAKE	30	34200	1	4
7499	ALLEN	30	19500	2	6
*/



-- 분석 함수
-- - 집계 함수
-- - 그룹 함수
-- - 윈도우 함수


-- 집계함수
-- SUM() 합, AVG() 평균, COUNT() 카운트, MAX() 최대값, MIN() 최소값
-- , VARIANCE() 분산, STDDEV() 표준편차
-- → 다중 행을 대상으로 처리한 단일 결과 반환
-- → 처리해야 할 데이터들 중 NULL 이 존재하면 이 NULL 은 제외하고 연산을 수행

-- SUM()
-- EMP 테이블을 대상으로 전체 사원들의 급여 총 합을 조회한다.

SELECT SUM(SAL) "결과확인"
FROM EMP;
--==>>29025
--> 800 + 1600 + 1250 +  2975 +  1250 +  2850 +  2450 +  3000 +  5000 +  1500 +  1100 +  950

SELECT SUM(COMM)"결과확인"
FROM EMP;
--==>>2200

SELECT COMM
FROM EMP;
-->(null) + 300 +  500 +  (null) +  1400 +  (null) +  (null) +  (null) +  (null) +  0  + (null)  + (null)  + (null) +  (null)
-->300 + 500 + 1400 + 0



-- COUNT()
-- 행의 갯수를 조회하여 결과값 반환
SELECT COUNT(ENAME)"결과확인"
FROM EMP;
--==>> 14

SELECT COUNT(COMM)"결과확인"
FROM EMP;
--==>> 4

SELECT COUNT(*)"결과확인"
FROM EMP;
--==>> 14



-- AVG()
-- 평균 반환
SELECT AVG(SAL)"결과확인"
FROM EMP;
--==>> 2073.214285714285714285714285714285714286

SELECT SUM(SAL) / COUNT(SAL) "결과확인"
FROM EMP;
--==>> 2073.214285714285714285714285714285714286


SELECT AVG(COMM)"결과확인"
FROM EMP;
--==>> 550

SELECT SUM(COMM) / COUNT(COMM) "결과확인"
FROM EMP;
--==>> 550


SELECT SUM(COMM) / COUNT(*) "결과확인"
FROM EMP;
--==>>157.142857142857142857142857142857142857


--※ 표준편의 제곱이 분산
--   분산의 제곱근이 표준편차
SELECT AVG(SAL), VARIANCE(SAL), STDDEV(SAL)
FROM EMP;
/*
2073.214285714285714285714285714285714286	→ 급여평균
1398313.87362637362637362637362637362637	→ 급여 분산
1182.503223516271699458653359613061928508*  → 급여 표준편차
*/
SELECT POWER(STDDEV(SAL),2)"급여표준편차제곱"
        ,VARIANCE(SAL)"급여분산"
FROM EMP;
--==>>
/*
1398313.87362637362637362637362637362637	
1398313.87362637362637362637362637362637
*/

SELECT SQRT(VARIANCE(SAL))"급여분산제곱근"
        ,STDDEV(SAL) "급여표준편차"
FROM EMP;
/*
1182.503223516271699458653359613061928508	
1182.503223516271699458653359613061928508
*/



--MAX() / MIN()
--최대값 / 최소값 반환
SELECT MAX(SAL)"COL1"
      ,MIN(SAL)"COL1"
FROM EMP;
--==>> 5000	800


--※ 주의
SELECT ENAME, SAL
FROM EMP;
--==>>
/*
SMITH	800
ALLEN	1600
WARD	1250
JONES	2975
MARTIN	1250
BLAKE	2850
CLARK	2450
SCOTT	3000
KING	5000
TURNER	1500
ADAMS	1100
JAMES	950
FORD	3000
MILLER	1300
*/

SELECT ENAME,SUM(SAL)"결과확인"
FROM EMP;
--==>> 에러 발생
/*
ORA-00937: not a single-group group function
00937. 00000 -  "not a single-group group function"
*Cause:    
*Action:
1,120행, 8열에서 오류 발생
*/

SELECT DEPTNO, SUM(SAL) "결과확인"
FROM EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
-- 구조상 GROUP BY가 먼저 실행되는데 부서별로 묶여있는 그룹을 SELECT 하는 부분이라 에러가 나지 않음.
/*
10	8750
20	10875
30	9400
*/
SELECT USER
FROM DUAL;
--==>>SYS

--○ SCOTT 계정에 VIEW 를 생성할 수 있는 권한 부여
GRANT CREATE VIEW TO SCOTT;
--==>>Grant을(를) 성공했습니다.
SELECT USER
FROM DUAL;
--==>>SCOTT


SELECT DEPTNO"부서번호", SUM(SAL) "급여합"
FROM EMP
GROUP BY DEPTNO;


SELECT DEPTNO"부서번호", SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
--==>>
/*
    10	    8750
    20	    10875
    30	    9400
(null)	    29025
*/


DELETE
FROM TBL_EMP
WHERE EMPNO = 9000;

--==>> 1 행 이(가) 삭제되었습니다.

SELECT *
FROM TBL_EMP;

COMMIT;
--==>>커밋 완료.




--○  실습 환경 구성을 위한 추가 데이터 입력
INSERT INTO TBL_EMP VALUES
(9001, '아이유','CLERK',7566,SYSDATE,1500,10,NULL);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_EMP VALUES
(8002, '수지','CLERK',7566,SYSDATE,1000,0,NULL);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_EMP VALUES
(8003, '이준혁','SALESMAN',7698,SYSDATE,2000,NULL,NULL);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_EMP VALUES
(8004, '손흥민','SALESMAN',7698,SYSDATE,2500,NULL,NULL);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_EMP VALUES
(8005, '카리나','SALESMAN',7698,SYSDATE,1000,NULL,NULL);


--○ 확인
SELECT *
FROM TBL_EMP;
/*
7369	SMITH	CLERK	    7902	80/12/17	800		20
7499	ALLEN	SALESMAN	7698	81/02/20	1600	300	    30
7521	WARD	SALESMAN	7698	81/02/22	1250	500	    30
7566	JONES	MANAGER	    7839	81/04/02	2975		    20
7654	MARTIN	SALESMAN	7698	81/09/28	1250	1400	30
7698	BLAKE	MANAGER	    7839	81/05/01	2850		    30
7782	CLARK	MANAGER	    7839	81/06/09	2450		    10
7788	SCOTT	ANALYST	    7566	87/07/13	3000		    20
7839	KING	PRESIDENT		    81/11/17	5000		    10
7844	TURNER	SALESMAN	7698	81/09/08	1500	0	    30
7876	ADAMS	CLERK	    7788	87/07/13	1100		    20
7900	JAMES	CLERK	    7698	81/12/03	 950		    30
7902	FORD	ANALYST	    7566	81/12/03	3000		    20
7934	MILLER	CLERK	    7782	82/01/23	1300		    10
8001	아이유	CLERK	    7566	24/11/22	1500	10	
8002	수지	CLERK	    7566	24/11/22	1000	0	
8003	이준혁	SALESMAN	7698	24/11/22	2000		
8004	손흥민	SALESMAN	7698	24/11/22	2500		
8005	카리나	SALESMAN	7698	24/11/22	1000		
*/


--○ 커밋
COMMIT;
--==>>커밋 완료.


SELECT DEPTNO"부서번호", SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
--==>> 
/*
    10	8750
    20	10875
    30	9400
(NULL)	8000            -- 부서번호가 NULL 인 데이터들끼리의 급여 합
(NULL)	37025           -- 모든 부서의 급여 합
*/



-- 위에서 조회한 내용을 아래와 같이 조회될 수 있도록 쿼리문을 구성한다.
/*
--==>>
*/
/*
-------------------------
부서번호 | 급여합
-------------------------
10	     |   8750
20	     |   10875
30	     |   9400
인턴	 |   8000            
모든부서 |   37025           
*/

SELECT CASE DEPTNO WHEN NULL THEN '인턴'
                   ELSE DEPTNO 
            END"부서번호"
FROM TBL_EMP;
/*
ORA-00932: inconsistent datatypes: expected CHAR got NUMBER
00932. 00000 -  "inconsistent datatypes: expected %s got %s"
*Cause:    
*Action:
120행, 29열에서 오류 발생
*/

SELECT CASE DEPTNO WHEN NULL THEN '인턴'
                   ELSE TO_CHAR(DEPTNO )
            END"부서번호"
FROM TBL_EMP;
/*
20
30
30
20
30
30
10
20
10
30
20
30
20
10
(NULL)
(NULL)
(NULL)
(NULL)
(NULL)
*/


SELECT CASE WHEN DEPTNO IS  NULL THEN '인턴'
            ELSE TO_CHAR(DEPTNO )
            END"부서번호"
FROM TBL_EMP;
/*
20
30
30
20
30
30
10
20
10
30
20
30
20
10
인턴
인턴
인턴
인턴
인턴
*/

SELECT CASE WHEN DEPTNO IS  NULL THEN '인턴'
            ELSE TO_CHAR(DEPTNO )
            END"부서번호"
           ,SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY DEPTNO;
/*
  30	    9400
인턴	    8000
  20	    10875
  10	    8750
*/

SELECT CASE WHEN DEPTNO IS  NULL THEN '인턴'
            ELSE TO_CHAR(DEPTNO )
            END"부서번호"
           ,SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY DEPTNO
ORDER BY DEPTNO;
/*
10	    8750
20	    10875
30	    9400
인턴	8000
*/

SELECT CASE WHEN DEPTNO IS  NULL THEN '인턴'
            ELSE TO_CHAR(DEPTNO )
            END"부서번호"
           ,SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
/*
10	    8750
20	    10875
30	    9400
인턴	8000
인턴	37025
*/

SELECT CASE WHEN DEPTNO IS  NULL THEN '인턴'
            ELSE TO_CHAR(DEPTNO )
            END"부서번호"
           ,SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);




SELECT NVL(DEPTNO,'인턴')"부서번호"
      ,SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
--==>> 에러 발생
/*
ORA-01722: invalid number
01722. 00000 -  "invalid number"
*Cause:    The specified number was invalid.
*Action:   Specify a valid number.
*/

SELECT NVL2(DEPTNO,TO_CHAR(DEPTNO),'인턴')"부서번호"
      ,SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
/*
10	    8750
20	    10875
30	    9400
인턴	8000
인턴	37025
*/



--※ GROUPING()
SELECT DEPTNO "부서번호", SUM(SAL)"급여합",GROUPING(DEPTNO)"그루핑결과"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
/*
    10	8750	0
    20	10875	0
    30	9400	0
(null)	8000	0   --- 데이터 자체가 NULL
(null)	37025	1   --- 묶음 처리 → ROLLUP
*/




-- 위에서 조회한 내용을 아래와 같이 조회될 수 있도록 쿼리문을 구성한다.
/*
--==>>
*/
/*
-------------------------
부서번호 | 급여합
-------------------------
10	     |   8750
20	     |   10875
30	     |   9400
인턴	 |   8000            
모든부서 |   37025           
*/


SELECT CASE WHEN GROUPING(DEPTNO) = 1 THEN '모든부서'
            WHEN DEPTNO IS NULL THEN '인턴'       -- NULL 일때 인턴
            ELSE TO_CHAR(DEPTNO)
            END"부서번호"
            ,SUM(SAL)"급여합"

FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);



SELECT NVL2(DEPTNO,TO_CHAR(DEPTNO),'인턴')
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN DEPTNO
            ELSE '모든부서'
            END"부서번호"
            ,SUM(SAL)"급여합"

FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);

/*
ORA-00932: inconsistent datatypes: expected NUMBER got CHAR
00932. 00000 -  "inconsistent datatypes: expected %s got %s"
*Cause:    
*Action:
309행, 18열에서 오류 발생
*/

SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN TO_CHAR(DEPTNO)
            ELSE '모든부서'
            END"부서번호"
            ,SUM(SAL)"급여합"

FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
/*
10	        8750
20	        10875
30	        9400
(NULL)      8000
모든부서	37025
*/

SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO),'인턴')
            ELSE '모든부서'
            END"부서번호"
            ,SUM(SAL)"급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO);
/*
10	        8750
20	        10875
30	        9400
인턴	    8000
모든부서	37025
*/


-- TBL_SAWON 테이블을 다음과 같이 조회될 수 있도록 쿼리문을 구성한다.

/*
----------------------------
    성별           급여합
----------------------------
     남             XXXX
     여            XXXXX
     모든사원     XXXXXX
*/


SELECT CASE 
            WHEN T.성별 IS NULL THEN '모든사원' 
            ELSE T.성별
            END"성별"
            ,SUM(T.급여)
FROM 
(
SELECT CASE WHEN SUBSTR(JUBUN,7,1) IN (1,3) THEN '남성' 
            ELSE '여성'
            END"성별"
            ,SAL"급여"
FROM TBL_SAWON
)T
GROUP BY ROLLUP(T.성별);
--==>>
/*
남성	    20100
여성	    21000
모든사원	41100
*/


--○  TBL_SAWON 테이블을 다음과 같이 연령대별 인원수 형태로
--   조회할 수 있도록 쿼리문을 구성한다.



/*
----------------------------
    연령대         인원수
----------------------------
     20             9
     30             3
     40             2 
     50             3
    전체           17
*/

------------------------------------------------------------------------------
-->> 서브쿼리 2중 사용
SELECT CASE WHEN F.모음 IS NULL THEN '전체' 
            ELSE F.모음
            END"연령대"
            ,COUNT(*)
FROM
(
SELECT CASE WHEN SUBSTR(T.연령대,1,1) = 2 THEN '20'
            WHEN SUBSTR(T.연령대,1,1) = 3 THEN '30' 
            WHEN SUBSTR(T.연령대,1,1) = 4 THEN '40' 
            WHEN SUBSTR(T.연령대,1,1) = 5 THEN '50'
            ELSE '전체'
            END"모음" 
FROM
(
SELECT CASE WHEN SUBSTR(JUBUN,7,1) IN (1,2) THEN 2024-((SUBSTR(JUBUN,1,2))+1899)
            WHEN SUBSTR(JUBUN,7,1) IN (3,4) THEN 2024-((SUBSTR(JUBUN,1,2))+1999)
            END "연령대"
FROM TBL_SAWON
)T

)F
GROUP BY ROLLUP(F.모음);


------------------------------------------------------------------------------
-->> 서브쿼리 한번 사용

SELECT CASE GROUPING(T.연령대) WHEN 0 THEN TO_CHAR(T.연령대) 
            ELSE '전체' 
        END "연령대"
      , COUNT(T.연령대) "인원수"
FROM
(
    SELECT TRUNC(CASE WHEN SUBSTR(JUBUN,7,1) IN('1','2') 
                         THEN EXTRACT (YEAR FROM SYSDATE) - (1899 + TO_NUMBER(SUBSTR(JUBUN, 1, 2)))
                         WHEN SUBSTR(JUBUN,7,1) IN('3','4') 
                         THEN EXTRACT (YEAR FROM SYSDATE) - (1999 + TO_NUMBER(SUBSTR(JUBUN, 1, 2)))
                         ELSE 0
                     END, -1) "연령대"
            FROM TBL_SAWON
) T
GROUP BY ROLLUP(T.연령대);


-- ○ ROLLUP 활용 및 CUBE
SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY 1,2;
/*
10	CLERK	1300
10	MANAGER	2450
10	PRESIDENT	5000
20	ANALYST	6000
20	CLERK	1900
20	MANAGER	2975
30	CLERK	950
30	MANAGER	2850
30	SALESMAN	5600
*/


SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY ROLLUP(DEPTNO, JOB)
ORDER BY 1,2;
/*
10	    CLERK	    1300
10	    MANAGER	    2450
10	    PRESIDENT	5000
10	    (NULL)	    8750        --10번 부서 모든 직종의 급여합
20	    ANALYST	    6000
20	    CLERK	    1900
20	    MANAGER	    2975
20	    (NULL)	    10875       --20번 부서 모든 직종의 급여합
30	    CLERK	    950
30	    MANAGER	    2850
30	    SALESMAN	5600
30	    (NULL)	    9400        --30번 부서 모든 직종의 급여합
(NULL)	(NULL)	    29025       --모든 부서 모든 직종의 급여합
*/


--○ CUBE() → ROLLUP() 보다 더 자세한 결과를 반환받을 수 있다.

SELECT DEPTNO, JOB, SUM(SAL)
FROM EMP
GROUP BY CUBE(DEPTNO, JOB)
ORDER BY 1,2;
/*
10	    CLERK	    1300
10	    MANAGER	    2450
10	    PRESIDENT	5000
10		(NULL)      8750        --10번 부서 모든 직종의 급여합
20	    ANALYST	    6000
20	    CLERK	    1900
20	    MANAGER	    2975
20		(NULL)      10875       --20번 부서 모든 직종의 급여합
30	    CLERK	    950
30	    MANAGER	    2850
30	    SALESMAN	5600
30		(NULL)      9400        --30번 부서 모든 직종의 급여합
(NULL)	ANALYST	    6000        --모든 부서 ANALYST 직종의 급여합
(NULL)	CLERK	    4150        --모든 부서 CLERK 직종의 급여합
(NULL)	MANAGER	    8275        --모든 부서 MANAGER 직종의 급여합
(NULL)	PRESIDENT	5000        --모든 부서 PRESIDENT 직종의 급여합
(NULL)	SALESMAN	5600        --모든 부서 SALESMAN 직종의 급여합
(NULL)	(NULL)	    29025       --모든 부서 모든 직종의 급여합
*/

--※ ROLLUP() 과 CUBE() 는
--   그룹을 묶어주는 방식이 다르다.(차이)

-- ROLLUP(A, B, C)
-- →(A, B, C) / (A, B) / (A) / ()

-- CUBE(A, B, C)
-- →(A, B, C) / (A, B) / (A, C) / (B,C) / (A) / (B) / (C) /()


--> 이와 같은 상황으로 ...
--  원하는 결과를 얻지 못하거나(→ ROLLUP())
--  불필요한 너무 많은 결과물을 얻게 되기 때문에(→ CUBE())
--  조회하고자 하는 그룹만 『GROUPING SETS』를 이용하여 묶어주는 방식으로
--  처리할 수 있다.


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO),'인턴')
       ELSE '전체부서' 
       END"부서번호"
      ,CASE GROUPING(JOB) WHEN 0 THEN JOB 
       ELSE '전체직종'
       END"직종"
      ,SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY ROLLUP(DEPTNO, JOB)            --ROLLUP() 을 사용한 결과
ORDER BY 1,2;
/*
10	        CLERK	    1300
10	        MANAGER	    2450
10	        PRESIDENT	5000
10	        전체직종	8750
20	        ANALYST	    6000
20	        CLERK	    1900
20	        MANAGER	    2975
20	        전체직종	10875
30	        CLERK	    950
30	        MANAGER	    2850
30	        SALESMAN	5600
30	        전체직종	9400
인턴	    CLERK	    2500
인턴	    SALESMAN	5500
인턴	    전체직종	8000
전체부서	전체직종	37025
*/


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO),'인턴')
       ELSE '전체부서' 
       END"부서번호"
      ,CASE GROUPING(JOB) WHEN 0 THEN JOB 
       ELSE '전체직종'
       END"직종"
      ,SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY CUBE(DEPTNO, JOB)            --ROLLUP() 을 사용한 결과
ORDER BY 1,2;
/*
10	         CLERK	    1300
10	         MANAGER	2450
10	         PRESIDENT	5000
10	         전체직종	8750
20	         ANALYST	6000
20	         CLERK	    1900
20	         MANAGER	2975
20	         전체직종	10875
30	          CLERK	    950
30	        MANAGER	    2850
30	        SALESMAN	5600
30	         전체직종	9400
인턴	    CLERK	    2500
인턴	    SALESMAN	5500
인턴	    전체직종	8000
전체부서	ANALYST	    6000
전체부서	CLERK	    6650
전체부서	MANAGER	    8275
전체부서	PRESIDENT	5000
전체부서	SALESMAN	11100
전체부서	전체직종	37025
*/


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO),'인턴')
       ELSE '전체부서' 
       END"부서번호"
      ,CASE GROUPING(JOB) WHEN 0 THEN JOB 
       ELSE '전체직종'
       END"직종"
      ,SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY GROUPING SETS((DEPTNO,JOB),(DEPTNO),(1))                --GROUPING SETS()를 사용한 결과 → CUBE() 와 같은 결과
ORDER BY 1,2;

/*
10	CLERK	1300
10	MANAGER	2450
10	PRESIDENT	5000
10	전체직종	8750
20	ANALYST	6000
20	CLERK	1900
20	MANAGER	2975
20	전체직종	10875
30	CLERK	950
30	MANAGER	2850
30	SALESMAN	5600
30	전체직종	9400
인턴	CLERK	2500
인턴	SALESMAN	5500
인턴	전체직종	8000
전체부서	전체직종	37025
*/


SELECT CASE GROUPING(DEPTNO) WHEN 0 THEN NVL(TO_CHAR(DEPTNO),'인턴')
       ELSE '전체부서' 
       END"부서번호"
      ,CASE GROUPING(JOB) WHEN 0 THEN JOB 
       ELSE '전체직종'
       END"직종"
      ,SUM(SAL) "급여합"
FROM TBL_EMP
GROUP BY GROUPING SETS((DEPTNO,JOB),(DEPTNO),(JOB),())                --GROUPING ROLLUP()를 사용한 결과 → CUBE() 와 같은 결과
ORDER BY 1,2;
/*
10	CLERK	1300
10	MANAGER	2450
10	PRESIDENT	5000
10	전체직종	8750
20	ANALYST	6000
20	CLERK	1900
20	MANAGER	2975
20	전체직종	10875
30	CLERK	950
30	MANAGER	2850
30	SALESMAN	5600
30	전체직종	9400
인턴	CLERK	2500
인턴	SALESMAN	5500
인턴	전체직종	8000
전체부서	ANALYST	6000
전체부서	CLERK	6650
전체부서	MANAGER	8275
전체부서	PRESIDENT	5000
전체부서	SALESMAN	11100
전체부서	전체직종	37025
*/


SELECT *
FROM TBL_EMP
ORDER BY HIREDATE;

ALTER SESSION SET NLS_DATE_FORMAT ='YYYY-MM-DD';
--==>>Session이(가) 변경되었습니다.



--○ TBL_EMP 테이블에서 입사년도별 인원수를 조회한다.
/*
--------------------------
입사년도        인원수
--------------------------
 1980              1
 1981             10
 1982              1
 1987              2
 2024              5
 전체             19
 -------------------------
*/




SELECT CASE WHEN T.입사년도 IS NULL THEN'전체' 
            ELSE T.입사년도 
            END "입사년도"
            ,COUNT(*)"인원수"
FROM
(
SELECT SUBSTR(HIREDATE,1,4)"입사년도"
FROM TBL_EMP
)T
GROUP BY CUBE(T.입사년도)
ORDER BY 1;





SELECT CASE WHEN T.입사년도 IS NULL THEN'전체' 
            ELSE T.입사년도 
            END "입사년도"
            ,COUNT(*)"인원수"
FROM
(
SELECT SUBSTR(HIREDATE,1,4)"입사년도"
FROM TBL_EMP
)T
GROUP BY ROLLUP(T.입사년도);




SELECT CASE WHEN T.입사년도 IS NULL THEN'전체' 
            ELSE T.입사년도 
            END "입사년도"
            ,COUNT(*)"인원수"
FROM
(
SELECT SUBSTR(HIREDATE,1,4)"입사년도"
FROM TBL_EMP
)T
GROUP BY GROUPING SETS(T.입사년도,());

--------------------------------------------------------------------------------

--■■■ HAVING ■■■--

--○ EMP 테이블에서 부서번호가 20, 30인 부서를 대상으로
--   부서의 총 급여가 10000보다 적을 경우만 부서별 총 급여를 조회한다.
SELECT DEPTNO,SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20,30)
GROUP BY DEPTNO;
--==>>
/*
30	9400
20	10875
*/

SELECT DEPTNO,SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20,30)
  AND SUM(SAL)< 10000
GROUP BY DEPTNO;
--==>> 그룹에 대한 조건이 아니라 오류 발생
/*
ORA-00934: group function is not allowed here
00934. 00000 -  "group function is not allowed here"
*Cause:    
*Action:
750행, 7열에서 오류 발생
*/

SELECT DEPTNO,SUM(SAL)
FROM EMP
WHERE DEPTNO IN (20,30)
GROUP BY DEPTNO
HAVING SUM(SAL) < 10000;
--==>>
/*
30	9400
*/


SELECT DEPTNO,SUM(SAL)
FROM EMP
GROUP BY DEPTNO
HAVING SUM(SAL) < 10000
       AND DEPTNO IN (20,30);
--==>> WHERE 절에서 활용할 수 있는 조건문은 되도록이면 HAVING 절에서는 안쓰는게좋다.
/*
30	9400
*/


--※ 그룹 함수는 2 LEVEL 까지 중첩해서 사용할 수 있다.
--   이 마저도 MS-SQL은 불가능하다
SELECT MAX(SUM(SAL)) "결과확인"
FROM EMP
GROUP BY DEPTNO;
--==>>10875


--※ RANK()
--   DENSE_RANK()
--   → ORACLE 9i 부터 적용... MSSQL 2005 부터 적용.....



--※ 하위 버전에서 RANK() 나 DENSE_RANK() 를 사용할 수 없기 때문에
--  이를 대체하여 연산을 수행할 수 있는 방법을 강구해야 한다.

-- 예를 들어, 급여의 순위를 구하고자 한다면...
-- 해당 사원의 급여보다 더 큰 값이 몇 개인지 확인한 후
-- 그 확인한 숫자에 +1 을 추가 연산해주면 그것이 곧 등수가 된다.


SELECT ENAME, SAL, 1
FROM EMP;

--SMITH 의 급수 등여
SELECT COUNT(*) +1
FROM EMP
WHERE SAL > 800;        --SMITH 의 급여
--==>> 14



--ALLEN 의 급수 등여
SELECT COUNT(*) +1 "ALLEN급여등수"
FROM EMP
WHERE SAL > 1600;        --ALLEN 의 급여




--※ 상관 서브 쿼리(서브 상관 쿼리)
--   메인 쿼리에 있는 테이블의 컬럼이
--  서브 쿼리의 조건절(WHERE절, HAVING절)에 사용되는 경우
--  우리는 이 쿼리문을 상관 서브 쿼리(서브 상관 쿼리)라고 부른다.



SELECT ENAME "사원명",SAL"급여",1"급여등수"
FROM EMP;


SELECT ENAME "사원명",SAL"급여",(1)"급여등수"
FROM EMP;


SELECT ENAME "사원명",SAL"급여",(SELECT COUNT(*) + 1
                                 FROM EMP
                                 WHERE SAL > 800)"급여등수"
FROM EMP;


SELECT ENAME "사원명",SAL"급여",(SELECT COUNT(*) + 1
                                 FROM EMP E2
                                 WHERE SAL > 1600)"급여등수"
FROM EMP E1;



SELECT ENAME "사원명",SAL"급여",(SELECT COUNT(*) + 1
                                 FROM EMP E2
                                 WHERE E2.SAL > E1.SAL)"급여등수"
FROM EMP E1;
--==>>
/*
SMITH	800	    14
ALLEN	1600	7
WARD	1250	10
JONES	2975	4
MARTIN	1250	10
BLAKE	2850	5
CLARK	2450	6
SCOTT	3000	2
KING	5000	1
TURNER	1500	8
ADAMS	1100	12
JAMES	950	    13
FORD	3000	2
MILLER	1300	9
*/


SELECT ENAME "사원명",SAL"급여",(SELECT COUNT(*) + 1
                                 FROM EMP E2
                                 WHERE E2.SAL > E1.SAL)"급여등수"
FROM EMP E1
ORDER BY 3;
--==>>
/*
KING	5000	 1
FORD	3000	 2
SCOTT	3000	 2
JONES	2975	 4
BLAKE	2850	 5
CLARK	2450	 6
ALLEN	1600	 7
TURNER	1500	 8
MILLER	1300	 9
WARD	1250	10
MARTIN	1250	10
ADAMS	1100	12
JAMES	950	    13
SMITH	800	    14
*/


--○ EMP 테이블을 대상으로
--   사원명, 급여, 부서번호, 부서내급여등수, 전체급여등수 항목을 조회한다.
--   단,RANK() 함수를 사용하지 않고, 서브 상관 쿼리를 활용할 수 있도록 한다.


SELECT ENAME"사원명",DEPTNO,SAL"급여",
       (
        SELECT COUNT(*) +1
        FROM EMP E2
        WHERE E2.SAL > E1.SAL AND E1.DEPTNO = E2.DEPTNO
       )"부서번호"
    ,   (SELECT COUNT(*) +1
        FROM EMP E2
        WHERE E2.SAL > E1.SAL) "전체 급여등수"
FROM EMP E1
ORDER BY E1.DEPTNO, E1.SAL DESC;
--==>>
/*
KING	10	5000	1	1
CLARK	10	2450	2	6
MILLER	10	1300	3	9
SCOTT	20	3000	1	2
FORD	20	3000	1	2
JONES	20	2975	3	4
ADAMS	20	1100	4	12
SMITH	20	800 	5	14
BLAKE	30	2850	1	5
ALLEN	30	1600	2	7
TURNER	30	1500	3	8
MARTIN	30	1250	4	10
WARD	30	1250	4	10
JAMES	30	950	    6	13
*/

SELECT *
FROM EMP
ORDER BY DEPTNO, HIREDATE;



--○ EMP 테이블을 대상으로 다음과 같이 조회될 수 있도록 쿼리문을 구성한다.
/*
-------------------------------------------------------------------------
    사원명    부서번호     입사일           급여    부서내입사별급여누적
-------------------------------------------------------------------------
    CLARK        10       1981-06-09        2450            2450
    KING         10       1981-11-17        5000            7450
    MILLER       10       1982-01-23        1300            8750
    SMITH        20       1980-12-17         800             800
    JONES        20       1981-04-02        2975            3775
    FORD         20       1981-12-03        3000            6775
-------------------------------------------------------------------------
*/
-- 입사일이 빠른순으로 → 그룹별로 금액을 합산해야한다. 
-- 부서별 오름차순 적용되어있음.

SELECT ENAME"사원명",DEPTNO"부서번호",HIREDATE"입사일",SAL"급여"
       ,(
        SELECT SUM(SAL)
        FROM EMP E2
        WHERE E1.HIREDATE >= E2.HIREDATE AND E1.DEPTNO = E2.DEPTNO
        )"부서내입사별급여누적"
FROM EMP E1
ORDER BY 2;
/*
CLARK	10	1981-06-09	2450	2450
KING	10	1981-11-17	5000	7450
MILLER	10	1982-01-23	1300	8750
JONES	20	1981-04-02	2975	3775
FORD	20	1981-12-03	3000	6775
ADAMS	20	1987-07-13	1100	10875
SMITH	20	1980-12-17	800	800
SCOTT	20	1987-07-13	3000	10875
WARD	30	1981-02-22	1250	2850
TURNER	30	1981-09-08	1500	7200
ALLEN	30	1981-02-20	1600	1600
JAMES	30	1981-12-03	950	9400
BLAKE	30	1981-05-01	2850	5700
MARTIN	30	1981-09-28	1250	8450
*/






SELECT *
FROM TBL_EMP;

--○ TBL_EMP 테이블에서 입사한 사원의 수가 제일 많았을 때의
--   입사년월과 인원수를 조회할 수 있도록 쿼리문을 구성한다.
/*
-----------------------------------------
        입사년월        인원수
-----------------------------------------
       2024-11             5
-----------------------------------------
*/

SELECT TO_CHAR(HIREDATE, 'YYYY-MM')"입사년월"
        , COUNT(*)"인원수"
FROM TBL_EMP
GROUP BY TO_CHAR(HIREDATE,'YYYY-MM')
HAVING COUNT(*) = 5;
--==>> 2024-11	5




SELECT MAX(COUNT(*))
FROM TBL_EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM');




SELECT TO_CHAR(HIREDATE, 'YYYY-MM')"입사년월"
        , COUNT(*)"인원수"
FROM TBL_EMP
GROUP BY TO_CHAR(HIREDATE,'YYYY-MM')
HAVING COUNT(*) = (SELECT MAX(COUNT(*))
FROM TBL_EMP
GROUP BY TO_CHAR(HIREDATE, 'YYYY-MM'));
--==>> 2024-11 5

--------------------------------------------------------------------------------

--■■■ ROW_NUMBER() ■■■--

SELECT ROW_NUMBER() OVER(ORDER BY SAL DESC)"관찰"
        ,ENAME"사원명", SAL"급여",HIREDATE"입사일"
FROM EMP;
/*
1	KING	5000	1981-11-17
2	FORD	3000	1981-12-03
3	SCOTT	3000	1987-07-13
4	JONES	2975	1981-04-02
5	BLAKE	2850	1981-05-01
6	CLARK	2450	1981-06-09
7	ALLEN	1600	1981-02-20
8	TURNER	1500	1981-09-08
9	MILLER	1300	1982-01-23
10	WARD	1250	1981-02-22
11	MARTIN	1250	1981-09-28
12	ADAMS	1100	1987-07-13
13	JAMES	950	    1981-12-03
14	SMITH	800	    1980-12-17
*/














SELECT USER
FROM DUAL;
--==>>SCOTT


--------------------------------------------------------------------------------

--■■■ ROW_NUMBER() ■■■--

SELECT ROW_NUMBER() OVER(ORDER BY SAL DESC)"관찰"
        ,ENAME"사원명", SAL"급여",HIREDATE"입사일"
FROM EMP;
/*
1	KING	5000	1981-11-17
2	FORD	3000	1981-12-03
3	SCOTT	3000	1987-07-13
4	JONES	2975	1981-04-02
5	BLAKE	2850	1981-05-01
6	CLARK	2450	1981-06-09
7	ALLEN	1600	1981-02-20
8	TURNER	1500	1981-09-08
9	MILLER	1300	1982-01-23
10	WARD	1250	1981-02-22
11	MARTIN	1250	1981-09-28
12	ADAMS	1100	1987-07-13
13	JAMES	950	    1981-12-03
14	SMITH	800	    1980-12-17
*/


--※ 게시판의 게시물 번호를
--   SEQUNCE 나 IDENTITY 를 사용하게 되면
--   특정 게시물을 삭제했을 경우, 삭제한 게시물의 자리에
--   다음 번호를 가진 게시물이 등록되는 상황이 발생하게 된다.
--   이는, 보안 측면에서나... 미관상... 바람직하지 않은 상황일 수 있기 때문에
--   ROW_NUMBER() 의 사용을 고려해 볼 수 있다.
--   관리의 목적으로 사용할 때에는 SEQUENCE 나 IDENTITY 를 사용하지만
--   단순히 게시물을 목록화하여 사용자에게 리스트 형식으로  보여줄 때에는
--   사용하지 않는 것이 좋다. 


--※ 관찰
-- 테이블 생성
CREATE TABLE TBL_AAA
( NO    NUMBER
, NAME  VARCHAR2(40)
, GRADE CHAR
);

--==>> Table TBL_AAA이(가) 생성되었습니다.


-- 데이터 입력
INSERT INTO TBL_AAA(NO,NAME,GRADE) VALUES(1,'정영훈','A');
INSERT INTO TBL_AAA(NO,NAME,GRADE) VALUES(2,'박제훈','B');
INSERT INTO TBL_AAA(NO,NAME,GRADE) VALUES(3,'공찬민','A');
INSERT INTO TBL_AAA(NO,NAME,GRADE) VALUES(4,'정승민','C');
INSERT INTO TBL_AAA(NO,NAME,GRADE) VALUES(5,'박세진','B');
INSERT INTO TBL_AAA(NO,NAME,GRADE) VALUES(6,'정영훈','B');
INSERT INTO TBL_AAA(NO,NAME,GRADE) VALUES(7,'정영훈','B');
--==>> 1 행 이(가) 삽입되었습니다. * 7


-- 확인
SELECT *
FROM TBL_AAA;
--==>>
/*
1	정영훈	A
2	박제훈	B
3	공찬민	A
4	정승민	C
5	박세진	B
6	정영훈	B
7	정영훈	B
*/

-- 커밋
COMMIT;
--==>> 커밋완료




UPDATE TBL_AAA
SET GRADE='A'
WHERE NAME='정영훈' AND GRADE='B';
--==>> 2개 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_AAA;
/*
1	정영훈	A
2	박제훈	B
3	공찬민	A
4	정승민	C
5	박세진	B
6	정영훈	A
7	정영훈	A
*/



--○ SEQUENCE 생성(시퀀스, 주문번호)
-- → 사전적인 의미 : 1.(일련의) 연속적인 사건들 2.(사건,행동 등의) 순서




CREATE SEQUENCE SEQ_BOARD       -- 시퀀스 기존 생성 구문(MYSQL 의 IDENTITY 와 동일한 개념)
START WITH 1                    -- 시작값
INCREMENT BY 1                  -- 증가값
NOMAXVALUE                      -- 최대값 제한 없음
NOCACHE;                        -- 캐시 사용 안함(없음)
--==>> Sequence SEQ_BOARD이(가) 생성되었습니다.



-- ○ 테이블 생성
-- 테이블명 : TBL_BOARD                         -- TBL_BOARD 이름의 테이블 생성 → 게시판
CREATE TABLE TBL_BOARD
( NO        NUMBER                              -- 게시물 번호       사용자가 입력 Ⅹ
, TITLE     VARCHAR2(50)                        -- 게시물 제목       사용자가 입력 ○
, CONTENTS  VARCHAR2(2000)                      -- 게시물 내용       사용자가 입력 ○
, NAME      VARCHAR2(20)                        -- 게시물 작성자     사용자가 입력 하거나 안하거나 △
, PW        VARCHAR2(20)                        -- 게시물 패스워드   사용자가 입력 하거나 안하거나 △
, CREATED   DATE        DEFAULT SYSDATE         -- 게시물 작성일     사용자가 입력 Ⅹ
);
--==>> Table TBL_BOARD이(가) 생성되었습니다.


--○ 데이터 입력 → 게시판에 게시물 작성

INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'앗싸~1등','내가 1등이지롱','김믿음','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'건강관리','다들 건강 챙깁시다','박지우','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'오늘은','점심 뭐 먹지...','엄서연','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'날씨','오늘은 미세먼지 없나?','정영훈','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'아침에','혼자 와있으면 추워요','박제훈','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'질문있습니다','쉬었다 하면 안되나요','임성산','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'질문있습니다','앗 생각나면 다시 질문할께요','김민승','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

--○ 확인
SELECT *
FROM TBL_BOARD;
/*
1	앗싸~1등	    내가 1등이지롱	            김믿음	JAVA006$	2024-11-25
2	건강관리	    다들 건강 챙깁시다	        박지우	JAVA006$	2024-11-25
3	오늘은	        점심 뭐 먹지...	            엄서연	JAVA006$	2024-11-25
4	날씨	        오늘은 미세먼지 없나?	    정영훈	JAVA006$	2024-11-25
5	아침에	        혼자 와있으면 추워요	    박제훈	JAVA006$	2024-11-25
6	질문있습니다	쉬었다 하면 안되나요	    임성산	JAVA006$	2024-11-25
7	질문있습니다	앗 생각나면 다시 질문할께요	김민승	JAVA006$	2024-11-25
*/


--○ 커밋
COMMIT;


--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=3;
--==>> 1 행 이(가) 삭제되었습니다.


DELETE
FROM TBL_BOARD
WHERE NO=7;
--==>> --==>> 1 행 이(가) 삭제되었습니다.


--○ 게시물 작성
INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'설문','좋아하는 축구 팀은?','정영훈','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.

--○ 게시물 삭제
DELETE
FROM TBL_BOARD
WHERE NO=6;
--==>>1 행 이(가) 삭제되었습니다.


--○ 커밋
COMMIT;
--==>> 커밋 완료.

--○ 확인
SELECT *
FROM TBL_BOARD;
--==>>
/*
1	앗싸~1등	    내가 1등이지롱	        김믿음	JAVA006$	2024-11-25
2	건강관리	    다들 건강 챙깁시다	    박지우	JAVA006$	2024-11-25
4	날씨	        오늘은 미세먼지 없나?	정영훈	JAVA006$	2024-11-25
5	아침에	        혼자 와있으면 추워요	박제훈	JAVA006$	2024-11-25
8	설문	        좋아하는 축구 팀은?	    정영훈	JAVA006$	2024-11-25
*/


SELECT ROW_NUMBER() OVER(ORDER BY CREATED)"글번호"
        , TITLE "제목", NAME"작성자" ,CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;
/*
5	설문	    정영훈	2024-11-25
4	아침에	    박제훈	2024-11-25
3	날씨  	    정영훈	2024-11-25
2	건강관리	박지우	2024-11-25
1	앗싸~1등	김믿음	2024-11-25
*/



--○ 게시물 삭제
DELETE 
FROM TBL_BOARD
WHERE NO=5;
--==>>1 행 이(가) 삭제되었습니다.


--○ 게시물 작성
INSERT INTO TBL_BOARD(NO, TITLE, CONTENTS, NAME, PW, CREATED)
VALUES(SEQ_BOARD.NEXTVAL,'외로워도','슬퍼도 나는 안울어','안석창','JAVA006$',DEFAULT);
--==>>1 행 이(가) 삽입되었습니다.


--○ 커밋
COMMIT;
--==>> 커밋 완료.


SELECT ROW_NUMBER() OVER(ORDER BY CREATED)"글번호"
        , TITLE "제목", NAME"작성자" ,CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;
--==>>
/*
5	외로워도	안석창	2024-11-25
4	설문	    정영훈	2024-11-25
3	날씨	    정영훈	2024-11-25
2	건강관리	박지우	2024-11-25
1	앗싸~1등	김믿음	2024-11-25
*/

SELECT *
FROM TBL_BOARD;
/*
1	앗싸~1등	내가 1등이지롱	        김믿음	JAVA006$	2024-11-25
2	건강관리	다들 건강 챙깁시다	    박지우	JAVA006$	2024-11-25
9	외로워도	슬퍼도 나는 안울어	    안석창	JAVA006$	2024-11-25
4	날씨	    오늘은 미세먼지 없나?	정영훈	JAVA006$	2024-11-25
8	설문	    좋아하는 축구 팀은?	    정영훈	JAVA006$	2024-11-25
*/



SELECT ROW_NUMBER() OVER(ORDER BY CREATED)"글번호"
        , TITLE "제목", NAME"작성자" ,CREATED "작성일"
FROM TBL_BOARD
ORDER BY 4 DESC;
--==>>
/*
5	외로워도	안석창	2024-11-25
4	설문	    정영훈	2024-11-25
3	날씨	    정영훈	2024-11-25
2	건강관리	박지우	2024-11-25
1	앗싸~1등	김믿음	2024-11-25
*/


--------------------------------------------------------------------------------

--■ ■ ■ JOIN(조인) ■ ■ ■--

SELECT *
FROM EMP;

SELECT *
FROM DEPT;

SELECT *
FROM SALGRADE;

--------------------------------------------------------------------------------
-- 7369 SMITH CLERK     1980-12-17      FORD     800  (null)    RESEARCH   DALLAS      1등급
-- 7499 ALLEN SALESMAN  1981-02-20      BLAKE   1600     300    SALES      CHICAGO     3등급          
--                                      :




--1. SQL 1992 CODE
SELECT *
FROM EMP, DEPT;
--> 수학에서 말하는 데카르트 곱(catersian product)
--  두 테이블을 합친(결합한) 모든 경우의 수


-- Equi join :  서로 정확히 일치하는 데이터들끼리 연결시키는 결합

SELECT *
FROM EMP,DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO;
--==>>
/*
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	10	ACCOUNTING	NEW YORK
7839	KING	PRESIDENT		    1981-11-17	5000		    10	10	ACCOUNTING	NEW YORK
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	10	ACCOUNTING	NEW YORK
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20	20	RESEARCH	DALLAS
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	20	RESEARCH	DALLAS
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	20	RESEARCH	DALLAS
7369	SMITH	CLERK	    7902	1980-12-17	800		        20	20	RESEARCH	DALLAS
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	20	RESEARCH	DALLAS
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	30	SALES	    CHICAGO
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	30	SALES	    CHICAGO
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	30	SALES	    CHICAGO
7900	JAMES	CLERK	    7698	1981-12-03	950		30	    30	    SALES	    CHICAGO
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	30	SALES	    CHICAGO
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	30	SALES	    CHICAGO
*/

SELECT *
FROM EMP E,DEPT D
WHERE E.DEPTNO = D.DEPTNO;
--==>>
/*
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	10	ACCOUNTING	NEW YORK
7839	KING	PRESIDENT		    1981-11-17	5000		    10	10	ACCOUNTING	NEW YORK
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	10	ACCOUNTING	NEW YORK
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20	20	RESEARCH	DALLAS
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	20	RESEARCH	DALLAS
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	20	RESEARCH	DALLAS
7369	SMITH	CLERK	    7902	1980-12-17	800		        20	20	RESEARCH	DALLAS
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	20	RESEARCH	DALLAS
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	30	SALES	    CHICAGO
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	30	SALES	    CHICAGO
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	30	SALES	    CHICAGO
7900	JAMES	CLERK	    7698	1981-12-03	950		30	    30	    SALES	    CHICAGO
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	30	SALES	    CHICAGO
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	30	SALES	    CHICAGO
*/


SELECT *
FROM EMP;
SELECT *
FROM SALGRADE;


-- Non Equi Join : 범위 안에 적합한 데이터들끼리 결합시키는 방식
SELECT *
FROM EMP, SALGRADE
WHERE EMP.SAL BETWEEN SALGRADE.LOSAL AND SALGRADE.HISAL;
/*
7369	SMITH	CLERK	    7902	1980-12-17	800		        20	1	700	    1200
7900	JAMES	CLERK	    7698	1981-12-03	950		        30	1	700	    1200
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	1	700	    1200
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	2	1201	1400
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	2	1201	1400
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	2	1201	1400
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	3	1401	2000
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	3	1401	2000
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	4	2001	3000
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	4	2001	3000
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20	4	2001	3000
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	4	2001	3000
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	4	2001	3000
7839	KING	PRESIDENT	    	1981-11-17	5000		    10	5	3001	9999
*/

-- 별칭 사용 가능
SELECT *
FROM EMP E,SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;
/*
7369	SMITH	CLERK	    7902	1980-12-17	800		        20	1	700	    1200
7900	JAMES	CLERK	    7698	1981-12-03	950		        30	1	700	    1200
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	1	700	    1200
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	2	1201	1400
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	2	1201	1400
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	2	1201	1400
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	3	1401	2000
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	3	1401	2000
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	4	2001	3000
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	4	2001	3000
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20	4	2001	3000
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	4	2001	3000
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	4	2001	3000
7839	KING	PRESIDENT	    	1981-11-17	5000		    10	5	3001	9999
*/


-- Equi Join 시 『+』를 활용한 결합 방법
SELECT *
FROM TBL_EMP;

SELECT *
FROM TBL_DEPT;

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO = D.DEPTNO;
/*
7369	SMITH	CLERK	    7902	1980-12-17	800		        20	20	RESEARCH	DALLAS
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	30	SALES	    CHICAGO
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	30	SALES	    CHICAGO
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20	20	RESEARCH	DALLAS
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	30	SALES	    CHICAGO
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	30	SALES	    CHICAGO
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	10	ACCOUNTING	NEW YORK
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	20	RESEARCH	DALLAS
7839	KING	PRESIDENT		    1981-11-17	5000		    10	10	ACCOUNTING	NEW YORK
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	30	SALES	    CHICAGO
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	20	RESEARCH	DALLAS
7900	JAMES	CLERK	    7698	1981-12-03	950		30	    30	    SALES	    CHICAGO
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	20	RESEARCH	DALLAS
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	10	ACCOUNTING	NEW YORK
*/


SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO = D.DEPTNO(+);
--> 총 19건의 데이터가 결합되어 조회된 상황.
--  즉, 부서번호를 갖지 못한 사원들(5인)도 모두 조회된 상황
/*
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	10	ACCOUNTING	NEW YORK
7839	KING	PRESIDENT		    1981-11-17	5000		    10	10	ACCOUNTING	NEW YORK
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	10	ACCOUNTING	NEW YORK
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	20	RESEARCH	DALLAS
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	20	RESEARCH	DALLAS
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	20	RESEARCH	DALLAS
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20	20	RESEARCH	DALLAS
7369	SMITH	CLERK	    7902	1980-12-17	800		        20	20	RESEARCH	DALLAS
7900	JAMES	CLERK	    7698	1981-12-03	950		        30	30	SALES	CHICAGO
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	30	SALES	CHICAGO
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	30	SALES	CHICAGO
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	30	SALES	CHICAGO
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	30	SALES	CHICAGO
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	30	SALES	CHICAGO
8005	카리나	SALESMAN	7698	2024-11-22	1000					
8004	손흥민	SALESMAN	7698	2024-11-22	2500					
8003	이준혁	SALESMAN	7698	2024-11-22	2000					
8002	수지	CLERK	    7566	2024-11-22	1000	0				
8001	아이유	CLERK	    7566	2024-11-22	1500	10				
*/

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO;
-->> 총 16건의 데이터가 결합되어 조회된 상황.
--   즉, 부서에 소속된 사원이 아무도 없는 부서(2부서)도 모두 조회된 상황

--※ (+)가  없는 쪽 테이블의 데이터를 모두 메모리에 적자핸 후
--  (+)가 있는 쪽 테이블의 데이터를 하나하나 확인하여 결합시키는 형태로
--  JOIN 이 이루어진다.


/*
7369	SMITH	CLERK	    7902	1980-12-17	800		    20	20	RESEARCH	DALLAS
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	30	30	SALES	    CHICAGO
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	30	30	SALES	    CHICAGO
7566	JONES	MANAGER	    7839	1981-04-02	2975		20	20	RESEARCH	DALLAS
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	30	SALES	CHICAGO
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		30	30	SALES	    CHICAGO
7782	CLARK	MANAGER	    7839	1981-06-09	2450		10	10	ACCOUNTING	NEW YORK
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		20	20	RESEARCH	DALLAS
7839	KING	PRESIDENT		    1981-11-17	5000		10	10	ACCOUNTING	NEW YORK
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	30	30	SALES	    CHICAGO
7876	ADAMS	CLERK	    7788	1987-07-13	1100		20	20	RESEARCH	DALLAS
7900	JAMES	CLERK	    7698	1981-12-03	950		    30	30	SALES	    CHICAGO
7902	FORD	ANALYST	    7566	1981-12-03	3000		20	20	RESEARCH	DALLAS
7934	MILLER	CLERK	    7782	1982-01-23	1300		10	10	ACCOUNTING	NEW YORK
                                                            50	개발부	서울
                                                            40	OPERATIONS	BOSTON
*/

SELECT *
FROM TBL_EMP E, TBL_DEPT D
WHERE E.DEPTNO(+) = D.DEPTNO(+);
--> 위와 같은 이유로 이런 형식의 JOIN구문은 존재하지 않는다.








--2. SQL 1999 CODE → 『JOIN』 키워드 등장 → JOIN 유형 명시
--                      결합 조건은 『WHERE』 대신 『ON』


-- CROSS JOIN
SELECT *
FROM EMP CROSS JOIN DEPT;


-- INNER JOIN
SELECT *
FROM EMP E INNER JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;


--※ INNER JOIN 시 INNER 는 생략 가능

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP E JOIN SALGRADE S
ON E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- OUTER JOIN
SELECT *
FROM TBL_EMP E LEFT OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;
/*
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	10	ACCOUNTING	NEW YORK
7839	KING	PRESIDENT		    1981-11-17	5000		    10	10	ACCOUNTING	NEW YORK
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	10	ACCOUNTING	NEW YORK
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	20	RESEARCH	DALLAS
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	20	RESEARCH	DALLAS
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	20	RESEARCH	DALLAS
7566	JONES	MANAGER	    7839	1981-04-02	2975		    20	20	RESEARCH	DALLAS
7369	SMITH	CLERK	    7902	1980-12-17	800		        20	20	RESEARCH	DALLAS
7900	JAMES	CLERK	    7698	1981-12-03	950		        30	30	SALES	    CHICAGO
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	30	SALES	    CHICAGO
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	30	SALES	    CHICAGO
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	30	SALES	    CHICAGO
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	30	SALES	    CHICAGO
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	30	SALES	    CHICAGO
8005	카리나	SALESMAN	7698	2024-11-22	1000					
8004	손흥민	SALESMAN	7698	2024-11-22	2500					
8003	이준혁	SALESMAN	7698	2024-11-22	2000					
8002	수지	CLERK	    7566	2024-11-22	1000	0				
8001	아이유	CLERK	    7566	2024-11-22	1500	10				
*/



--※ 방향이 지정된 쪽 테이블(→LEFT)의 데이터를 메모리에 적자한 후
--  방향이 지정되지 않은 쪽 테이블들의 데이터를 각각 확인하여 결합시키는 형태로
--  JOIN 이 이루어진다.


SELECT *
FROM TBL_EMP E RIGHT OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;
/*
7369	SMITH	CLERK	    7902	1980-12-17	800		20	    20	    RESEARCH	DALLAS
7499	ALLEN	SALESMAN	7698	1981-02-20	1600	300	    30	30	SALES	    CHICAGO
7521	WARD	SALESMAN	7698	1981-02-22	1250	500	    30	30	SALES	    CHICAGO
7566	JONES	MANAGER	7   839	    1981-04-02	2975		    20	20	RESEARCH	DALLAS
7654	MARTIN	SALESMAN	7698	1981-09-28	1250	1400	30	30	SALES	    CHICAGO
7698	BLAKE	MANAGER	    7839	1981-05-01	2850		    30	30	SALES	    CHICAGO
7782	CLARK	MANAGER	    7839	1981-06-09	2450		    10	10	ACCOUNTING	NEW YORK
7788	SCOTT	ANALYST	    7566	1987-07-13	3000		    20	20	RESEARCH	DALLAS
7839	KING	PRESIDENT		    1981-11-17	5000		    10	10	ACCOUNTING	NEW YORK
7844	TURNER	SALESMAN	7698	1981-09-08	1500	0	    30	30	SALES	    CHICAGO
7876	ADAMS	CLERK	    7788	1987-07-13	1100		    20	20	RESEARCH	DALLAS
7900	JAMES	CLERK	    7698	1981-12-03	950		30	    30	    SALES	    CHICAGO
7902	FORD	ANALYST	    7566	1981-12-03	3000		    20	20	RESEARCH	DALLAS
7934	MILLER	CLERK	    7782	1982-01-23	1300		    10	10	ACCOUNTING	NEW YORK
                                                                    50	개발부	서울
                                                                    40	OPERATIONS	BOSTON
*/

SELECT *
FROM TBL_EMP E FULL OUTER JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;


--※ OUTER JOIN 에서 OUTER 는 생략 가능

SELECT *
FROM TBL_EMP E FULL JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;             --OUTER JOIN

SELECT *
FROM TBL_EMP E LEFT JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;             --OUTER JOIN

SELECT *
FROM TBL_EMP E RIGHT JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;             --OUTER JOIN


SELECT *
FROM TBL_EMP E JOIN TBL_DEPT D
ON E.DEPTNO = D.DEPTNO;             --INNER JOIN

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
AND JOB = 'CLERK';


SELECT *
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE JOB = 'CLERK';



--------------------------------------------------------------------------------

--○ EMP 테이블과 DEPT 테이블을 대상으로
--  직종이 MANAGER 와 CLERK 인 사원들만
--  부서번호, 부서명, 사원명, 직종명, 급여 항목을 조회한다.
--  -------   -----   -----   -----   ----
--   DEPTNO   DNAME   ENAME   JOB     SAL
--   ------   -----   -----  -----   ------
--    E, D      D       E      E       E

--> 두 테이블간 중복되는 컬럼에 대한 소속 테이블을
--  정해주지 않으면 오류발생
--  SELECT 문에서 각 테이블의 ALIAS 를 지정해주면 오라클은 불필요한 작업을 하지않는다.

SELECT D.DEPTNO"부서번호",D.DNAME"부서명",E.ENAME"사원명",JOB"직종명",SAL"급여"
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO
WHERE JOB = 'MANAGER' OR JOB ='CLERK';
--> 두 테이블 간 중복되는 컬럼에 대해 소속 테이블을 명시하는 경우
--  부서(DEPT), 사원(EMP) 중 어떤 테이블을 지정해도
--  쿼리문 수행에 대한 결과 반환에는 문제가 없다.(차이도 없다.)

-- ※ 하지만...
--   두 테이블 간 중복되는 컬럼에 대한 소속 테이블을 명시하는 경우
--   부모 테이블의 컬럼을 참조할 수 있도록 해야 한다.
SELECT *
FROM DEPT;      -- 부모 테이블
SELECT *
FROM EMP;       -- 자식 테이블

-- ※ 부모 자식 테이블 관계를 명확히 정리할 수 있도록 한다.

--     DEPTNO
-- EMP--------DEPT


SELECT D.DEPTNO,DNAME,ENAME,JOB,SAL
FROM EMP E RIGHT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;

SELECT E.DEPTNO,DNAME,ENAME,JOB,SAL
FROM EMP E RIGHT JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;


-- 최종 쿼리
SELECT D.DEPTNO,D.DNAME,E.ENAME,E.JOB,E.SAL
FROM EMP E , DEPT D
WHERE E.DEPTNO = D.DEPTNO;


SELECT D.DEPTNO,D.DNAME,E.ENAME,E.JOB,E.SAL
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;




--> 두 테이블 간 중복된 컬럼이 아니더라도...
--  소속 테이블을 명시할 수 있도록 권장한다.


--○ SELF JOIN(자기 조인)
--  EMP 테이블의 데이터를 다음과 같이 조회할 수 있도록 쿼리문을 구성한다.

-----------------------------------------------------------------------
--  사원번호   사원명   직종명    관리자번호    관리자명    관리자직종명
-----------------------------------------------------------------------
--    7369      SWMITH  CLERK       7902          FORD        ANALUST
--    7499      ALLEN   SALESMAN    7698          BLAKE       MANAGER
--                                  :
--                                  :



SELECT EMPNO,ENAME,JOB,MGR
FROM EMP;


--> OUTER JOIN 하지않을시 1명이 NULL이기때문에 소환되지않음
SELECT E.EMPNO,E.ENAME,E.JOB,E.MGR,W.ENAME,W.JOB
FROM EMP E LEFT JOIN EMP W
ON E.MGR = W.EMPNO
ORDER BY 1;
--==>>
/*
7369	SMITH	CLERK	    7902	FORD	ANALYST
7499	ALLEN	SALESMAN	7698	BLAKE	MANAGER
7521	WARD	SALESMAN	7698	BLAKE	MANAGER
7566	JONES	MANAGER	    7839	KING	PRESIDENT
7654	MARTIN	SALESMAN	7698	BLAKE	MANAGER
7698	BLAKE	MANAGER	    7839	KING	PRESIDENT
7782	CLARK	MANAGER	    7839	KING	PRESIDENT
7788	SCOTT	ANALYST	    7566	JONES	MANAGER
7839	KING	PRESIDENT			
7844	TURNER	SALESMAN	7698	BLAKE	MANAGER
7876	ADAMS	CLERK	    7788	SCOTT	ANALYST
7900	JAMES	CLERK	    7698	BLAKE	MANAGER
7902	FORD	ANALYST	    7566	JONES	MANAGER
7934	MILLER	CLERK	    7782	CLARK	MANAGER
*/




SELECT USER
FROM DUAL;
--==>>HR


--○ 세 개이상의 테이블 조인(JOIN, 결합)

--형식1(SQL 1992 CODE)
SELECT 테이블명1.컬럼명, 테이블명2.컬럼명, 테이블명3.컬럼명
FROM 테이블명1,테이블명2,테이블명3
WHERE 테이블명1,컬렴명1 = 테이블명2.컬럼명1
AND  테이블명2.컬렴명2 = 테이블명3.컬럼명2

--형식2(SQL 1995 CODE)

FROM 테이블명1 JOIN 테이블명2
ON 테이블명1.컬럼명1 = 테이블명2.컬럼명1
            JOIN 테이블명3
            ON 테이블명2.컬럼명2 = 테이블명3.컬럼명2;
            
            
            
            
--○ HR 계정 소유의 테이블 또는 뷰 목록 조회
SELECT *
FROM TAB;
--==>>
/*
COUNTRIES	        TABLE	
DEPARTMENTS	        TABLE	
EMPLOYEES	        TABLE	
EMP_DETAILS_VIEW	VIEW	
JOBS	            TABLE	
JOB_HISTORY	        TABLE	
LOCATIONS	        TABLE	
REGIONS	            TABLE	
*/


--○ HR.JOBS, HR.EMPLOYEES, HR.DEPARTMENTS 테이블을 대상으로
--  직원들의 FIRST_NAME, LAST_NAME, JOB_TITLE, DEPARTMENT_NAME
--  항목을 조회한다.

-- 형식 1
SELECT EMPLOYEES.FIRST_NAME,EMPLOYEES.LAST_NAME,JOBS.JOB_TITLE,DEPARTMENTS.DEPARTMENT_NAME
FROM JOBS,DEPARTMENTS,EMPLOYEES
WHERE JOBS.JOB_ID = EMPLOYEES.JOB_ID
AND   EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID(+);


-- 형식 2
SELECT EMPLOYEES.FIRST_NAME,EMPLOYEES.LAST_NAME,JOBS.JOB_TITLE,DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES JOIN JOBS 
ON EMPLOYEES.JOB_ID = JOBS.JOB_ID 
        LEFT JOIN DEPARTMENTS 
        ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;




                                  
--○ EMPLOYEES, DEPARTMENTS, JOBS, LOCATIONS, COUNTRIES, REGIONS 테이블을 대상으로
--  직원들의 데이터를 다음과 같이 조회할 수 있도록 쿼리문을 구성한다.
--  FIRST_NAME, LAST_NAME, JOB_TITLE, DEPARTMENT_NAME,CITY,COUNTRY_NAME,REGION_NAME




SELECT E.FIRST_NAME,E.LAST_NAME,J.JOB_TITLE,D.DEPARTMENT_NAME,L.CITY,C.COUNTRY_NAME,REGION_NAME
FROM EMPLOYEES E JOIN JOBS J
ON E.JOB_ID = J.JOB_ID
        LEFT JOIN DEPARTMENTS D
        ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
        LEFT JOIN LOCATIONS L
        ON  D.LOCATION_ID =L.LOCATION_ID
        LEFT JOIN COUNTRIES C
        ON  L.COUNTRY_ID = C.COUNTRY_ID
        LEFT JOIN REGIONS R
        ON  C.REGION_ID = R.REGION_ID
        ORDER BY 1;

----------------------------------------------------------------------------------------------

        
        
        
        

SELECT *
FROM DEPARTMENTS;
SELECT *
FROM JOBS;
SELECT *
FROM EMPLOYEES;
SELECT *
FROM LOCATIONS;
SELECT *
FROM COUNTRIES;
SELECT *
FROM REGIONS;SELECT USER
FROM DUAL;
--==>> SCOTT



--■ ■ ■ UNION / UNION ALL ■ ■ ■--

--○ 실습 테이블 생성
-- 테이블명 : TBL_.JUMUN
CREATE TABLE TBL_JUMUN                      -- 주문 테이블 생성
( JUNO      NUMBER                          -- 주문번호
, JECODE    VARCHAR2(30)                    -- 주문된 제품 코드
, JUSU      NUMBER                          -- 주문수량
, JUDAY     DATE DEFAULT SYSDATE            -- 주문일자
);

--==>> Table TBL_JUMUN이(가) 생성되었습니다.


--○ 데이터 입력 → 고객의 주문 발생 / 접수
INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(1, '오감자', 20, TO_DATE('2001-11-01 09:10:12', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(2, '초코송이', 10, TO_DATE('2001-11-01 09:23:37', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(3, '오레오', 30, TO_DATE('2001-11-01 11:41:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(4, '새우깡', 12, TO_DATE('2001-11-02 10:00:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(5, '홈런볼', 50, TO_DATE('2001-11-03 15:50:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(6, '맛동산', 40, TO_DATE('2001-11-04 20:20:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(7, '포카칩', 40, TO_DATE('2001-11-20 14:20:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(8, '이구동성', 20, TO_DATE('2001-11-22 10:10:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(9, '빈츠', 30, TO_DATE('2001-11-23 05:13:22', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(10, '브이콘', 30, TO_DATE('2001-11-24 04:44:20', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(11, '홈런볼', 30, TO_DATE('2001-11-25 10:10:20', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(12, '프링글스', 20, TO_DATE('2001-11-25 15:15:15', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(13, '치토스', 20, TO_DATE('2001-11-26 12:10:42', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(14, '오징어칩', 20, TO_DATE('2001-11-27 17:10:00', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(15, '초코송이', 10, TO_DATE('2001-11-28 03:22:11', 'YYYY-MM-DD HH24:MI:SS'));

INSERT INTO TBL_JUMUN(JUNO,JECODE,JUSU,JUDAY)
VALUES(16, '치토스', 30, TO_DATE('2001-11-29 14:22:00', 'YYYY-MM-DD HH24:MI:SS'));

--==>> 1 행 이(가) 삽입되었습니다.

ALTER SESSION SET NLS_DATE_FORMAT='YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.


-- 확인
SELECT *
FROM TBL_JUMUN;
/*
1	오감자	    20	2001-11-01 09:10:12
2	초코송이	10	2001-11-01 09:23:37
3	오레오	    30	2001-11-01 11:41:00
4	새우깡	    12	2001-11-02 10:00:00
5	홈런볼	    50	2001-11-03 15:50:00
6	맛동산	    40	2001-11-04 20:20:00
7	포카칩	    40	2001-11-20 14:20:00
8	이구동성	20	2001-11-22 10:10:00
9	빈츠	    30	2001-11-23 05:13:22
10	브이콘	    30	2001-11-24 04:44:20
11	홈런볼	    30	2001-11-25 10:10:20
12	프링글스	20	2001-11-25 15:15:15
13	치토스	    20	2001-11-26 12:10:42
14	오징어칩	20	2001-11-27 17:10:00
15	초코송이	10	2001-11-28 03:22:11
16	치토스	    30	2001-11-29 14:22:00
*/



COMMIT;
--==>> 커밋 완료.




-- ○ 데이터 추가 입력 → 2001년 부터 시작된 주문이 현재(2024년)까지 계속 발생
INSERT INTO TBL_JUMUN VALUES(938765, '홈런볼',10,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938766, '빈츠',10,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938767, '썬칩',50,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938768, '홈런볼',50,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938769, '허니버터칩',30,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938770, '허니버터칩',20,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938771, '홈런볼',20,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938772, '초코송이',40,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938773, '포카칩',40,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938774, '칸쵸',20,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938775, '바나나킥',10,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938776, '맛동산',20,SYSDATE);
--==>> 1 행 이(가) 삽입되었습니다.


--○ 확인
SELECT *
FROM TBL_JUMUN;
/*
1	오감자 	        20	2001-11-01 09:10:12
2	초코송이	    10	2001-11-01 09:23:37
3	오레오	        30	2001-11-01 11:41:00
4	새우깡	        12	2001-11-02 10:00:00
5	홈런볼	        50	2001-11-03 15:50:00
6	맛동산	        40	2001-11-04 20:20:00
7	포카칩	        40	2001-11-20 14:20:00
8	이구동성	    20	2001-11-22 10:10:00
9	빈츠	        30	2001-11-23 05:13:22
10	브이콘	        30	2001-11-24 04:44:20
11	홈런볼	        30	2001-11-25 10:10:20
12	프링글스	    20	2001-11-25 15:15:15
13	치토스	        20	2001-11-26 12:10:42
14	오징어칩	    20	2001-11-27 17:10:00
15	초코송이	    10	2001-11-28 03:22:11
16	치토스	        30	2001-11-29 14:22:00
938765	홈런볼	    10	2024-11-26 14:34:56
938766	빈츠	    10	2024-11-26 14:35:21
938767	썬칩	    50	2024-11-26 14:35:48
938768	홈런볼	    50	2024-11-26 14:36:09
938769	허니버터칩	30	2024-11-26 14:36:38
938770	허니버터칩	20	2024-11-26 14:37:23
938771	홈런볼	    20	2024-11-26 14:37:30
938772	초코송이	40	2024-11-26 14:37:45
938773	포카칩	    40	2024-11-26 14:38:03
938774	칸쵸	    20	2024-11-26 14:38:21
938776	맛동산	    20	2024-11-26 14:39:12
938775	바나나킥	10	2024-11-26 14:41:12
*/




--※  영훈이가 2001년도 부터 과자 쇼핑몰 운영 중...
--   TBL_JUMUN 테이블이 매우 무거워진 상황
--   어플리케이션과의 연동으로 인해 주문 내역을
--   다른 테이블에 저장할 수 있도록 만드는 것은 힘든 상황
--   기존의 모든 데이터를 덮어놓고 지우는 것도 불가능한 상황
--   → 결과적으로 ... 현재까지 누적된 주문 데이터 중
--   금일 발생한 주문 내역을 제외하고
--   나머지를 다른 테이블로 데이터 이관을 수행할 계획

--○ TBL_JUMUN 테이블에서 금일 발생한 주문 내역을 제외하고
--  나머지 데이터 조회


SELECT *
FROM TBL_JUMUN
WHERE TO_CHAR(JUDAY,'YYYY-MM-DD') != TO_CHAR(SYSDATE,'YYYY-MM-DD');
/*
1	오감자	20	2001-11-01 09:10:12
2	초코송이	10	2001-11-01 09:23:37
3	오레오	30	2001-11-01 11:41:00
4	새우깡	12	2001-11-02 10:00:00
5	홈런볼	50	2001-11-03 15:50:00
6	맛동산	40	2001-11-04 20:20:00
7	포카칩	40	2001-11-20 14:20:00
8	이구동성	20	2001-11-22 10:10:00
9	빈츠	30	2001-11-23 05:13:22
10	브이콘	30	2001-11-24 04:44:20
11	홈런볼	30	2001-11-25 10:10:20
12	프링글스	20	2001-11-25 15:15:15
13	치토스	20	2001-11-26 12:10:42
14	오징어칩	20	2001-11-27 17:10:00
15	초코송이	10	2001-11-28 03:22:11
16	치토스	30	2001-11-29 14:22:00
*/


-- 위의 조회 결과로 TBL_JUMUNBACKUP 테이블 생성

CREATE TABLE TBL_JUMUNBACKUP
AS
SELECT *
FROM TBL_JUMUN
WHERE TO_CHAR(JUDAY, 'YYYY-MM-DD') != TO_CHAR(SYSDATE,'YYYY-MM-DD');
--==>>Table TBL_JUMUNBACKUP이(가) 생성되었습니다.

SELECT *
FROM TBL_JUMUNBACKUP;

/*
1	오감자	20	2001-11-01 09:10:12
2	초코송이	10	2001-11-01 09:23:37
3	오레오	30	2001-11-01 11:41:00
4	새우깡	12	2001-11-02 10:00:00
5	홈런볼	50	2001-11-03 15:50:00
6	맛동산	40	2001-11-04 20:20:00
7	포카칩	40	2001-11-20 14:20:00
8	이구동성	20	2001-11-22 10:10:00
9	빈츠	30	2001-11-23 05:13:22
10	브이콘	30	2001-11-24 04:44:20
11	홈런볼	30	2001-11-25 10:10:20
12	프링글스	20	2001-11-25 15:15:15
13	치토스	20	2001-11-26 12:10:42
14	오징어칩	20	2001-11-27 17:10:00
15	초코송이	10	2001-11-28 03:22:11
16	치토스	30	2001-11-29 14:22:00
*/

--> TBL_JUMUN 테이블의 데이터들 중
--  금일 주문내역 이외의 데이터는 모두 TBL_JUMUNBACKUP 테이블에 백업을 마친 상태

--○ TBL_JUMUN 테이블의 데이터들 중
--  금일 주문내역 이외의 데이터는 모두 삭제


DELETE
FROM TBL_JUMUN
WHERE TO_CHAR(JUDAY,'YYYY-MM-DD') != TO_CHAR(SYSDATE,'YYYY-MM-DD');
--==>> 16개 행 이(가) 삭제되었습니다. → 938764 건의 데이터 삭제


-- 아직 제품 발송이 완료되지 않은 금일 주문 데이터를 제외하고
--  이전의 모든 주문 데이터들이 삭제된 상황이므로
-- 테이블의 행(레코드)의 갯수가 줄어들어 매우 가벼워진 상황

SELECT *
FROM TBL_JUMUNBACKUP;
--==>>
/*
1	오감자	    20	2001-11-01 09:10:12
2	초코송이	10	2001-11-01 09:23:37
3	오레오	    30	2001-11-01 11:41:00
4	새우깡	    12	2001-11-02 10:00:00
5	홈런볼	    50	2001-11-03 15:50:00
6	맛동산	    40	2001-11-04 20:20:00
7	포카칩	    40	2001-11-20 14:20:00
8	이구동성	20	2001-11-22 10:10:00
9	빈츠	    30	2001-11-23 05:13:22
10	브이콘	    30	2001-11-24 04:44:20
11	홈런볼	    30	2001-11-25 10:10:20
12	프링글스	20	2001-11-25 15:15:15
13	치토스	    20	2001-11-26 12:10:42
14	오징어칩	20	2001-11-27 17:10:00
15	초코송이	10	2001-11-28 03:22:11
16	치토스	    30	2001-11-29 14:22:00
*/

SELECT *
FROM TBL_JUMUN;
--==>>
/*
938765	홈런볼	    10	2024-11-26 14:34:56
938766	빈츠	    10	2024-11-26 14:35:21
938767	썬칩	    50	2024-11-26 14:35:48
938768	홈런볼	    50	2024-11-26 14:36:09
938769	허니버터칩	30	2024-11-26 14:36:38
938770	허니버터칩	20	2024-11-26 14:37:23
938771	홈런볼	    20	2024-11-26 14:37:30
938772	초코송이	40	2024-11-26 14:37:45
938773	포카칩	    40	2024-11-26 14:38:03
938774	칸쵸	    20	2024-11-26 14:38:21
938776	맛동산	    20	2024-11-26 14:39:12
938775	바나나킥	10	2024-11-26 14:41:12
*/


COMMIT;
--==>> 커밋 완료.

-- 그런데, 지금까지 주문받은 내역에 대한 정보를
-- 제품별 총 주문량으로 나타내야 할 상황이 발생하게 되었다.
-- 그렇다면... TBL_JUMUNBACKUP 테이블의 레코드(행)와
-- TBL_JUMUN 테이블의 레코드(행)을 합쳐서
-- 하나의 테이블을 조회하는 것과 같은
-- 결과를 확인할 수 있도록 조회해야 한다.

-- 컬럼과 컬럼의 관계를 고려하여 테이블을 결합하고자 하는 경우 JOIN을 사용하지만
-- 레코드(행)와 레코드(행)을 결합하고자 하는 경우 UNION /UNION ALL 을 사용할 수 있다.

SELECT *
FROM TBL_JUMUNBACKUP;
SELECT *
FROM TBL_JUMUN;


SELECT *
FROM TBL_JUMUN
UNION
SELECT *
FROM TBL_JUMUNBACKUP;


SELECT *
FROM TBL_JUMUN
UNION ALL
SELECT *
FROM TBL_JUMUNBACKUP;




--※  UNION은 항상 결과물의 첫 번째 컬럼을 기준으로
--   오름차순 정렬을 수행한다.
--   UNION ALL 은 결합된 순서대로(쿼리문 구성대로) 조회한 결과를 반환한다. (정렬 없음)
--   이로 인해 UNION 의 부하가 더 크다.
--   또한, UNION 은 결과물에서 중복된 행이 존재할 경우
--   중복을 제거하고 1개 행만 조회된 결과를 반환하게 된다.


--○  지금까지 주문받은 모든 데이터를 통해
--   제품별 총 주문량을 조회하는 쿼리문을 구성한다.
/*
---------------------------------
    제품코드        총주문량
---------------------------------
    ...                XX
    .......           XXX
    ...                XX
----------------------------------
*/

SELECT T.JECODE,SUM(T.JUSU)
FROM
(
SELECT JECODE,JUSU
FROM TBL_JUMUN
UNION ALL
SELECT JECODE,JUSU
FROM TBL_JUMUNBACKUP
)T
GROUP BY T.JECODE;

/*
썬칩	50
맛동산	60
새우깡	12
치토스	50
초코송이	60
포카칩	80
오감자	20
이구동성	20
오징어칩	20
바나나킥	10
브이콘	30
홈런볼	160
빈츠	40
허니버터칩	50
오레오	30
프링글스	20
칸쵸	20
*/

--> 이 문제를 해결하는 과정에서는 UNION 을 사용해서는 안된다.
-- → JECODE 와 JUSU 를 조회하는 과정에서 중복된 행을 제거하는 상황이 발생


--○  INTERSECT / MINUS(→ 교집합 / 차집합)
--  TBL_JUMUNBACKUP 테이블과 TBL_JUMUN 테이블에서
--  제품코드와 주ㅡ문량의 값이 똑같은 행만 추출하고자 한다
SELECT JECODE,JUSU
FROM TBL_JUMUNBACKUP
INTERSECT
SELECT JECODE,JUSU
FROM TBL_JUMUN;
--==>>
/*
포카칩	40
홈런볼	50
*/

UPDATE TBL_JUMUNBACKUP
SET JUSU = 40
WHERE JUNO = 2;
--==>>1 행 이(가) 업데이트되었습니다.




SELECT *
FROM TBL_JUMUNBACKUP;



UPDATE TBL_JUMUN
SET JUSU = 10
WHERE JUNO = 938768;
--==>> 1 행 이(가) 업데이트되었습니다.


UPDATE TBL_JUMUN
SET JUSU = 40
WHERE JUNO = 938776;
--==>> 1 행 이(가) 업데이트되었습니다.



COMMIT;
--==>> 커밋 완료



--○ TBL_JUMUNBACKUP 테이블과 TBL_JUMUN 테이블에서
--  제품코드와 주문량의 값이 똑같은 행의 정보를
--  주문번호, 제품코드, 주문수량, 주문일자 항목으로 조회한다.

SELECT F.JUNO,T.JECODE,T.JUSU,F.JUDAY
FROM
(
SELECT JECODE,JUSU
FROM TBL_JUMUN
INTERSECT
SELECT JECODE,JUSU
FROM TBL_JUMUNBACKUP
)T
JOIN
(
SELECT JUNO,JECODE,JUSU,JUDAY
FROM TBL_JUMUN
UNION ALL
SELECT JUNO,JECODE,JUSU,JUDAY
FROM TBL_JUMUNBACKUP
)F
ON T.JECODE = F.JECODE
AND T.JUSU = F.JUSU
ORDER BY 1;
/*
938772	    초코송이	40	2024-11-26 14:37:45
938773	        포카칩	40	2024-11-26 14:38:03
938776	        맛동산	40	2024-11-26 14:39:12
2	        초코송이	40	2001-11-01 09:23:37
6	            맛동산	40	2001-11-04 20:20:00
7	            포카칩	40	2001-11-20 14:20:00
*/


UPDATE TBL_JUMUNBACKUP
SET JUSU = 30
WHERE JUNO=2;
--==>>1 행 이(가) 업데이트되었습니다.

UPDATE TBL_JUMUN
SET JUSU = 30
WHERE JUNO=938772;
--==>>1 행 이(가) 업데이트되었습니다.


UPDATE TBL_JUMUNBACKUP
SET JUSU = 20
WHERE JUNO=6;
--==>>1 행 이(가) 업데이트되었습니다.

UPDATE TBL_JUMUN
SET JUSU = 20
WHERE JUNO=938776;
--==>>1 행 이(가) 업데이트되었습니다.

COMMIT;
--==>> 커밋 완료.



--※ 실습을 위한 추가 환경 구성
INSERT INTO TBL_JUMUNBACKUP VALUES(17,'초코송이',20,TO_DATE('2001-12-01 10:10:00', 'YYYY-MM-DD HH24:MI:SS'));
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_JUMUN VALUES(938777,'맛동산',40,SYSDATE);
--==>>1 행 이(가) 삽입되었습니다.

COMMIT;
--==>> 커밋 완료.


SELECT T.JUNO"제품번호",T.JECODE"제품코드",T.JUSU"주문수량",T.JUDAY"주문일자"
FROM
(
SELECT JUNO,JECODE,JUSU,JUDAY
FROM TBL_JUMUN
UNION ALL
SELECT JUNO,JECODE,JUSU,JUDAY
FROM TBL_JUMUNBACKUP
)T
--WHERE JECODE||JUSU IN ('초코송이30','맛동산20','포카칩40');
--WHERE CONCAT(JECODE,JUSU) = ANY('초코송이30','맛동산20','포카칩40');
WHERE CONCAT(JECODE,JUSU) = ANY(SELECT CONCAT(JECODE,JUSU)
                                FROM TBL_JUMUNBACKUP
                                INTERSECT
                                SELECT CONCAT(JECODE,JUSU)
                                FROM TBL_JUMUN);

--==>>
/*
938772	초코송이	30	2024-11-26 14:37:45
938773	포카칩	    40	2024-11-26 14:38:03
938776	맛동산	    20	2024-11-26 14:39:12
2	    초코송이	30	2001-11-01 09:23:37
6	    맛동산	    20	2001-11-04 20:20:00
7	    포카칩	    40	2001-11-20 14:20:00
*/



-- MINUS : 차집합

SELECT JECODE,JUSU
FROM TBL_JUMUNBACKUP
MINUS
SELECT JECODE,JUSU
FROM TBL_JUMUN;
/*
브이콘	    30
빈츠	    30
새우깡	    12
오감자	    20
오레오	    30
오징어칩	20
이구동성	20
초코송이	10
초코송이	20
치토스	    20
치토스	    30
프링글스	20
홈런볼	    30
홈런볼	    50
*/  

/*
        A= {10, 20, 30, 40, 50}
        B= {10, 20, 30}
        
        A - B = {40, 50}
*/

SELECT D.DEPTNO,D.DNAME,E.ENAME,E.SAL
FROM EMP E JOIN DEPT D
ON E.DEPTNO = D.DEPTNO;


-- CHECK !! NATURAL JOIN
SELECT DEPTNO,DNAME,ENAME,SAL
FROM EMP NATURAL JOIN DEPT;

-- CHECK !! USING
SELECT DEPTNO,DNAME,ENAME,SAL
FROM EMP JOIN DEPT
USING(DEPTNO);          -- DEPTNO 컬럼을 사용하여 조인시키라는 뜻 // 결합조건을 명시해주었기때문에 문제없음

SELECT USER
FROM DUAL;
--==>> HR

--------------------------------------------------------------------------------
--■ ■ ■ 정규화(Normallization) ■ ■ ■ --

--○ 정규화란?
--  한마디로 데이터베이스 서버의 메모리 낭비를 막기 위해
--  어떤 하나의 테이블을... 식별자를 가지는 여러 개의 테이블로
--  나누는 과정을 말한다.

-- EX) 영훈이가 옥장판을 판매한다.
--     고객리스트 → 거래처직원 명단이 적혀있는 수첩의 정보를
--     데이터베이스화 하려고 한다.

--     테이블명 : 거래처직원
/*
   10Byte        10Byte      10Byte        10Byte    10Byte  10Byte    10Byte
-------------------------------------------------------------------------------
거래처회사명   회사주소     회사전화   거래처직원명   직급   이메일   휴대폰
-------------------------------------------------------------------------------
    LG       서울여의도   02-3456-6789     안석창     부장   ASC@NA... 010-12...
    LG       서울여의도   02-3456-6789     이은솔     과장   LES@NA... 010-77...
    LG       서울여의도   02-3456-6789     정승민     대리   JSM@NA... 010-91...
    LG       서울여의도   02-3456-6789     박세진     부장   PSJ@NA... 010-48...
    SK       서울소곡동   02-1234-4567     곽유진     부장   KYJ@NA... 010-55...
    LG       부산동래구   051-9999-9999    윤영식     대리   YYS@NA... 010-66...
    LG       부산동래구   051-9999-9999    윤영식     대리   YYS@NA... 010-66...
                                    :
                                    :
-------------------------------------------------------------------------------
*/
/*
가정) 서울여의도 LG (본사) 라는 회사에 근무하는 거래처 직원 명단이
      총 100만 명이라고 가정한다.
      (한 행(레코드)은 70Byte 이다.)
      
      어느 날...『서울여의도』에 위치한 LG본사가
      『경기분당』으로 사옥을 이전하게 되었다.
      이로 인해...
      회사주소는 『경기분당』 으로 바뀌고
      회사전화는 『031-1111-2222』로 바뀌게 되었다.
      
      그러면... 100만 명의 회사주소와 회사전화를 변경해야 한다.
      
      - 이 때 수행되어야 할 쿼리문 → UPDATE
      
      
      UPDATE 거래처직원
      SET 회사주소='경기분당',회사전화 = '031-1111-2222'
      WHERE 거래처회사명='LG'
       AND  회사주소='서울여의도';
       
       --> 100만 개 행을 하드디스크상에서 읽어다가
           메모리에 로드시켜 주어야 한다.
           즉, 100만 * 70Byte 를 모두
           하드디스크상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.
           
           --> 이는 테이블의 설계가 잘못되었으므로
               DB 서버는 조만간 메모리 고갈로 인해 DOWN 될 것이다.
               
               -->그러므로 이와 같은 상황을 막기 위해 정규화 과정을 수행해야 한다.
               
 */
 
 -- 제 1 정규화
 --> 어떤 하나의 테이블에 반복되어 컬럼 값들이 존재한다면
 --  값들이 반복되어 나오는 컬럼을 분리하여
 --  새로운 테이블을 만들어준다.


--> 제 1 정규화를 수행하는 과정에서 분리된 테이블은
--  반드시 부모 테이블과 자식 테이블의 관계를 갖게 된다.  

-- 부모 테이블 → 참조받는 컬럼  → PRIMARY KEY(제약조건)(기본키)
-- 자식 테이블 → 참조하는 컬럼  → FOREIGN KEY(제약조건)(외래키,참조키)

--> 참조받는 컬럼이 갖는 특징(부모 테이블)
--  반드시 고유한 값(데이터)이 들어와야 한다.
--  즉, 중복된 값(데이터)이 없어야 한다.
--  NULL 이어서는 안된다.(비어있어서는 안된다.)
--  즉,NOT NULL 이어야 한다.

--> 참조하는 컬럼이 갖는 특징(자식 테이블)
--  부모 테이블의 참조받는 컬럼이 갖는 데이터들 중
--  하나인 데이터를 참조해야 한다.

--> 제1 정규화를 수행하는 과정에서
--  부모 테이블의 PRIMARY KEY 는
--  항상 자식 테이블의 FOREIGN KEY 로 전이된다.


/*
-- 테이블명 : 회사 → 부모 테이블
-------------------------------------------------------
회사아이디   거래처회사명   회사주소     회사전화   
=========
(참조받는컬럼)
-------------------------------------------------------
    10          LG          서울여의도   02-3456-6789 
    20          SK          서울소곡동   02-1234-4567 
    30          LG          부산동래구   051-9999-9999
-------------------------------------------------------


--테이블명 : 직원 → 자식 테이블
---------------------------------------------------------
거래처직원명   직급   이메일   휴대폰       회사아이디
                                            ==========
                                            (참조하는컬럼)
---------------------------------------------------------
    안석창     부장   ASC@NA... 010-12...       10
    이은솔     과장   LES@NA... 010-77...       10
    정승민     대리   JSM@NA... 010-91...       10
    박세진     부장   PSJ@NA... 010-48...       10
    곽유진     부장   KYJ@NA... 010-55...       20
    윤영식     대리   YYS@NA... 010-66...       30
                                    :
                                    :
-----------------------------------------
*/




--※ 테이블이 분할(분리)되기 이전 상태로 조회


SELECT A.거래처회사명, A.회사주소, A.회사전화, B.거래처직원명, B.직급, B.이메일, B.휴대폰
FROM 직원 ㅈ LEFT JOIN 회사 ㅎ
ON ㅈ.회사아이디 = ㅎ.회사아이디;

SELECT A.거래처회사명, A.회사주소, A.회사전화, B.거래처직원명, B.직급, B.이메일, B.휴대폰
FROM 직원 A,회사B
WHERE A.회사아이디 = B.회사아이디;


/*
가정) 서울여의도 LG (본사) 라는 회사에 근무하는 거래처 직원 명단이
      총 100만 명이라고 가정한다.
      
      어느 날...『서울여의도』에 위치한 LG본사가
      『경기분당』으로 사옥을 이전하게 되었다.
      이로 인해...
      회사주소는 『경기분당』 으로 바뀌고
      회사전화는 『031-1111-2222』로 바뀌게 되었다.
      
      그러면... 회사 테이블에서 1건의 회사주소와 회사전화를 변경해야 한다.
      
      - 이 때 수행되어야 할 쿼리문 → UPDATE
      
      
      UPDATE 회사
      SET 회사주소='경기분당',회사전화 = '031-1111-2222'
      WHERE 회사아이디=10
      
      
       
       --> 1개 행을 하드디스크상에서 읽어다가
           메모리에 로드시켜 주어야 한다.
           즉, 1 * 40Byte 를 모두
           하드디스크상에서 읽어다가 메모리에 로드시켜 주어야 한다는 말이다.
           
           --> 이는 테이블의 설계가 잘 된 상황이다.
               
               --> 정규화를 수행하기 이전에는 100만 건을  처리해야 할 업무에서
                   1건만 처리하면 되는 업무로 바뀐 상황이기 때문에
                   DB 서버는 메모리 고갈 없이 아주 빠르게 처리될 것이다.
                   
               
 */

/*
--A. 거래처회사명, 회사전화
--------------------------------------------------------------------------------
        정규화 이후                      |           정규화 이전
--------------------------------------------------------------------------------
SELECT 거래처회사명,회사전화             | SELECT 거래처회사명,회사전화
FROM 회사;                               | FROM   거래처직원;
→ 3 * 40Byte                             | → 200만 * 70Byte
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
*/


/*
--B. 거래처직원명, 직급
--------------------------------------------------------------------------------
        정규화 이후                      |           정규화 이전
--------------------------------------------------------------------------------
SELECT 거래처직원명,직급                 | SELECT 거래처직원명,직급
FROM 직원;                               | FROM   거래처직원;
→ 200만 * 50Byte                         | → 200만 * 70Byte
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
*/

/*
--C. 거래처회사명, 거래처직원명
--------------------------------------------------------------------------------
        정규화 이후                      |           정규화 이전
--------------------------------------------------------------------------------
SELECT A.거래처회사명,B.거래처직원명     | SELECT 거래처회사명,,거래처직원명
FROM 회사 A JOIN 직원 B                  | FROM   거래처직원;
ON A.회사아이디=B.회사아이디;            |
→ (회사) + (직원)                        | → 200만 * 70Byte
  (3*40Byte) + (200만*50Byte)
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
*/



/*
-- 테이블명 : 주문
------------------------------------------------------------------
   고객아이디        제품코드        주문일자            주문수량
------------------------------------------------------------------
KMS1127(김민승)   SWK123(새우깡)    2024-11-26 11:11:11     50
MJJ1127(문제정)   YPR456(양파링)    2024-11-26 13:40:54     30
AYJ3361(안예지)   SWK123(새우깡)    2024-11-27 10:22:30     20
AYJ3361(안예지)   KJK987(감자깡)    2024-11-27 10:23:20     50
KCM7654(공찬민)   KJK987(감자깡)    2024-11-27 11:30:50     20
                                :
                                :
------------------------------------------------------------------
*/

--※  하나의 테이블에 존재하는 PRIMARY KEY 의 최대 갯수는 1개이다.
--   하지만, PRIMARY KEY 를 이루는(구성하는) 컬럼의 갯수는
--   복수(다수, 여러개)인 것이 가능하다.
--   컬럼 1개로만 (단일 컬럼) 구성된 PRIMARY KEY 를
--   Single Primary Key 라고 부른다.
--   (→ 단일 프라이머리 키)
--   두 개 이상의 컬럼으로 구성된 PRIMARY KEY 를
--   Composite Primary Key 라고 부른다.
--   (→ 복합 프라이커리 키)

--○ 제 2 정규화
--> 제 1 정규화를 마친 결과물에서 PRIMARY KEY  가 SINGLE COLUMN 이라면
--  제 2 정규화는 수행하지 않는다.
--  하지만, PRIMARY KEY 가 COMPOSITE COLUMN 이라면
--  반드시 제 2 정규화를 수행해야 한다.


--> 식별자가 아닌 컬럼은 식별자 전체 컬럼에 의존적이어야 하는데
--  식별자 전체 컬럼이 아닌 일부 식별자 컬럼에 대해서 의존적이라면
--  이를 분리하여 새로운 테이블을 생성해준다.

/*
-- 테이블명 : 과목  → 부모 테이블
-------------------------------------------------------------------------------
과목번호   과목명  교수자번호   교수자명  강의실코드           강의실명
+++++++            ++++++++++
(P.K)                 (P.K)
-------------------------------------------------------------------------------
JAVA101   자바기초     21        장영실      A403      전산실습관 4층 30석 규모
JAVA102   자바중급     22        에디슨      T502      전자공학관 5층 20석 규모
DB102     오라클중급   22        에디슨      A201      전산실습관 2층 50석 규모
DB102     오라클중급   21        장영실      T502      전자공학관 5층 20석 규모
DB103     오라클고급   25        테슬라      A203      전산실습관 2층 30석 규모
JSP105    JSP심화      21        장영실      K101      인문사회관 1층 80석 규모
                                    :
                                    :
-------------------------------------------------------------------------------
  
--테이블명 : 점수  → 자식 테이블
-----------------------------------------------
과목번호   교수자번호   학번     학생명   점수
=====================
        (F.K)
++++++++                +++++
(P.K)                   (P.K)
-----------------------------------------------
 DB102         21      2409110   박제훈    90
 DB102         21      2409117   임성산    76
                        :
                        :
-----------------------------------------------                
*/



--○ 제 3정규화
--> 식별자가 아닌 컬럼이 식별자가 아닌 컬럼에 의존적인 상황이라면
--  이를 분리하여 새로운 테이블을 생성해 주어야 한다.


--※ 관계(Relation)의 종류

-- 1 : 1

-- 1 : 다(many)
--> 제 1정규화를 마친 결과물에서 대표적으로 나타나는 바람직한 관계
--  관계형 데이터베이스를 활용하는 과정에서 추구해야 하는 관계.

-- 다(many) : 다(many)
--> 논리적인 모델링에서는 존재할 수 있지만
--  실제 물리적인 모델링에서는 존재할 수 없는 관계.

/*
-- 테이블명 : 고객  (다 → 1)                  --테이블명 : 제품 (다 → 1)
-----------------------------                --------------------------------
고객번호 고객명 이메일 ...                   제품코드 제품명 제품단가 ...
-----------------------------                --------------------------------
 1100    김믿음 kme@test.co..                  swk123  새우깡  1500   ...
 1101    박지우 pjw@test.co..                  gjk234  감자깡  1000   ...
 1103    엄서연 usy@test.co..                  jgc345  자갈치   800   ...
            :                                             :
-----------------------------                --------------------------------


                        -- 테이블명 : 주문접수(등록) (다)
                        -----------------------------------------
                        고객번호  제품코드  주문일자  주문수량...
                        =======   ========
                        -----------------------------------------
                        1100      swk123    2024...      30    ...
                        1100      swk123    2024...      20    ...
                        1100      gjk123    2024...      30    ...
                        1103      jgc123    2024...      30    ...
                        -----------------------------------------
*/



--○ 제 4 정규화
--> 위에서 확인한 내용과 같이 『다:다』 관계를 『1:다』 관계로 깨트리는 과정이
--  제 4 정규화의 수행 과정이다.
--  → 일반적으로 파생 테이블 생성
--   → 『다:다』관계를 『1:다』 관계로 깨트리는 역할 수행


--○ 역정규화(비정규화,반정규화)


/*
--A 경우 → 역정규화를 수행하지 않는 것이 바람직한 경우

테이블명 : 부서                   테이블명 : 사원
  10      10    10                   10      10    10   10   10      10        10
-----------------------           ----------------------------------------- + ----
부서번호 부서명 주소              사원번호 사원명 직급 급여 입사일 부서번호   부서명
++++++++                          ++++++++                          =======
-----------------------           ----------------------------------------- + ----
      10개 행                                     1,000,000개 행
-----------------------           ----------------------------------------- + ----

>> 업무 분석 상 조회 결과물
--------------------------
부서명 사원명 직급 급여
--------------------------

→  『부서』테이블과 『사원』테이블을 JOIN 했을 때의 크기
 (10 * 30Byte)  + (1000000 * 60Byte) = 300 + 60000000 = 60,000,300Byte
 
 
→ 『사원』테이블을 역정규화 수행한 후 이 테이블만 단독을 읽어올 때의 크기
  (즉, 부서 테이블에 부서명 컬럼을 사원 테이블에 추가한 경우)
  1000000 * 70Byte = 70,000,000Byte
 
 
--B 경우 → 역정규화를 수행하는 것이 바람직하다.


테이블명 : 부서                   테이블명 : 사원
  10      10    10                   10      10    10   10   10      10        10
-----------------------           ----------------------------------------- + ----
부서번호 부서명 주소              사원번호 사원명 직급 급여 입사일 부서번호   부서명
++++++++                          ++++++++                          =======
-----------------------           ----------------------------------------- + ----
      500,000개 행                             1,000,000개 행
-----------------------           ----------------------------------------- + ----

>> 업무 분석 상 조회 결과물
--------------------------
부서명 사원명 직급 급여
--------------------------

→  『부서』테이블과 『사원』테이블을 JOIN 했을 때의 크기
 (500000 * 30Byte)  + (1000000 * 60Byte) = 15,000,000 + 60,000,000 = 75,000,000Byte
 
 
→ 『사원』테이블을 역정규화 수행한 후 이 테이블만 단독을 읽어올 때의 크기
  (즉, 부서 테이블에 부서명 컬럼을 사원 테이블에 추가한 경우)
  1000000 * 70Byte = 70,000,000Byte

*/



/*
테이블명 : 사원   → 부모 테이블
-------------------------------------------------
사원번호  사원명  주민번호  입사일    급여    직급
++++++++
-------------------------------------------------
 7369     김믿음  92xxxx..  2010-xxx  xxxx    부장
 7370     박지우  01xxxx..  2020-xxx  xxxx    차장
 7371     엄서연  97xxxx..  2012-xxx  xxxx    과장  
 7372     정영훈  97xxxx..  2011-xxx  xxxx    대리
                    :
                    :
-------------------------------------------------

테이블명 : 사원가족 → 자식 테이블
---------------------------------------
주민번호    사원번호   관계      성명
++++++++    ========
---------------------------------------
9xxxxxx...    7369     아내     손가인
9xxxxxx...    7370     아내     아이유
9xxxxxx...    7371     남편     이동욱
9xxxxxx...    7372     아내     고윤정
9xxxxxx...    7373     아들     김지용
9xxxxxx...    7374     아들     박영배
                :
                :
---------------------------------------

※문제점
▶ 사원과 사원가족과 결혼시 사원가족에 중복되는 값이 들어갈 수 있다.
▶ 직급 및 관계에 있어서 정해져있는 값이아닌 사용자화가 되면 구별하기가 힘들어진다.


※착안사항
1. 예측 가능한 데이터가 입력되는 상황이라면...                → 코드화 (제1정규화)
2. 기존 컬럼을 통해 얻어낼 수 있는 데이터라면...              → 컬럼으로 구성하지 않는다!

*/
--------------------------------------------------------------------------------

/*
--※ 참고

1. 관계(relationship relation)
  - 모든 엔트리(entry)는 단일값을 가진다.
  - 각 열(column)은 유일한 이름을 가지며 순서는 무의미하다.
  - 테이블의 모든 행(row = 튜플 = tuple)은 동일하지 않으며 순서는 무의미하다.
  
2. 속성(attribute)
  - 테이블의 열(column)을 나타낸다.
  - 자료의 이름을 가진 최소 논리적 단위 : 객체의 성질 , 상태 기술
  - 일반 파일(file)의 항목(아이템 = item = 필드 = filed)에 해당한다.
  - 엔티티(entity)의 특성과 상태를 기술
  - 속성(attribute)의 이름은 모두 달라야 한다.
  
3. 튜플 = tuple = 엔티티 = entity
    - 테이블의 행(row)
    - 연관된 몇 개의 속성(attribute)으로 구성
    - 개념 정보 단위
    - 일반 파일(file)의 레코드(record)에 해당한다.
    - 튜플 변수(tuple variable)
      : 튜플(tuple)을 가르키는 변수, 모든 튜플 집합을 도메인으로 하는 변수
      
4. 도메인(domain)
    - 각 속성(attribute)이 가질 수 있도록 허용된 값들의 집합
    - 속성 명과 도메인 명이 반드시 동일할 필요는 없음
    - 모든 릴레이션에서 모든 속성들의 도메인은 원자적(atomic)이어야 함.
    - 원자적 도메인
       : 도메인의 원소가 더이상 나누어질 수 없는 단일체일 때를 나타냄.
       
       
5. 릴레이션(relation)
   - 파일 시스템에서 파일(file)과 같은 개념
   - 중복된 튜플(tuple = entity = 엔티티)을 포함하지 않는다.
     → 모두 상이함(튜플의 유일성)
   - 릴레이션 = 튜플(엔티티 = entity)의 집합, 따라서 튜플의 순서는 무의미하다.
   - 속성(attribute)간에는 순서가 없다.
   
*/

-------------------------------------------------------------------------------

--■ ■ ■ 무결성(integrity) ■ ■ ■--
/*
1. 무결성에는 개체 무결성(Entity Integrity)
              참조 무결성(Relational Integrity)
              도메인 무결성(Domain Integrity)
              
2. 개체 무결성(Entity Integrity)
   개체 무결성은 릴레이션에서 저장되는 튜플(tuple)의
   유일성을 보장하기 위한 제약조건이다.
   
3. 참조 무결성(Relational Integrity)
   참조 무결성은 릴레이션 간의 데이터 일관성을
   보장하기 위한 제약조건이다.
   
   
4. 도메인 무결성(Domain Integrity)
   도메인 무결성은 허용 가능한 값의 범위를
   지정하기 위한 제약 조건이다.
   
5. 제약조건의 종류
  
   - PRIMARY KEY(PK:P) → 부모 테이블의 참조받는 컬럼 → 기본키,식별자
     해당 컬럼의 값은 반드시 존재해야 하며, 유일해야 한다.
     (UNIQUE 와 NOT NULL 이 결합된 형태)
     
   - FOREIGN KEY(FK:F:R) → 자식 테이블의 참조하는 컬럼 → 외래키,외부키,참조키
     해당 컬럼의 값은 참조되는 테이블의 컬럼 데이터들 중 하나와
     일치하거나 NULL 을가진다.
     
   - UNIQUE(UK:U)
     테이블 내에서 해덩 컬럼의 값은 항상 유일해야 한다.
     
   - NOT NULL(NN:CK:C)
     해당 컬럼은 NULL 을 포함할 수 없다.(비어있어서는 안된다.)
     
   - CHECK(CK:C)
     해당 컬럼에서 저장 가능한 데이터의 값의 
*/




--------------------------------------------------------------------------------

---■ ■ ■ PRIMARY KEY ■ ■ ■--

-- 1. 테이블에 대한 기본 키를 생성한다.

-- 2. 테이블에서 각 행을 유일하게 식별하는 컬럼 또는 컬럼의 집합이다.
--    기본 키는 테이블 당 최대 하나만 존재한다.
--    그러나 반드시 하나의 컬럼으로만 구성되는 것은 아니다.
--    NULL 일 수 없고, 이미 테이블에 존재하고 있는 데이터를
--    다시 입력하거나 수정할 수 없도록 처리된다.
--    UNIQUE INDEX가 자동으로 생성된다.
--    (오라클이 자체적으로 만든다.)

-- 3. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명] PRIMARY KEY[(컬렴명,...)]

-- ② 테이블 레벨의 형식  --> 가급적이면 컬럼보다는 추천 / 실무에서도 많이 사용
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 PRIMARY KEY(컬럼명[, ...])

-- 4. CONSTRAINT 추가 시 CONSTRAINT명을 생략하면
-- 오라클 서버가 자동적으로 CONSTRAINT 명을 부여하게 된다.
-- 일반적으로 CONSTRAINT 명은 『테이블명_컬럼명_CONSTRAINT약어』
-- 형식으로 기술한다.


--○ PK 지정 실습(① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST1
( COL1  NUMBER(5)       PRIMARY KEY
 ,COL2  VARCHAR2(30)
);
--==>>Table TBL_TEST1이(가) 생성되었습니다.

-- 데이터 입력
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(1,'TEST');
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(2,'ABCD');
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(3,NULL);
INSERT INTO TBL_TEST1(COL1) VALUES(4);
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(2, 'ABCD');   --> 에러발생(중복된값)
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(2, 'KKKK');   --> 에러발생(중복된값)
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(5, 'ABCD');
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(NULL, NULL);        --> 에러발생(널)
INSERT INTO TBL_TEST1(COL1,COL2) VALUES(NULL, 'STUDY');     --> 에러발생(널)
INSERT INTO TBL_TEST1(COL2) VALUES('STUDY');                --> 에러발생(널)

COMMIT;
--==>> 커밋완료.

SELECT *
FROM TBL_TEST1;
--==>>
/*
1	TEST
2	ABCD
3	(null)
4	(null)
5	ABCD
*/


DESC TBL_TEST1;
--==>>
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)         → PK 제약 확인 불가
COL2          VARCHAR2(30)      
*/


--○ 제약조건 확인

SELECT *
FROM USER_CONSTRAINTS;
--==>>
/*
HR	REGION_ID_NN	         C	REGIONS	"REGION_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	REG_ID_PK	             P	REGIONS					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	REG_ID_PK		
HR	COUNTRY_ID_NN	         C	COUNTRIES	"COUNTRY_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	COUNTRY_C_ID_PK	         P	COUNTRIES					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	COUNTRY_C_ID_PK		
HR	COUNTR_REG_FK	         R	COUNTRIES		HR	REG_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	LOC_CITY_NN	             C	LOCATIONS	"CITY" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	LOC_ID_PK	             P	LOCATIONS					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	LOC_ID_PK		
HR	LOC_C_ID_FK	             R	LOCATIONS		HR	COUNTRY_C_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	DEPT_NAME_NN	         C	DEPARTMENTS	"DEPARTMENT_NAME" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	DEPT_ID_PK	             P	DEPARTMENTS					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	DEPT_ID_PK		
HR	DEPT_LOC_FK	             R	DEPARTMENTS		HR	LOC_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JOB_TITLE_NN	         C	JOBS	"JOB_TITLE" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JOB_ID_PK	             P	JOBS					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	JOB_ID_PK		
HR	EMP_LAST_NAME_NN	     C	EMPLOYEES	"LAST_NAME" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	EMP_EMAIL_NN	         C	EMPLOYEES	"EMAIL" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	EMP_HIRE_DATE_NN	     C	EMPLOYEES	"HIRE_DATE" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	EMP_JOB_NN	             C	EMPLOYEES	"JOB_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	EMP_SALARY_MIN	         C	EMPLOYEES	salary > 0				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	EMP_EMAIL_UK	         U	EMPLOYEES					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	EMP_EMAIL_UK		
HR	EMP_EMP_ID_PK	         P	EMPLOYEES					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	EMP_EMP_ID_PK		
HR	EMP_DEPT_FK	             R	EMPLOYEES		HR	DEPT_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	EMP_JOB_FK	             R	EMPLOYEES		HR	JOB_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	EMP_MANAGER_FK	         R	EMPLOYEES		HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	DEPT_MGR_FK	             R	DEPARTMENTS		HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_EMPLOYEE_NN	     C	JOB_HISTORY	"EMPLOYEE_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_START_DATE_NN	     C	JOB_HISTORY	"START_DATE" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_END_DATE_NN	     C	JOB_HISTORY	"END_DATE" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_JOB_NN	         C	JOB_HISTORY	"JOB_ID" IS NOT NULL				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_DATE_INTERVAL	     C	JOB_HISTORY	end_date > start_date				ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_EMP_ID_ST_DATE_PK	 P	JOB_HISTORY					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29	HR	JHIST_EMP_ID_ST_DATE_PK		
HR	JHIST_JOB_FK	         R	JOB_HISTORY		HR	JOB_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_EMP_FK	         R	JOB_HISTORY		HR	EMP_EMP_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	JHIST_DEPT_FK	         R	JOB_HISTORY		HR	DEPT_ID_PK	NO ACTION	ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	USER NAME			2014-05-29				
HR	SYS_C004102	             O	EMP_DETAILS_VIEW					ENABLED	NOT DEFERRABLE	IMMEDIATE	NOT VALIDATED	GENERATED NAME			2014-05-29				
HR	SYS_C007015	             P	TBL_TEST1					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	GENERATED NAME			2024-11-27	HR	SYS_C007015		
*/


SELECT *
FROM USER_CONSTRAINTS
WHERE TABLE_NAME='TBL_TEST1';
--==>>
/*
HR	SYS_C007015	P	TBL_TEST1					ENABLED	NOT DEFERRABLE	IMMEDIATE	VALIDATED	GENERATED NAME			2024-11-27	HR	SYS_C007015		
*/



--○ 제약조건이 지정된 컬럼 확인(조회)
SELECT *
FROM USER_CONS_COLUMNS;
--==>>
/*
HR	REGION_ID_NN	REGIONS	REGION_ID	
HR	REG_ID_PK	REGIONS	REGION_ID	1
HR	COUNTRY_ID_NN	COUNTRIES	COUNTRY_ID	
HR	COUNTRY_C_ID_PK	COUNTRIES	COUNTRY_ID	1
HR	COUNTR_REG_FK	COUNTRIES	REGION_ID	1
HR	LOC_ID_PK	LOCATIONS	LOCATION_ID	1
HR	LOC_CITY_NN	LOCATIONS	CITY	
HR	LOC_C_ID_FK	LOCATIONS	COUNTRY_ID	1
HR	DEPT_ID_PK	DEPARTMENTS	DEPARTMENT_ID	1
HR	DEPT_NAME_NN	DEPARTMENTS	DEPARTMENT_NAME	
HR	DEPT_MGR_FK	DEPARTMENTS	MANAGER_ID	1
HR	DEPT_LOC_FK	DEPARTMENTS	LOCATION_ID	1
HR	JOB_ID_PK	JOBS	JOB_ID	1
HR	JOB_TITLE_NN	JOBS	JOB_TITLE	
HR	EMP_EMP_ID_PK	EMPLOYEES	EMPLOYEE_ID	1
HR	EMP_LAST_NAME_NN	EMPLOYEES	LAST_NAME	
HR	EMP_EMAIL_NN	EMPLOYEES	EMAIL	
HR	EMP_EMAIL_UK	EMPLOYEES	EMAIL	1
HR	EMP_HIRE_DATE_NN	EMPLOYEES	HIRE_DATE	
HR	EMP_JOB_NN	EMPLOYEES	JOB_ID	
HR	EMP_JOB_FK	EMPLOYEES	JOB_ID	1
HR	EMP_SALARY_MIN	EMPLOYEES	SALARY	
HR	EMP_MANAGER_FK	EMPLOYEES	MANAGER_ID	1
HR	EMP_DEPT_FK	EMPLOYEES	DEPARTMENT_ID	1
HR	JHIST_EMPLOYEE_NN	JOB_HISTORY	EMPLOYEE_ID	
HR	JHIST_EMP_ID_ST_DATE_PK	JOB_HISTORY	EMPLOYEE_ID	1
HR	JHIST_EMP_FK	JOB_HISTORY	EMPLOYEE_ID	1
HR	JHIST_START_DATE_NN	JOB_HISTORY	START_DATE	
HR	JHIST_DATE_INTERVAL	JOB_HISTORY	START_DATE	
HR	JHIST_EMP_ID_ST_DATE_PK	JOB_HISTORY	START_DATE	2
HR	JHIST_END_DATE_NN	JOB_HISTORY	END_DATE	
HR	JHIST_DATE_INTERVAL	JOB_HISTORY	END_DATE	
HR	JHIST_JOB_NN	JOB_HISTORY	JOB_ID	
HR	JHIST_JOB_FK	JOB_HISTORY	JOB_ID	1
HR	JHIST_DEPT_FK	JOB_HISTORY	DEPARTMENT_ID	1
HR	SYS_C007015	TBL_TEST1	COL1	1
*/


SELECT *
FROM USER_CONS_COLUMNS
WHERE TABLE_NAME = 'TBL_TEST1';
--==>>
/*
HR	SYS_C007015	TBL_TEST1	COL1	1
*/



--○ 제약조건이 설정된 소유주,제약명,테이블명,제약종류,컬럼명 항목 조회

SELECT UC.OWNER, UC.CONSTRAINT_NAME,UC.TABLE_NAME
      ,UC.CONSTRAINT_TYPE,UCC.COLUMN_NAME
FROM USER_CONSTRAINT UC, USER_CONS_COLUMNS UCC
WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
   AND UC.TABLE_NAME='TBL_TEST1';
   
--○ PK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST2
( COL1 NUMBER(5)
 ,COL2 VARCHAR2(30)
 ,CONSTRAINT TEST2_COL1_PK PRIMARY KEY(COL1)
);
--==>>Table TBL_TEST2이(가) 생성되었습니다.


--데이터 입력
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(1,'TEST');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(2,'ABCD');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(3,NULL);
INSERT INTO TBL_TEST2(COL1) VALUES(4);
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(2,'ABCD');          --> 에러발생




































SELECT USER
FROM DUAL;
--==>>HR


--○ PK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST2
( COL1 NUMBER(5)
 ,COL2 VARCHAR2(30)
 ,CONSTRAINT TEST2_COL1_PK PRIMARY KEY(COL1)
);
--==>>Table TBL_TEST2이(가) 생성되었습니다.


--데이터 입력
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(1,'TEST');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(2,'ABCD');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(3,NULL);
INSERT INTO TBL_TEST2(COL1) VALUES(4);
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(2,'ABCD');          --> 에러발생
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(2,'ABCD');          --> 에러발생
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(5,'ABCD');
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(NULL,NULL);         --> 에러발생
INSERT INTO TBL_TEST2(COL1,COL2) VALUES(NULL,'STUDY');      --> 에러발생
INSERT INTO TBL_TEST2(COL2) VALUES('STUDY');                --> 에러발생

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TEST2;
/*
5	ABCD
1	TEST
2	ABCD
3	(null)
4	(null)
*/



--○ 제약조건이 설정된 소유주,제약명,테이블명,제약종류,컬럼명 항목 조회

SELECT A.OWNER"소유주",A.CONSTRAINT_NAME"제약명",A.TABLE_NAME"테이블명",A.CONSTRAINT_TYPE"제약종류",B.COLUMN_NAME"컴럼명"
FROM
(
SELECT *
FROM USER_CONSTRAINTS 
)A
LEFT OUTER JOIN
(
SELECT *
FROM USER_CONS_COLUMNS 
)B
ON A.CONSTRAINT_NAME = B.CONSTRAINT_NAME
WHERE A.TABLE_NAME='TBL_TEST2';
--==>> 
/*
HR	TEST2_COL1_PK	TBL_TEST2	P	COL1
*/


--○ PK 지정 실습 (③ 다중 컬럼 PK 지정 → 복합 프라이머리 키)
--테이블 생성
CREATE TABLE TBL_TEST3
( COL1  NUMBER(5)
 ,COL2  VARCHAR2(30)
 ,CONSTRAINT TEST3_COL1_COL2_PK PRIMARY KEY(COL1,COL2)
);
--==>>Table TBL_TEST3이(가) 생성되었습니다.


--(Ⅹ) 복합프라이머리 키가 아닌 단일 프라이머리키를 2개를 지정해준다는 뜻
/*
CREATE TABLE TBL_TEST3
( COL1  NUMBER(5)
 ,COL2  VARCHAR2(30)
 ,CONSTRAINT TEST3_COL1_PK PRIMARY KEY(COL1)
 ,CONSTRAINT TEST3_COL2_PK PRIMARY KEY(COL2)
);
*/

-- 데이터 입력
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(1,'TEST');
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(2,'ABCD');
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(3,NULL);            --> 에러 발생(널)
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(4);                 --> 에러 발생(널)
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(2,'ABCD');          --> 에러 발생(중복)
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(3,'ABCD');          -- 복합은 두값이 하나의 짝을 이루기 떄문에 중복에서 제외됨
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(1,'ABCD');          -- 복합은 두값이 하나의 짝을 이루기 떄문에 중복에서 제외됨
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(2,'KKKK');          -- 복합은 두값이 하나의 짝을 이루기 떄문에 중복에서 제외됨
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(5,'ABCD');          -- 복합은 두값이 하나의 짝을 이루기 떄문에 중복에서 제외됨
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(NULL,NULL);         --> 에러 발생(널)
INSERT INTO TBL_TEST3(COL1,COL2) VALUES(NULL,'STUDY');      --> 에러 발생(널)
INSERT INTO TBL_TEST3(COL2) VALUES('STUDY');                --> 에러 발생(널)

COMMIT;
--==>> 커밋 완료



--○ PK 지정 실습(④ 테이블 생성 이후 제약조건 추가 → PK 지정)
CREATE TABLE TBL_TEST4
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
);
--==>>Table TBL_TEST4이(가) 생성되었습니다.


--※ 이미 만들어져 있는 테이블에
--  부여하려는 제약조건을 위반한 데이터가 포함되어 있을 경우
--  해당 테이블에 제약조건을 추가하는 것을 불가능하다


-- 제약조건 추가
ALTER TABLE TBL_TEST4
ADD CONSTRAINT TEST4_COL1_PK PRIMARY KEY(COL1);
--==>> Table TBL_TEST4이(가) 변경되었습니다.


--※ 제약조건 확인용 전용 뷰(VIEW) 생성

CREATE OR REPLACE VIEW VIEW_CONSTCHECK
AS
SELECT UC.OWNER "OWNER"
      ,UC.CONSTRAINT_NAME "CONSTRAINT_NAME"
      ,UC.TABLE_NAME"TABLE_NAME"
      ,UC.CONSTRAINT_TYPE"CONSTRAINT_TYPE"
      ,UCC.COLUMN_NAME"COLUMN_NAME"
      ,UC.SEARCH_CONDITION"SEARCH_CONDITION"
      ,UC.DELETE_RULE"DELETE_RULE"
FROM USER_CONSTRAINTS UC JOIN USER_CONS_COLUMNS UCC
ON UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME;
--==>>View VIEW_CONSTCHECK이(가) 생성되었습니다.


--○ 생성된 뷰(VIEW)를 통한 제약조건 확인

SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST4';
--==>>
/*
HR	TEST4_COL1_PK	TBL_TEST4	P	COL1		
*/


--------------------------------------------------------------------------------

--■ ■ ■ UNIQUE(UK:U) ■ ■ ■--


--1. 테이블에서 지정한 컬럼의 데이터가 중복되지 않고
--   테이블 내에서 유일한 수 있도록 설정하는 제약조건
--   PRIMARY KEY 와 유사한 제약조건이지만,NULL 을 허용한다는 차이가 있다.
--   내부적으로 PRIMARY KEY 와 마찬가지로 UNIQUE INDEX 가 자동 생성된다.
--   하나의 테이블 내에서 UNIQUE 제약조건은 여러 번 설정하는 것이 가능하다.
--   즉, 하나의 테이블에 UNIQUE 제약조건을 여러 개 만드는 것이
--   가능하다는 것이다.


-- 2. 형식 및 구조
-- ① 컬럼 레벨의 형식
--  컬럼별 데이터타입 [CONSTRAINT CONSTRAINT명] UNIQUE

-- ② 테이블 레벨의 형식
--  컬럼별 데이터타입,
--  컬럼별 데이터타입,
--  CONSTRAINT CONSTRAINT명 UNIQUE(컬럼명[, ...])


--○ UK 지정 실습(① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST5
(COL1 NUMBER(5)     PRIMARY KEY
,COL2 VARCHAR2(30) UNIQUE
);
--==>>Table TBL_TEST5이(가) 생성되었습니다.

-- 제약조건 조회
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST5';
/*
HR	SYS_C007019	TBL_TEST5	P	COL1		
HR	SYS_C007020	TBL_TEST5	U	COL2		
*/


--데이터 입력
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(1,'TEST');
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(2,'ABCD');
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(3,NULL);
INSERT INTO TBL_TEST5(COL1) VALUES(4);                  --UNIQUE 제약조건에 NULL은 고유한 값으로 취급안한다.
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(5,'ABCD');      --에러 발생(중복)
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(5,NULL);
INSERT INTO TBL_TEST5(COL1,COL2) VALUES(6,NULL);

COMMIT;
--==>> 커밋 완료.


--○ UK 지정 실습 (① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST6
(COL1 NUMBER(5)
,COL2 VARCHAR2(30)
,CONSTRAINT TEST6_COL1_PK PRIMARY KEY(COL1)
,CONSTRAINT TEST6_COL2_UK UNIQUE(COL2)
);
--==>>Table TBL_TEST6이(가) 생성되었습니다.


-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST6';
--==>>
/*
HR	TEST6_COL1_PK	TBL_TEST6	P	COL1		
HR	TEST6_COL2_UK	TBL_TEST6	U	COL2		
*/


--○ UK 지정 실습 (③ 테이블 생성 이후 제약조건 추가)
-- 테이블 생성
CREATE TABLE TBL_TEST7
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
);
--==>> Table TBL_TEST7이(가) 생성되었습니다.

-- 제약조건 조회
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST7';
--==>> 조회 결과 없음


--제약조건 추가
ALTER TABLE TBL_TEST7
ADD (CONSTRAINT TEST7_COL1_PK PRIMARY KEY(COL1)
    ,CONSTRAINT TEST7_COL2_UK UNIQUE(COL2));
--==>> Table TBL_TEST7이(가) 변경되었습니다.


-- 제약조건 확인(조회)
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST7';
--==>> 
/*
HR	TEST7_COL1_PK	TBL_TEST7	P	COL1		
HR	TEST7_COL2_UK	TBL_TEST7	U	COL2		
*/



--- ■ ■ ■ CHECK(CK:C) ■ ■ ■ --

-- 1. 컬럼에서 허용 가능한 데이터의 범위나 조건을 지정하기 위한 제약조건.
--    컬럼에 입력되는 데이터를 검사하여 조건에 맞는 데이터만 입력될 수 있도록
--    처리하며, 수정되는 데이터 또한 검사하여 조건에 맞는 데이터로 수정되는 것만
--    하용하는 기능을 수행하게 된다.


-- 2. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명] CHECK(컬럼 조건)

-- ② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 CHECK(컬럼 조건)

-- ※ NUMBER(38)         까지...
--   CHAR(2000)         까지...
--   VARCHAR2(4000)     까지...
--   NCHAR(1000)        까지...
--   NVARCHAR2(2000)    까지...

-- COL1 NUMBER → NUMBER(38)
-- COL2 CHAR   → CHAR(1)

--○ CK 지정 실습(① 컬럼 레벨의 형식)
CREATE TABLE TBL_TEST8
(COL1 NUMBER(5)             PRIMARY KEY
,COL2 VARCHAR2(30)
,COL3 NUMBER(3)             CHECK(COL3 BETWEEN 0 AND 100)
);
--==>>Table TBL0TEST8이(가) 생성되었습니다.


-- 데이터 입력
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(1, '영식', 100);
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(2, '유진', 101);       --> 에러발생
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(3, '세진', -50);       --> 에러발생
INSERT INTO TBL_TEST8(COL1, COL2, COL3) VALUES(4, '승민', 80);


COMMIT;
--==>> 커밋 완료.


-- 데이터 확인
SELECT *
FROM TBL_TEST8;
--==>>
/*
1	영식	100
4	승민	80
*/

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST8';
--==>>
/*
SYS_C007027	TBL_TEST8	C	COL3	COL3 BETWEEN 0 AND 100	
SYS_C007028	TBL_TEST8	P	COL1		
*/



--○ CK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST9
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, COL3 NUMBER(3)
, CONSTRAINT TEST9_COL1_PK PRIMARY KEY(COL1)
, CONSTRAINT TEST9_COL3_CK CHECK(COL3 BETWEEN 0 AND 100)
);
--==>> Table TBL_TEST9이(가) 생성되었습니다.


-- 데이터 입력
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(1,'영식',100);
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(2,'유진',101);  --> 에러 발생
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(3,'세진',-50);
INSERT INTO TBL_TEST9(COL1, COL2, COL3) VALUES(4,'승민',80);

COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_TEST9;
--==>>
/*
1	영식	100
4	승민	80
*/


-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST9';
--==>>
/*
HR	TEST9_COL3_CK	TBL_TEST9	C	COL3	COL3 BETWEEN 0 AND 100	
HR	TEST9_COL1_PK	TBL_TEST9	P	COL1		
*/


--○ CK 지정 실습 (③ 테이블 생성 이후 제약조건 추가)
-- 테이브,ㄹ 생성
CREATE TABLE TBL_TEST10
(COL1 NUMBER(5)
,COL2 VARCHAR2(30)
,COL3 NUMBER(3)
);
--==>>Table TBL_TEST10이(가) 생성되었습니다.


--제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST10';
--==>> 조회결과 없음


-- 기존 테이블에 제약조건 추가
ALTER TABLE TBL_TEST10
ADD ( CONSTRAINT TEST10_COL1_PK PRIMARY KEY(COL1)
    ,CONSTRAINT TEST10_COL3_CK CHECK(COL3 BETWEEN 0 AND 100));
    --==>> Table TBL_TEST10이(가) 변경되었습니다.



--제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST10';
--==>>
/*
HR	TEST10_COL1_PK	TBL_TEST10	P	COL1		
HR	TEST10_COL3_CK	TBL_TEST10	C	COL3	COL3 BETWEEN 0 AND 100	
*/



--○ 실습을 위한 추가 테이블 생성
-- 테이블명 : TBL_TESTMEMBER
CREATE TABLE TBL_TESTMEMBER
( SID  NUMBER
, NAME VARCHAR2(30)
, SSN  CHAR(14)                 -- 입력 형태 → 'YYMMDD-NNNNNNN'
, TEL  VARCHAR2(40)
);
--==>>Table TBL_TESTMEMBER이(가) 생성되었습니다.

-- TBL_TESTMEMBER 테이블의 SSN 컬럼(주민번호) 컬럼에서
-- 데이터 입력 및 수정시 성별이  유효한 데이터만 처리될 수 있도록
-- 체크 제약조건을 추가할 수 있도록 한다.
-- → 성별 유효 데이터 → 특정 자리 1, 2, 3, 4 허용
-- 또한, SID 컬럼에는 PRIMARY KEY 제약조건을 설정할 수 있도록 한다.

--> 강사님풀이
ALTER TABLE TBL_TESTMEMBER
ADD (CONSTRAINT TESTMEMBER_SID_PK PRIMARY KEY(SID)
     ,CONSTRAINT TESTMEMBER_SSN_CK CHECK(SUBSTR(SSN,8,1) IN ('1','2','3','4')));

--> 내가한거
ALTER TABLE TBL_TESTMEMBER
ADD (CONSTRAINT TESTMEMBER_SSN_CK CHECK(SUBSTR(SSN,8,1) BETWEEN 1 AND 4));



SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TESTMEMBER';




--데이터 입력 테스트
INSERT INTO TBL_TESTMEMBER(SID,NAME,SSN,TEL)
VALUES(1, '김믿음','921028-1234567','010-1111-1111');
--==>>1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_TESTMEMBER(SID,NAME,SSN,TEL)
VALUES(2, '박지우','011105-3234566','010-2222-2222');
--==>>1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_TESTMEMBER(SID,NAME,SSN,TEL)
VALUES(3, '엄서연','971126-2234567','010-3333-3333');
--==>>1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_TESTMEMBER(SID,NAME,SSN,TEL)
VALUES(4, '정승민','000211-4234567','010-4444-4444');
--==>>1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_TESTMEMBER(SID,NAME,SSN,TEL)
VALUES(5, '정영훈','970906-5234567','010-5555-5555');
--==>> 에러발생
/*
heck constraint (HR.TESTMEMBER_SSN_CK) violated
*/

COMMIT;

SELECT *
FROM TBL_TESTMEMBER;
/*
1	김믿음	921028-1234567	010-1111-1111
2	박지우	011105-3234566	010-2222-2222
3	엄서연	971126-2234567	010-3333-3333
4	정승민	000211-4234567	010-4444-4444
*/

--제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TESTMEMBER';
--==>>
/*
HR	TESTMEMBER_SID_PK	TBL_TESTMEMBER	P	SID		
HR	TESTMEMBER_SSN_CK	TBL_TESTMEMBER	C	SSN	SUBSTR(SSN,8,1) BETWEEN 1 AND 4	
*/



-- ■ ■ ■ FOREIGN KEY(FK:F:R) ■ ■ ■--

-- 1. 참조 키 또는 외래 키(FK)는
--    두 테이블의 데이터 간 연결을 설정하고
--    강제 적용시키는데 사용되는 열이다
--    한 테이블의 기본 키 값이 있는 열을
--    다른 테이블에 추가하면 테이블 간 연결을 설정할 수 있다.
--    이 때, 두 번째 테이블에 추가되는 열이 외래 키가 된다.

-- 2. 부모 테이블(참조받는 컬럼이 포함된 테이블)이 먼저 생성된 후
--    자식 테이블(참조하는 컬럼이 포함된 테이블)이 생성되어야 한다.
--    이 때, 자식 테이블 FOREIGN KEY 제약조건이 설정된다.

-- 3. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명]
--                   REFERENCES 참조테이블명(참조컬럼명)
--                   [ON DELETE CASCADE | ON DELETE SET NULL]

-- ② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 FOREIGN KEY(컬렴명)
--            REFERENCES 참조테이블명(참조컬럼명)
--            [ON DELETE CASCADE | ON DELETE SET NULL]

-- ※ FOREIGN KEY 제약조건을 설정하는 실습을 진행하기 위해서는
--  독립적인 하나의 테이블을 생성하여 처리하는 것이 아니라
--  부모테이블 생성 작업을 먼저 수행해야 한다.
--  그리고 이 때, 부모 테이블에는 반드시 PK 또는 UK 제약조건이
--  설정된 컬럼이 존재해야 한다.


-- 부모 테이블 생성
-- 테이블명 : TBL_JOBS
CREATE TABLE TBL_JOBS
( JIKWI_ID      NUMBER
, JIKWI_NAME    VARCHAR2(30)
, CONSTRAINT JOBS_ID_PK PRIMARY KEY(JIKWI_ID)
);
--==>>Table TBL_JOBS이(가) 생성되었습니다.


-- 생성된 부모 테이블에 데이터 입력
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(1, '사원');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(2, '대리');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(3, '과장');
INSERT INTO TBL_JOBS(JIKWI_ID, JIKWI_NAME) VALUES(4, '부장');
--==>> 1 행 이(가) 삽입되었습니다. * 4

SELECT *
FROM TBL_JOBS;
--==>>
/*
1	사원
2	대리
3	과장
4	부장
*/

COMMIT;
--==>> 커밋 완료.

DROP TABLE TBL_EMP1;
--○ FK 지정 실습(① 컬럼 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_EMP1
( SID           NUMBER          PRIMARY KEY
, NAME          VARCHAR2(30)
, JIKWI_ID      NUMBER          REFERENCES TBL_JOBS(JIKWI_ID)
);
--==>> Table TBL_EMP1이(가) 생성되었습니다.

-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_EMP1';
--==>>
/*
HR	SYS_C007040	TBL_EMP1	P	SID		
HR	SYS_C007041	TBL_EMP1	R	JIKWI_ID		NO ACTION
*/

-- 자식 테이블에 데이터 입력
INSERT INTO TBL_EMP1(SID,NAME,JIKWI_ID) VALUES(1,'임성산',1);
INSERT INTO TBL_EMP1(SID,NAME,JIKWI_ID) VALUES(2,'박제훈',2);
INSERT INTO TBL_EMP1(SID,NAME,JIKWI_ID) VALUES(3,'공찬민',3);
INSERT INTO TBL_EMP1(SID,NAME,JIKWI_ID) VALUES(4,'안예지',4);
INSERT INTO TBL_EMP1(SID,NAME,JIKWI_ID) VALUES(5,'문제정',5);  --> 에러 발생
INSERT INTO TBL_EMP1(SID,NAME,JIKWI_ID) VALUES(5,'문제정',1);
INSERT INTO TBL_EMP1(SID,NAME) VALUES(6,'김민승');
INSERT INTO TBL_EMP1(SID,NAME,JIKWI_ID) VALUES(7,'윤영식',NULL);

SELECT *
FROM TBL_EMP1;
--==>>
/*
1	임성산	1
2	박제훈	2
3	공찬민	3
4	안예지	4
5	문제정	1
6	김민승	
7	윤영식	
*/

COMMIT;
--==>> 커밋 완료.


--○ FK 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_EMP2
( SID         NUMBER
, NAME        VARCHAR2(30)
, JIKWI_ID    NUMBER
, CONSTRAINT  EMP2_SID_PK PRIMARY KEY(SID)
, CONSTRAINT  EMP2_JIKWI_ID_FK FOREIGN KEY(JIKWI_ID)
              REFERENCES TBL_JOBS(JIKWI_ID)
);
--==>> Table TBL_EMP2이(가) 생성되었습니다.


-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_EMP2';
--==>>
/*
HR	EMP2_SID_PK	TBL_EMP2	P	SID		
HR	EMP2_JIKWI_ID_FK	TBL_EMP2	R	JIKWI_ID		NO ACTION
*/


--○ FK 지정 실습(③ 테이블 생성 이후 제약조건 추가)
-- 테이블 생성
CREATE TABLE TBL_EMP3
(SID        NUMBER
,NAME       VARCHAR2(30)
,JIKWI_ID   NUMBER
);
--==>> Table TBL_EMP3이(가) 생성되었습니다.

-- 제약조건 확인
SELECT 8
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_EMP3';
--==>> 조회결과 없음

-- 제약조건 추가

ALTER TABLE TBL_EMP3
ADD ( CONSTRAINT EMP3_SID_PK PRIMARY KEY(SID)
    , CONSTRAINT EMP3_JIKWI_ID_FK FOREIGN KEY(JIKWI_ID)
                REFERENCES TBL_JOBS(JIKWI_ID));
--==>> Table TBL_EMP3이(가) 변경되었습니다.



    
-- 4. FOREIGN KEY 생성 시 주의사항
--   - 참조하고자 하는 부모 테이블을 먼저 생성해야 한다.
--   - 참조하고자 하는 컬럼이 PRIMARY KEY 나 UNIQUE 제약조건이 있어야한다.
--   - 테이블 간에 PRIMARY KEY 와 FORIGN KEY 가 정의되어 있으면
--     PRIMARY KEY 제약조건이 설정된 컬럼의 데이터 삭제 시
--     FOREIGN KEY 컬럼에 그 값이 입력되어 있는 경우 삭제되지 않는다.
--     (단, FK 설정 과정에서 『ON DELETE CASCADE』나
--     『ON DELETE SET NULL』옵션을 사용하여 설정한 경우에는 삭제가 가능하다.)
--   - 부모 테이블을 제거하기 위해서는 자식 테이블을 먼저 제거해야 한다.


-- 부모 테이블
SELECT *
FROM TBL_JOBS;
--==>>
/*
1	사원
2	대리
3	과장
4	부장
*/


-- 자식 테이블
SELECT *
FROM TBL_EMP1;
--==>>
/*
1	임성산	1
2	박제훈	2
3	공찬민	3
4	안예지	4
5	문제정	1
6	김민승	
7	윤영식	
*/


-- 안예지 부장의 직위를 사원으로 변경

UPDATE TBL_EMP1
SET JIKWI_ID=1
WHERE SID = 4;
--==>> 1 행 이(가) 업데이트되었습니다.


--확인
SELECT *
FROM TBL_EMP1;
--==>>
/*
1	임성산	1
2	박제훈	2
3	공찬민	3
4	안예지	1
5	문제정	1
6	김민승	
7	윤영식	
*/


--커밋
COMMIT;
--==>> 커밋 완료.

-- 부모 테이블(TBL_JOBS)의 부장 데이터를 참조하고 있는
-- 자식 테이블(TBL_EMP1)의 데이터가 존재하지 않는 상황

-- 이와 같은 상황에서 부모 테이블(TBL-JOBS)의
-- 부장 데이터 삭제
DELETE 
FROM TBL_JOBS
WHERE JIKWI_ID=4;
--==>> 1 행 이(가) 삭제되었습니다.

-- 확인
SELECT *
FROM TBL_JOBS;
/*
1	사원
2	대리
3	과장
*/

-- 커밋
COMMIT;
--==>> 커밋 완료.

SELECT *
FROM TBL_EMP1;
/*
1	임성산	1
2	박제훈	2
3	공찬민	3
4	안예지	1
5	문제정	1
6	김민승	
7	윤영식	
*/


-- 부모 테이블(TBL_JOBS)의 사원 데이터를 참조하고 있는
-- 자식 테이블(TBL_EMP1)의 데이터가 3건 존재하는 상황.

-- 이와 같은 상황에서 부모 테이블(TBL_JOBS)의
-- 사원 데이터 삭제

DELETE
FROM TBL_JOBS
WHERE JIKWI_ID=1;
--==>> 에러 발생
/*
integrity constraint (HR.SYS_C007043) violated - child record found
*/

-- 부모 테이블(TBL_JOBS) 제거
DROP TABLE TBL_JOBS;
/*
ORA-02449: unique/primary keys in table referenced by foreign keys
02449. 00000 -  "unique/primary keys in table referenced by foreign keys"
*Cause:    An attempt was made to drop a table with unique or
           primary keys referenced by foreign keys in another table.
*Action:   Before performing the above operations the table, drop the
           foreign key constraints in other tables. You can see what
           constraints are referencing a table by issuing the following
           command:
           SELECT * FROM USER_CONSTRAINTS WHERE TABLE_NAME = "tabnam";

*/


--※ 참조하고 있는 자식 테이블의 레코드가 존재하는 상황임에도 불구하고
--  부모 테이블의 데이터를 자유롭게 삭제하기 위해서는
--  『ON DELETE CASCADE』옵션 지정이 필요하다.


-- TBL_EMP1 테이블(자식 테이블) 에서 FK 제약조건을 제거 한 후
-- CASCADE 옵션을 포함한 상태로 다시 FK 제약조건을 설정한다.


-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_EMP1';
/*
HR	SYS_C007042	TBL_EMP1	P	SID		
HR	SYS_C007043	TBL_EMP1	R	JIKWI_ID		NO ACTION
*/

-- 제약조건 제거
ALTER TABLE TBL_EMP1
DROP CONSTRAINT SYS_C007043;
--==>> Table TBL_EMP1이(가) 변경되었습니다.


-- 제약조건 제거 이후 다시 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_EMP1';
--==>>
/*
HR	SYS_C007042	TBL_EMP1	P	SID		
*/


-- 『ON DELETE CASCADE』옵션이 포함된 내용으로 재약조건 다시 지정
ALTER TABLE TBL_EMP1
ADD CONSTRAINT EMP1_JIKWIID_FK FOREIGN KEY(JIKWI_ID)
                REFERENCES TBL_JOBS(JIKWI_ID)
                ON DELETE CASCADE;
--==>> Table TBL_EMP1이(가) 변경되었습니다.


-- 제약조건 다시 지정한  이후 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_EMP1';
/*
HR	SYS_C007042	TBL_EMP1	P	SID		
HR	EMP1_JIKWIID_FK	TBL_EMP1	R	JIKWI_ID		CASCADE
*/

--※ CASCADE 옵션을 지정한 후에는
--  참조받고 있는 부모 테이블의 데이터를
--  언제든지 자유롭게 삭제하는 것이 가능하다.
--  단... ... ... ... 부모 테이블의 데이터가 삭제될 경우
--  이를 참조하는 자식 테이블의 데이터도 모~~~두 함께 삭제된다.
--  CHECK!!

--부모 테이블
SELECT *
FROM TBL_JOBS;
--==>>
/*
SELECT *
FROM TBL_JOBS;
*/

--자식 테이블
SELECT *
FROM TBL_EMP1;
/*
1	임성산	1       ←
2	박제훈	2
3	공찬민	3
4	안예지	1       ←
5	문제정	1       ←
6	김민승	
7	윤영식	
*/


-- TBL_JOBS(부모 테이블)의 사원 데이터 삭제
DELETE
FROM TBL_JOBS
WHERE JIKWI_ID=1;
--==>> 1 행 이(가) 삭제되었습니다.

-- 부모 테이블
SELECT *
FROM TBL_JOBS;
--==>>
/*
2	대리
3	과장
*/

-- 자식 테이블
SELECT *
FROM TBL_EMP1;
/*
2	박제훈	2
3	공찬민	3
6	김민승	
7	윤영식	
*/

--------------------------------------------------------------------------------
--■ ■ ■ NOT NULL(NN:CK:C)■ ■ ■--

--1. 테이블에서 지정한 컬럼의 데이터가 NULL 인 상태를 갖지 못하도록 하는 제약조건.

--2. 형식 및 구조
-- ① 컬럼 레벨의 형식
-- 컬럼명 데이터타입 [CONSTRAINT CONSTRAINT명] NOT NULL

-- ② 테이블 레벨의 형식
-- 컬럼명 데이터타입,
-- 컬럼명 데이터타입,
-- CONSTRAINT CONSTRAINT명 CHECK(컬럼명 IS NOT NULL)

-- 3. 기존에 생성되어 있는 테이블에 NOT NULL 제약조건을 추가할 경우
--   ADD 보다 MODIFY 절이 더 많이 사용된다.

-- ALTER TABLE 테이블명
-- MODIFY 컬럼명 데이터타입 NOT NULL;

-- 4.기존 테이블에 데이터가 이미 들어있지 않은 컬럼(→ NULL 인 상태)을
--  NOT NULL 제약조건을 갖게끔 수정하는 경우에는 에러 발생한다.

--○ NOT NULL 지정 실습(① 컬럼 레벨의 형식)
--  테이블 생성
CREATE TABLE TBL_TEST11
( COL1      NUMBER(5)           PRIMARY KEY
, COL2      VARCHAR2(30)        NOT NULL
);
--==>>Table TBL_TEST11이(가) 생성되었습니다.


-- 데이터 입력
INSERT INTO TBL_TEST11(COL1,COL2) VALUES(1,'TEST');
INSERT INTO TBL_TEST11(COL1,COL2) VALUES(2,'ABCD');
INSERT INTO TBL_TEST11(COL1,COL2) VALUES(3,'NULL');
INSERT INTO TBL_TEST11(COL1,COL2) VALUES(4,NULL);  --> 에러 발생
INSERT INTO TBL_TEST11(COL1) VALUES(4);            --> 에러 발생


SELECT *
FROM TBL_TEST11;
/*
1	TEST
2	ABCD
3	NULL        → 문자 타입
*/

COMMIT;
--==>> 커밋 완료.


-- 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST11';
/*
HR	SYS_C007049	TBL_TEST11	C	COL2	"COL2" IS NOT NULL	
HR	SYS_C007050	TBL_TEST11	P	COL1		
*/


--○ NOT NULL 지정 실습(② 테이블 레벨의 형식)
-- 테이블 생성
CREATE TABLE TBL_TEST12
(COL1 NUMBER(5)
,COL2 VARCHAR(30)
,CONSTRAINT TEST12_COL1_PK PRIMARY KEY(COL1)
,CONSTRAINT TEST12_COL2_NN CHECK(COL2 IS NOT NULL)
);

--==>>Table TBL_TEST12이(가) 생성되었습니다.


--제약조건 확인

SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME = 'TBL_TEST12';
/*
HR	TEST12_COL2_NN	TBL_TEST12	C	COL2	COL2 IS NOT NULL	
HR	TEST12_COL1_PK	TBL_TEST12	P	COL1		
*/



--○ NOT NULL 지정 실습(③ 테이블 생성 이후 제약조건 추가)
-- 테이블 생성
CREATE TABLE TBL_TEST13
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
);
--==>> Table TBL_TEST13이(가) 생성되었습니다.

--제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST13';
--==>> 조회결과 없음


--제약조건 추가
ALTER TABLE TBL_TEST13
ADD (CONSTRAINT TEST13_COL1_PK PRIMARY KEY(COL1)
    ,CONSTRAINT TEST13_COL2_NN CHECK(COL2 IS NOT NULL));
--==>>Table TBL_TEST13이(가) 변경되었습니다.


--추가 이후 다시 제약조건 확인
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='TBL_TEST13';
/*
HR	TEST13_COL1_PK	TBL_TEST13	P	COL1		
HR	TEST13_COL2_NN	TBL_TEST13	C	COL2	COL2 IS NOT NULL	
*/


--※ NOT NULL 제약조건만 추가하는 경우
--  다음과 같은 형태로 처리하는 것도 가능하다.
--  테이블 생성
CREATE TABLE TBL_TEST14
( COL1 NUMBER(5)
, COL2 VARCHAR2(30)
, CONSTRAINT TEST14_COL1_PK PRIMARY KEY(COL1)
);
--==>>Table TBL_TEST14이(가) 생성되었습니다.


-- NOT NULL 제약조건 추가

ALTER TABLE TBL_TEST14
MODIFY COL2 NOT NULL;
--==>>Table TBL_TEST14이(가) 변경되었습니다.

--※ 컬럼 레벨에서 NOT NULL 제약조건을 지정한 ㅌ ㅔ이블
DESC TBL_TEST11;
--==>>
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2 NOT NULL VARCHAR2(30) 
*/
--> DESC 명령을 통해 COL2 컬럼이 NOT NULL 인 상태가 확인되는 상황.


--※ 테이블 레벨에서 NOT NULL 제약조건을 지정한 테이블
DESC TBL_TEST12;
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2          VARCHAR2(30) 
*/
--> DESC 명령을 통해 COL2 컬럼이 NOT NULL 인 상태가 확인되지 않는 상황


-- ※ 테이블 생성 이후 ADD 를 통해 NOT NULL 제약조건을 지정한 테이블
DESC TBL_TEST13;
--==>>
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2          VARCHAR2(30) 
*/
--> DESC 명령을 통해 COL2 컬럼이 NOT NULL 인 상태가 확인되징 않는 상황.

--※ 테이블 생성 이후 MODIFY 를 통해 NOT NULL 제약조건을 지정한 테이블
DESC TBL_TEST14;
--==>>
/*
이름   널?       유형           
---- -------- ------------ 
COL1 NOT NULL NUMBER(5)    
COL2 NOT NULL VARCHAR2(30) 
*/
--> DESC 명령을 통해 COL2 컬럼이 NOT NULL 인 상태가 확인되는 상황




--■ ■ ■ DEFAULT 표현식 ■ ■ ■--

-- 1. INSERT 와 UPDATE 구문에서
--    사용자가 전달하는 특정 값이 아닌
--    기본적으로 설정된 값을 입력하도록 처리할 수 있다.

-- 2. 형식 및 구조
-- 컬럼명 데이터타입 DEFAULT 기본값

-- 3. INSERT 명령 시 해당 컬럼에 입력될 값을 할당하지 않거나
--  DEFAULT 키워드를 활용하여 기본적으로 설정된 값을 입력하도록 할 수 있다.

-- 4. DEFAULT 키워드와 다른 제약(NOT NULL 등 ) 표기가 같이 오는 경우
--    DEFAULT 키워드를 먼저 표기(작성)할 것을 권장한다.


--○  DEFAULT 표현식 실습
-- 테이블 생성
CREATE TABLE TBL_BOARD                             -- 게시판 테이블 생성
( SID               NUMBER        PRIMARY KEY      -- 게시물 번호 → 식별자
, NAME              VARCHAR2(30)                   -- 게시물 작성자
, CONTENTS          VARCHAR2(2000)                 -- 게시물 내용
, WRITEDAY          DATE         DEFAULT SYSDATE   -- 게시물 작성일(현재 날짜시간 자동 입력)
, COMMENTS          NUMBER       DEFAULT 0         -- 게시물 댓글 갯수 (기본값 0)
, COUNTS            NUMBER       DEFAULT 0         -- 게시물 조회수(기본값 0)
);
--==>> Table TBL_BOARD이(가) 생성되었습니다.

--※ SID 를 자동 증가 값으로 운영하려면 시퀸스 객체가 필요하다
--  자동으로 입력되는 컬럼은 사용자가 입력해야 하는 항목에서
--  제외시킬 수 있다.

-- 시퀸스 생성
CREATE SEQUENCE SEQ_BOARD
NOCACHE;
--==>>Sequence SEQ_BOARD이(가) 생성되었습니다.

--  세션 설정 변경
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>> Session이(가) 변경되었습니다.


-- 게시물 작성
INSERT INTO TBL_BOARD(SID, NAME, CONTENTS, WRITEDAY, COMMENTS, COUNTS)
VALUES(SEQ_BOARD.NEXTVAL, '안석창', '오라클에서 DEFAULT 표현식을 실습중입니다.'
     , TO_DATE('2024-11-28 15:04:20', 'YYYY-MM-DD HH24:MI:SS'), 0, 0);
--==>> 1행 이(가) 삽입되었습니다.

INSERT INTO TBL_BOARD(SID,NAME,CONTENTS,WRITEDAY,COMMENTS,COUNTS)
VALUES(SEQ_BOARD.NEXTVAL,'이은솔','계속 실습중입니다.',SYSDATE, 0,0);


INSERT INTO TBL_BOARD(SID,NAME,CONTENTS,WRITEDAY,COMMENTS,COUNTS)
VALUES(SEQ_BOARD.NEXTVAL,'정승민','힘껏 실습중입니다.',DEFAULT, DEFAULT,DEFAULT);

INSERT INTO TBL_BOARD(SID,NAME,CONTENTS)
VALUES(SEQ_BOARD.NEXTVAL,'박세진','테스트 마무리중입니다.');

SELECT *
FROM TBL_BOARD;
/*
2	이은솔	계속 실습중입니다.	                        2024-11-28 15:08:49	0	0
3	정승민	힘껏 실습중입니다.	                        2024-11-28 15:08:51	0	0
4	박세진	테스트 마무리중입니다.	                    2024-11-28 15:09:07	0	0
6	안석창	오라클에서 DEFAULT 표현식을 실습중입니다.	2024-11-28 15:04:20	0	0
*/


COMMIT;
--==>> 커밋 완료.


--○ DEFAULT 표현식 확인(조회)
SELECT *
FROM USER_TAB_COLUMNS
WHERE TABLE_NAME='TBL_BOARD';
--==>>
/*
TBL_BOARD	SID	        NUMBER			        22			N	1													NO	NO		0		NO	YES	NONE
TBL_BOARD	NAME	    VARCHAR2			    30			Y	2											CHAR_CS	30	NO	NO		30	B	NO	YES	NONE
TBL_BOARD	CONTENTS	VARCHAR2			    2000			Y	3											CHAR_CS	2000	NO	NO		2000	B	NO	YES	NONE
TBL_BOARD	WRITEDAY	DATE			        7			Y	4	68	"SYSDATE"   -- 게시물 작성일(현재 날짜시간 자동 입력)
											NO	NO		0		NO	YES	NONE
TBL_BOARD	COMMENTS	NUMBER			        22			Y	5	51	"0"         -- 게시물 댓글 갯수 (기본값 0)
											NO	NO		0		NO	YES	NONE
TBL_BOARD	COUNTS	    NUMBER			        22			Y	6	46	"0"         -- 게시물 조회수(기본값 0)
											NO	NO		0		NO	YES	NONE
*/

SELECT TABLE_NAME, COLUMN_NAME, DATA_TYPE, DATA_DEFAULT
FROM USER_TAB_COLUMNS
WHERE TABLE_NAME='TBL_BOARD';
/*
TBL_BOARD	SID	NUMBER	
TBL_BOARD	NAME	VARCHAR2	
TBL_BOARD	CONTENTS	VARCHAR2	
TBL_BOARD	WRITEDAY	DATE	"SYSDATE   -- 게시물 작성일(현재 날짜시간 자동 입력)
"
TBL_BOARD	COMMENTS	NUMBER	"0         -- 게시물 댓글 갯수 (기본값 0)
"
TBL_BOARD	COUNTS	NUMBER	"0         -- 게시물 조회수(기본값 0)
"
*/




--○ 테이블 생성 이후 DEFAULT 표현식 추가 / 변경

ALTER TABLE 테이블명
MODIFY 컬럼명 [자료형] DEFAULT 기본값;


--○ 생성된 FEFAULT 표현식 제거(삭제)
ALTER TABLE 테이블명
MODIFY 컬럼명 [자료형] DEFAULT NULL;



SELECT USER
FROM DUAL;
--==>> HR
SELECT *
FROM TAB;

-- ■ ■ ■ 팀별 실습 과제 ■ ■ ■ --

-- HR 샘플 스키마 ERD 를 이용한 테이블 재구성

-- 팀별로... HR 스키마에 있는 기본 테이블(7개)
-- COUNTRIES / DEPARTMENTS / EMPLYEES / JOBS / JOB_HISTORY / LOCATIONS / REGIONS
-- 을 똑같이 새로 구성한다.


-- 단, 생성하는 테이블 이름은 『테이블명+팀번호』
-- COUNTRIES3 / DEPARTMENTS3 / EMPLYEES3 / JOBS3 / JOB_HISTORY3 / LOCATIONS3 / REGIONS3
-- 과 같이 구성한다.


-- 1. 기존 테이블의 정보 수집
-- 2. 테이블 생성(컬럼 이름, 자료형, DEFAULT 표현식,NOT NULL 등...)
--    제약조건 설정(PK, UK, FK, CK, ... NN)
-- 3. 작성 후 데이터 입력
-- 4. 제출 항목
--    - 20241128_02_hr_팀별실습과제3.sql
--    - GNRL_3.sql
-- 5. 제출 기한
--    - 오후 5:00에 결정

SELECT *
FROM COUNTRIES; --> REGIONS /           REGION_ID
SELECT *
FROM DEPARTMENTS;  --> EMPLOYEES    / MANAGER_ID
SELECT *
FROM EMPLOYEES;     --> DEPARTMENTS     /DEPARTMNET_ID
SELECT *
FROM JOBS;          --> EMPLOYEES   / JOB_ID
SELECT *
FROM JOB_HISTORY;       --> EMPLYEES    / EMPLOYEE_ID , DEPARTMENT_ID
SELECT *
FROM LOCATIONS;     --> COUNTRIES      /COUNTRY_ID
SELECT *
FROM REGIONS; --> COUNTRIES         REGION_ID


DESC EMPLOYEES;

SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='EMPLOYEES';


SELECT *
FROM EMPLOYEES;


SELECT *
FROM TAB;

SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='JOBS3';



SELECT *
FROM TAB;

CREATE TABLE COUNTRIES3
( COUNTRY_ID        CHAR(2)
, COUNTRY_NAME      VARCHAR2(40)
, REGION_ID         NUMBER
, CONSTRAINT COUNTRIES3_COUNTRY_C_ID_PK PRIMARY KEY(COUNTRY_ID)
, CONSTRAINT COUNTRIES3_COUNTRY_ID_CK CHECK(COUNTRY_ID IS NOT NULL)
);



SELECT *
FROM COUNTRIES;
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='COUNTRIES';



CREATE TABLE DEPARTMENTS3
( DEPARTMENT_ID     NUMBER(4)     
, DEPARTMENT_NAME   VARCHAR2(30)    
, MANAGER_ID        NUMBER(6)
, LOCATION_ID       NUMBER(4)
 CONSTRAINT DEPARTMENTS3_DEPT_ID_PK PRIMARY KEY(DEPARTMENT_ID)
,CONSTRAINT DEPARTMENTS3_DEPT_NAME_NN CHECK(DEPARTMNET_NAME IS NOT NULL)
);


SELECT *
FROM DEPARTMENTS;
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='DEPARTMENTS';





CREATE TABLE EMPLOYEES3
( EMPLOYEE_ID       NUMBER(6)
, FIRST_NAME        VARCHAR2(20)
, LAST_NAME         VARCHAR2(25)
, EMAIL             VARCHAR2(25)
, PHONE_NUMBER      VARCHAR2(20)
, HIRE_DATE         DATE
, JOB_ID            VARCHAR2(10)
, SALARY            NUMBER(8,2)
, COMMISSION_PCT    NUMBER(2,2)
, MANAGER_ID        NUMBER(6)
, DEPARTMENT_ID     NUMBER(4)
, CONSTRAINT EMP_LAST_NAME_NN CHAR(LAST_NAME IS NOT NULL)
, CONSTRAINT EMP_EMAIL_NN CHAR(EMAIL IS NOT NULL)
, CONSTRAINT EMP_HIRE_DATE_NN CHAR(HIRE_DATE IS NOT NULL)
, CONSTRAINT EMP_JOB_NN CHAR(JOB_ID IS NOT NULL)
, CONSTRAINT EMP_SALARY_MIN CHAR(SALARY > 0)
, CONSTRAINT EMP_EMAIL_UK UNIQUE(EMAIL)
, CONSTRAINT EMP_EMP_ID_PK PRIMARY KEY(EMPLOYEE_ID)
, CONSTRAINT EMP_DEPT_FK REFERENCES DEPARTMENTS(DEPARTMENT_ID)
, CONSTRAINT EMP_JOB_FK REFERENCES JOBS(JOB_ID)
, CONSTRAINT EMP_MANAGER_FK REFERENCES EMPLOYEES(MANAGER_ID)
);

SELECT *
FROM EMPLOYEES;
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='EMPLOYEES';




CREATE TABLE JOBS3
( JOB_ID            VARCHAR2(10)
, JOB_TITLE         VARCHAR2(35)
, MIN_SALARY        NUMBER(6)
, MAX_SALARY        NUMBER(6)
, CONSTRAINT JOB_TITLE_NN CHECK(JOB_TITLE IS NOT NULL)
, CONSTRAINT JOB_ID_PK PRIMARY KEY(JOB_ID) 
);




SELECT *
FROM JOBS;
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='JOBS';




CREATE TABLE JOB_HISTORY3
( EMPLOYEE_ID       NUMBER(6)
, START_DATE        DATE
, END_DATE          DATE
, JOB_ID            VARCHAR2(10)
, DEPARTMENT_ID     NUMBER(4)
, CONSTRAINT JHIST_EMPLOYEE_NN CHECK(EMPLOYEE_ID IS NOT NULL)
, CONSTRAINT JHIST_START_DATE_NN CHECK(START_DATE IS NOT NULL)
, CONSTRAINT JHIST_END_DATE_NN CHECK(END_DATE IS NOT NULL)
, CONSTRAINT JHIST_JOB_NN CHECK(JOB_ID IS NOT NULL)
, CONSTRAINT JHIST_DATE_INTERVAL CHECK(START_DATE END_DATE > START_DATE)
, CONSTRAINT JHIST_DATE_INTERVAL CHECK(END_DATE END_DATE > START_DATE)
, CONSTRAINT JHIST_EMP_ID_ST_DATE_PK PRIMARY KEY(EMPLOYEE_ID)
, CONSTRAINT JHIST_EMP_ID_ST_DATE_PK PRIMARY KEY(START_DATE)
, CONSTRAINT JHIST_JOB_FK REFERENCES JOBS(JOB_ID)
, CONSTRAINT JHIST_EMP_FK REFERENCES EMPLOYEES(EMPLOYEE_ID)
, CONSTRAINT JHIST_DEPT_FK REFERENCES DEPARTMENTS(DEPARTMENT_ID)
);


SELECT *
FROM JOBS;
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='JOB_HISTORY';





CREATE TABLE LOCATIONS3
( LOCATION_ID       NUMBER(4)
, STREET_ADDRESS    VARCHAR2(40)
, POSTAL_CODE       VARCHAR2(12)
, CITY              VARCHAR2(30)
, STATE_PROVINCE    VARCHAR2(25)
, COUNTRY_ID        CHAR(2)
);


SELECT *
FROM LOCATIONS;
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='LOCATIONS';




CREATE TABLE REGIONS3
( REGION_ID         NUMBER
, REGION_NAME       VARCHAR2(25)
);


SELECT *
FROM JOBS;
SELECT *
FROM VIEW_CONSTCHECK
WHERE TABLE_NAME='REGIONS';


SELECT USER
FROM DUAL;
--==>> SCOTT


--■ ■ ■ UPDATE ■ ■ ■ --

--1. 테이블에서 기존 데이터를 변경하는 구문.

--2. 형식 및 구조
/*
UPDATE 테이블명
SET 컬럼명=변경할값[,   컬럼명=변경할값, ...]
[WHERE 조건절]
*/


SELECT *
FROM TBL_SAWON;

--○ TBL_SAWON 테이블에서 사원번호 1003번 사원의
--  주민번호를 『8709062234567』로 수정한다.

UPDATE TBL_SAWON
SET JUBUN = '8709062234567'
WHERE SANO = 1003;
--==>>
/*
            :
            :
1003	정영훈	8709062234567	2005-08-16	5000
            :
            :
*/
-- 실행 후 COMMIT 또는 ROLLBACK 을 반드시 선택적으로 실행
COMMIT;
--==>>커밋 완료.

--○ TBL_SAWON 테이블에서 1005번 사원의 입사일과 급여를
--  각각 2018-02-22, 7700 으로 변경한다.


UPDATE TBL_SAWON
SET HIREDATE = TO_DATE('2018-02-22', 'YYYY-MM-DD') , SAL = 7700
WHERE SANO = 1005;
--==>>1 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_SAWON;
/*
                    :
                    :
1005	이은솔	9104282234567	2018-02-22	7700
                    :
                    :
*/


COMMIT;
--==>>커밋 완료.


--○ TBL_INSA 테이블 복사(데이터만_
CREATE TABLE TBL_INSABACKUP
AS
SELECT *
FROM TBL_INSA;
--==>> Table TBL_INSABACKUP이(가) 생성되었습니다.



--○ TBL_INSABACKUP 테이블에서 
--  직위가 과장과 부장만 수당 10% 인상!

SELECT *
FROM TBL_INSABACKUP;



UPDATE TBL_INSABACKUP
SET SUDANG = SUDANG + SUDANG * 0.1
WHERE JIKWI IN ('과장','부장');

SELECT NAME"사원명", JIKWI"직위",SUDANG"수당"
FROM TBL_INSABACKUP
WHERE JIKWI IN ('과장','부장');
/*
홍길동	부장	22000
이순애	부장	17600
이기자	과장	16500
김종서	부장	14300
이상헌	과장	16500
박문수	과장	18150
김인수	부장	18700
김영길	과장	18700
정정해	과장	13640
지재환	부장	17600
최석규	과장	20570
문길수	과장	16500
허경운	부장	16500
권영미	과장	11440
이미경	부장	17600
*/

COMMIT;
--==>>커밋 완료.


--○ TBL_INSABACKUP 테이블에서 전화번호가 016,017,018,019 로 시작하는
--  전화번호인 경우 이를 모두 010 으로 변경한다.


UPDATE TBL_INSABACKUP
SET TEL = '010'||SUBSTR(TEL,4)
WHERE SUBSTR(TEL,1,3) IN ('016','017','018','019');
--==>> 24개 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_INSABACKUP;
/*

*/

COMMIT;
--==>> 커밋 완료.




















SELECT USER
FROM DUAL;
--==>>HR\


--○  EMPLOYEES 테이블의 직원들 SALARY 를 10% 인상한다.
--   단 부서명이 'IT'인 경우로 한정한다.
--   (쿼리문 실행 이후 변경된 결과를 확인한 후 ROLLBACK 할 것)
UPDATE
(
SELECT *
FROM EMPLOYEES E LEFT JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE DEPARTMENT_NAME IN ('IT')
)Z
SET Z.SALARY = Z.SALARY * 1.1
WHERE Z.DEPARTMENT_NAME IN ('IT');


SELECT *
FROM EMPLOYEES E LEFT JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
WHERE DEPARTMENT_NAME IN ('IT');




UPDATE EMPLOYEES
SET SALARY = SALARY * 1.1
WHERE DEPARTMENT_ID = 60;

SELECT FIRST_NAME,LAST_NAME,SALARY,DEPARTMENT_ID,SALARY * 1.1
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (DEPARTMENTS 테이블에서 IT 부서의 부서ID);

--(DEPARTMENTS 테이블에서 IT 부서의 부서ID)
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_NAME='IT';



SELECT FIRST_NAME,LAST_NAME,SALARY,DEPARTMENT_ID,SALARY * 1.1
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE DEPARTMENT_NAME='IT');
/*
Alexander	Hunold	    9900	60	10890
Bruce	    Ernst	    6600	60	7260
David	    Austin	    5280	60	5808
Valli	    Pataballa	5280	60	5808
Diana	    Lorentz	    4620	60	5082
*/


UPDATE EMPLOYEES
SET SALARY = SALARY * 1.1
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE DEPARTMENT_NAME='IT');
--==>>5개 행 이(가) 업데이트되었습니다.

SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE DEPARTMENT_NAME='IT');
/*
Alexander	Hunold	    10890	60
Bruce	    Ernst	    7260	60
David	    Austin	    5808	60
Valli	    Pataballa	5808	60
Diana	    Lorentz	    5082	60
*/

ROLLBACK;
--==>> 롤백 완료.

--○  EMPLOYEES 테이블에서 JOB_TITLE 이 『SALES MANAGER』인 사원의
--   SALARY 를 해당 직무(직종)의 최고 급여(MAX_SALARY)로 수정하는 쿼리문을 구성한다.
--   단, 입사일이 2006년 이전(해당 년도 제외) 입사자에 한하여
--   적용할 수 있도록 처리한다.
--   (쿼리문 실행 이후 변경된 결과를 확인한 후 ROLLBACK 할 것)


-- 내가 한 풀이
UPDATE EMPLOYEES
SET SALARY =   (SELECT MAX_SALARY FROM JOBS WHERE JOB_TITLE = 'Sales Manager')
WHERE JOB_ID =  (SELECT JOB_ID FROM JOBS WHERE JOB_TITLE = 'Sales Manager') AND TO_CHAR(HIRE_DATE,'YYYY') < 2006;


-- 강사님 풀이
UPDATE EMPLOYEES
SET SALARY = (SELECT MAX_SALARY
              FROM JOBS
              WHERE JOB_TITLE = 'Sales Manager')
WHERE JOB_ID = (SELECT JOB_ID
                FROM JOBS
                WHERE JOB_TITLE = 'Sales Manager')
AND   TO_NUMBER(TO_CHAR(HIRE_DATE, 'YYYY')) < 2006;

-- ('Sales Manager' 의 MAX_SALARY)
SELECT MAX_SALARY
FROM JOBS
WHERE JOB_TITLE = 'Sales Manager';
--==>> 20080


--('Sales Manager' 의 JOB_ID)
SELECT JOB_ID
FROM JOBS
WHERE JOB_TITLE = 'Sales Manager';
--==>> SA_MAN







SELECT FIRST_NAME,SALARY
FROM EMPLOYEES
WHERE JOB_ID = (SELECT JOB_ID
                FROM JOBS
                WHERE JOB_TITLE = 'Sales Manager')
AND   TO_NUMBER(TO_CHAR(HIRE_DATE, 'YYYY')) < 2006;
--==>>
/*
John	20080
Karen	20080
Alberto	20080
*/

ROLLBACK;
--==>> 롤백 완료.



--○ EMPLOYEES 테이블에서 SALARY 를
--  각 부서의 이름별로 다른 인상률을 적용하여 수정할 수 있도록 한다.
-- Finance → 10%
-- Accounting → 20%
-- 나머지부서 → 0%
--   (쿼리문 실행 이후 변경된 결과를 확인한 후 ROLLBACK 할 것)



UPDATE EMPLOYEES
SET SALARY = SALARY *
(CASE WHEN DEPARTMENT_ID =(SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Finance') THEN 1.1
      WHEN DEPARTMENT_ID =(SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Executive') THEN 1.5
      WHEN DEPARTMENT_ID =(SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Accounting') THEN 2.0
      END
);


ROLLBACK;
















SELECT USER
FROM DUAL;
--==>>

--○ EMPLOYEES 테이블에서 SALARY 를
--  각 부서의 이름별로 다른 인상률을 적용하여 수정할 수 있도록 한다.
-- Finance → 10%
-- Accounting → 20%
-- 나머지부서 → 0%
--   (쿼리문 실행 이후 변경된 결과를 확인한 후 ROLLBACK 할 것)


UPDATE EMPLOYEES
SET SALARY = SALARY *
(CASE WHEN DEPARTMENT_ID =(SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Finance') THEN 1.1
      WHEN DEPARTMENT_ID =(SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Executive') THEN 1.15
      WHEN DEPARTMENT_ID =(SELECT DEPARTMENT_ID FROM DEPARTMENTS WHERE DEPARTMENT_NAME = 'Accounting') THEN 1.2
      END
);




UPDATE EMPLOYEES
SET SALARY = CASE DEPARTMENT_ID WHEN ('Finance'의 부서아이디)
                                THEN SALARY * 1.1
                                WHEN ('Executive'의 부서아이디)
                                THEN SALARY * 1.1
                                WHEN ('Accounting'의 부서아이디)
                                THEN SALARY * 1.1


--('Finance'의 부서아이디)
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_NAME = 'Finanace'
--('Executive'의 부서아이디)
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_NAME = 'Executive'
--('Accounting'의 부서아이디)
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_NAME = 'Accounting'




UPDATE EMPLOYEES
SET SALARY = CASE DEPARTMENT_ID WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Finanace')
                                THEN SALARY * 1.1
                                WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Executive')
                                THEN SALARY * 1.15
                                WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Accounting')
                                THEN SALARY * 1.2
                                ELSE SALARY
                                END
WHERE DEPARTMENT_ID IN (100,90,110);



UPDATE EMPLOYEES
SET SALARY = CASE DEPARTMENT_ID WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Finanace')
                                THEN SALARY * 1.1
                                WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Executive')
                                THEN SALARY * 1.15
                                WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Accounting')
                                THEN SALARY * 1.2
                                ELSE SALARY
                                END
WHERE DEPARTMENT_ID IN (100,90,110);

-- (100,90,110)
SELECT DEPARTMENT_ID
FROM DEPARTMENTS
WHERE DEPARTMENT_NAME IN ('Finance','Executive','Accounting');
/*
90
100
110
*/



UPDATE EMPLOYEES
SET SALARY = CASE DEPARTMENT_ID WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Finanace')
                                THEN SALARY * 1.1
                                WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Executive')
                                THEN SALARY * 1.15
                                WHEN (SELECT DEPARTMENT_ID
                                FROM DEPARTMENTS
                                WHERE DEPARTMENT_NAME = 'Accounting')
                                THEN SALARY * 1.2
                                ELSE SALARY
                                END
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
                        FROM DEPARTMENTS
                        WHERE DEPARTMENT_NAME IN ('Finance','Executive','Accounting')
                        );


ROLLBACK;
--==>> 11개 행 이(가) 업데이트되었습니다.


--■ ■ ■ DELETE ■ ■ ■--

-- 1. 테이블에서 지정된 행(레코드)을 삭제하는 데 사용하는 구문.

-- 2. 형식 및 구조
-- DELETE [FROM] 테이블명
-- [WHERE 조건절];


SELECT *
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 198;
--==>>198	Donald	OConnell	DOCONNEL	650.507.9833	2007-06-21	SH_CLERK			124	50
DELETE
FROM EMPLOYEES
WHERE EMPLOYEE_ID = 198;
--==>>1 행 이(가) 삭제되었습니다.

ROLLBACK;
--==>>롤백 완료.



--○ EMPLOYEES 테이블에서 직원들의 정보를 삭제한다.
--  단, 부서명이 'IT'인 경우로 한정한다.

-- ※  실제로는 EMPLOYEES 테이블의 데이터가(삭제하고자 하는 대상)
--    다른 테이블(혹은 자기 자신 테이블)에 의해 참조당하고 있는 경우
--    삭제되지 않을 수 있다는 상황을 인지해야 하며...
--    그에 대한 이유도 알아야 한다.




SELECT *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
                       FROM DEPARTMENTS
                       WHERE DEPARTMENT_NAME='IT');
/*
103	Alexander	Hunold	    AHUNOLD	    590.423.4567	2006-01-03	IT_PROG			102	60
104	Bruce	    Ernst	    BERNST	    590.423.4568	2007-05-21	IT_PROG			103	60
105	David	    Austin	    DAUSTIN	    590.423.4569	2005-06-25	IT_PROG			103	60
106	Valli	    Pataballa	VPATABAL	590.423.4560	2006-02-05	IT_PROG			103	60
107	Diana	    Lorentz	    DLORENTZ	590.423.5567	2007-02-07	IT_PROG			103	60
*/


DELETE *
FROM EMPLOYEES
WHERE DEPARTMENT_ID = (SELECT DEPARTMENT_ID
                       FROM DEPARTMENTS
                       WHERE DEPARTMENT_NAME='IT');

--==>> 에러발생 
/*
오류 보고 -
SQL 오류: ORA-00903: invalid table name
00903. 00000 -  "invalid table name"
*Cause:    
*Action:
*/




--■ ■ ■ 뷰(VIEW) ■ ■ ■--

-- 1. 뷰(VIEW)란 이미 특정한 데이터베이스 내에 존재하는
--    하나 이상의 테이블에서 사용자가 얻기 원하는 데이터들만을
--    원하는 형태로 정확하고 편하게 가져오기 위하여
--    사전에 원하는 컬럼들만 모아서 만들어놓은 가상의 테이블로
--    편의성 및 보안에 목적이 있다.

--    가상의 테이블이란 뷰가 실제로 존재하는 테이블(객체)이 아니라
--    하나 이상의 테이블에서 파생된 또 다른 정보를 볼 수 있는 방법이다
--    그 정보를 추출해내는 SQL 문장이라고 볼 수 있다.

-- 2. 형식 및 구조
-- CREAT [OR REPLACE] VIEW 뷰이름
-- [(ALIAS[, ALIAS, ...])]
-- AS
-- 서브쿼리(SUBQUERY)
-- [WITH CHECK OPTION]
-- [WITH READ ONLY];


--○ 뷰(VIEW) 생성

SELECT E.FIRST_NAME, E.LAST_NAME
      , D.DEPARTMENT_NAME, L.CITY
      , C.COUNTRY_NAME, R.REGION_NAME
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L, COUNTRIES C, REGIONS R
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
  AND D.LOCATION_ID = L.LOCATION_ID(+)
  AND L.COUNTRY_ID = C.COUNTRY_ID(+)
  AND C.REGION_ID = R.REGION_ID(+);
/*
Alexander	Hunold	IT	Southlake	United States of America	Americas
Bruce	    Ernst	IT	Southlake	United States of America	Americas
David	    Austin	IT	Southlake	United States of America	Americas
Valli	    Pataballa	IT	Southlake	United States of America	Americas
Diana	    Lorentz	IT	Southlake	United States of America	Americas
Matthew	    Weiss	Shipping	South San Francisco	United States of America	Americas
Adam	    Fripp	Shipping	South San Francisco	United States of America	Americas
Payam	    Kaufling	Shipping	South San Francisco	United States of America	Americas
Shanta	    Vollman	Shipping	South San Francisco	United States of America	Americas
Kevin	    Mourgos	Shipping	South San Francisco	United States of America	Americas
Julia	    Nayer	Shipping	South San Francisco	United States of America	Americas
Irene	    Mikkilineni	Shipping	South San Francisco	United States of America	Americas
James	    Landry	Shipping	South San Francisco	United States of America	Americas
Steven	    Markle	Shipping	South San Francisco	United States of America	Americas
Laura	    Bissot	Shipping	South San Francisco	United States of America	Americas
Mozhe	    Atkinson	Shipping	South San Francisco	United States of America	Americas
James	    Marlow	Shipping	South San Francisco	United States of America	Americas
TJ	Olson	Shipping	South San Francisco	United States of America	Americas
Jason	    Mallin	Shipping	South San Francisco	United States of America	Americas
Michael	    Rogers	Shipping	South San Francisco	United States of America	Americas
Ki	Gee	    Shipping	South San Francisco	United States of America	Americas
Hazel	    Philtanker	Shipping	South San Francisco	United States of America	Americas
Renske	    Ladwig	Shipping	South San Francisco	United States of America	Americas
Stephen	    Stiles	Shipping	South San Francisco	United States of America	Americas
John	    Seo	Shipping	South San Francisco	United States of America	Americas
Joshua	    Patel	Shipping	South San Francisco	United States of America	Americas
Trenna	    Rajs	Shipping	South San Francisco	United States of America	Americas
Curtis	    Davies	Shipping	South San Francisco	United States of America	Americas
Randall	    Matos	Shipping	South San Francisco	United States of America	Americas
Peter	    Vargas	Shipping	South San Francisco	United States of America	Americas
Winston	    Taylor	Shipping	South San Francisco	United States of America	Americas
Jean	    Fleaur	Shipping	South San Francisco	United States of America	Americas
Martha	    Sullivan	Shipping	South San Francisco	United States of America	Americas
Girard	    Geoni	Shipping	South San Francisco	United States of America	Americas
Nandita	    Sarchand	Shipping	South San Francisco	United States of America	Americas
Alexis	    Bull	Shipping	South San Francisco	United States of America	Americas
Julia	    Dellinger	Shipping	South San Francisco	United States of America	Americas
Anthony	    Cabrio	Shipping	South San Francisco	United States of America	Americas
Kelly	    Chung	Shipping	South San Francisco	United States of America	Americas
Jennifer	Dilly	Shipping	South San Francisco	United States of America	Americas
Timothy	    Gates	Shipping	South San Francisco	United States of America	Americas
Randall 	Perkins	Shipping	South San Francisco	United States of America	Americas
Sarah	    Bell	Shipping	South San Francisco	United States of America	Americas
Britney	    Everett	Shipping	South San Francisco	United States of America	Americas
Samuel	    McCain	Shipping	South San Francisco	United States of America	Americas
Vance	    Jones	Shipping	South San Francisco	United States of America	Americas
Alana	    Walsh	Shipping	South San Francisco	United States of America	Americas
Kevin	    Feeney	Shipping	South San Francisco	United States of America	Americas
Donald	    OConnell	Shipping	South San Francisco	United States of America	Americas
Douglas	    Grant	Shipping	South San Francisco	United States of America	Americas
Shelley	    Higgins	Accounting	Seattle	United States of America	Americas
William	    Gietz	Accounting	Seattle	United States of America	Americas
Nancy	    Greenberg	Finance	Seattle	United States of America	Americas
Daniel	    Faviet	Finance	Seattle	United States of America	Americas
John	    Chen	Finance	Seattle	United States of America	Americas
Ismael	    Sciarra	Finance	Seattle	United States of America	Americas
Jose Manuel	Urman	Finance	Seattle	United States of America	Americas
Luis	    Popp	Finance	Seattle	United States of America	Americas
Steven	    King	Executive	Seattle	United States of America	Americas
Neena	    Kochhar	Executive	Seattle	United States of America	Americas
Lex	        De Haan	Executive	Seattle	United States of America	Americas
Den	        Raphaely	Purchasing	Seattle	United States of America	Americas
Alexander	Khoo	Purchasing	Seattle	United States of America	Americas
Shelli	    Baida	Purchasing	Seattle	United States of America	Americas
Sigal	    Tobias	Purchasing	Seattle	United States of America	Americas
Guy	Himuro	Purchasing	Seattle	United States of America	Americas
Karen	    Colmenares	Purchasing	Seattle	United States of America	Americas
Jennifer	Whalen	Administration	Seattle	United States of America	Americas
Michael	    Hartstein	Marketing	Toronto	Canada	Americas
Pat	Fay	    Marketing	Toronto	Canada	Americas
Susan	    Mavris	Human Resources	London	United Kingdom	Europe
John	    Russell	Sales	Oxford	United Kingdom	Europe
Karen	    Partners	Sales	Oxford	United Kingdom	Europe
Alberto	    Errazuriz	Sales	Oxford	United Kingdom	Europe
Gerald	    Cambrault	Sales	Oxford	United Kingdom	Europe
Eleni	    Zlotkey	Sales	Oxford	United Kingdom	Europe
Peter	    Tucker	Sales	Oxford	United Kingdom	Europe
David	    Bernstein	Sales	Oxford	United Kingdom	Europe
Peter	    Hall	Sales	Oxford	United Kingdom	Europe
Christopher	Olsen	Sales	Oxford	United Kingdom	Europe
Nanette	    Cambrault	Sales	Oxford	United Kingdom	Europe
Oliver	    Tuvault	Sales	Oxford	United Kingdom	Europe
Janette	    King	Sales	Oxford	United Kingdom	Europe
Patrick	    Sully	Sales	Oxford	United Kingdom	Europe
Allan	    McEwen	Sales	Oxford	United Kingdom	Europe
Lindsey	    Smith	Sales	Oxford	United Kingdom	Europe
Louise	    Doran	Sales	Oxford	United Kingdom	Europe
Sarath	    Sewall	Sales	Oxford	United Kingdom	Europe
Clara	    Vishney	Sales	Oxford	United Kingdom	Europe
Danielle	Greene	Sales	Oxford	United Kingdom	Europe
Mattea	    Marvins	Sales	Oxford	United Kingdom	Europe
David	    Lee	Sales	Oxford	United Kingdom	Europe
Sundar	    Ande	Sales	Oxford	United Kingdom	Europe
Amit	    Banda	Sales	Oxford	United Kingdom	Europe
Lisa	    Ozer	Sales	Oxford	United Kingdom	Europe
Harrison	Bloom	Sales	Oxford	United Kingdom	Europe
Tayler	    Fox 	Sales	Oxford	United Kingdom	Europe
William	    Smith	Sales	Oxford	United Kingdom	Europe
Elizabeth	Bates	Sales	Oxford	United Kingdom	Europe
Sundita	Kumar	Sales	Oxford	United Kingdom	Europe
Ellen	Abel	Sales	Oxford	United Kingdom	Europe
Alyssa	Hutton	Sales	Oxford	United Kingdom	Europe
Jonathon	Taylor	Sales	Oxford	United Kingdom	Europe
Jack	Livingston	Sales	Oxford	United Kingdom	Europe
Charles	Johnson	Sales	Oxford	United Kingdom	Europe
Hermann	Baer	Public Relations	Munich	Germany	Europe
Kimberely	Grant				
*/

CREATE OR REPLACE VIEW VIEW_EMPLOYEES
AS
SELECT E.FIRST_NAME, E.LAST_NAME
      , D.DEPARTMENT_NAME, L.CITY
      , C.COUNTRY_NAME, R.REGION_NAME
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L, COUNTRIES C, REGIONS R
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
  AND D.LOCATION_ID = L.LOCATION_ID(+)
  AND L.COUNTRY_ID = C.COUNTRY_ID(+)
  AND C.REGION_ID = R.REGION_ID(+);
--==>>View VIEW_EMPLOYEES이(가) 생성되었습니다.

--○ 뷰(VIEW) 조회

SELECT *
FROM VIEW_EMPLOYEES;
--==>>
/*
Alexander	Hunold	IT	Southlake	United States of America	Americas
Bruce	Ernst	IT	Southlake	United States of America	Americas
David	Austin	IT	Southlake	United States of America	Americas
Valli	Pataballa	IT	Southlake	United States of America	Americas
Diana	Lorentz	IT	Southlake	United States of America	Americas
Matthew	Weiss	Shipping	South San Francisco	United States of America	Americas
Adam	Fripp	Shipping	South San Francisco	United States of America	Americas
Payam	Kaufling	Shipping	South San Francisco	United States of America	Americas
Shanta	Vollman	Shipping	South San Francisco	United States of America	Americas
Kevin	Mourgos	Shipping	South San Francisco	United States of America	Americas
Julia	Nayer	Shipping	South San Francisco	United States of America	Americas
Irene	Mikkilineni	Shipping	South San Francisco	United States of America	Americas
James	Landry	Shipping	South San Francisco	United States of America	Americas
Steven	Markle	Shipping	South San Francisco	United States of America	Americas
Laura	Bissot	Shipping	South San Francisco	United States of America	Americas
Mozhe	Atkinson	Shipping	South San Francisco	United States of America	Americas
James	Marlow	Shipping	South San Francisco	United States of America	Americas
TJ	Olson	Shipping	South San Francisco	United States of America	Americas
Jason	Mallin	Shipping	South San Francisco	United States of America	Americas
Michael	Rogers	Shipping	South San Francisco	United States of America	Americas
Ki	Gee	Shipping	South San Francisco	United States of America	Americas
Hazel	Philtanker	Shipping	South San Francisco	United States of America	Americas
Renske	Ladwig	Shipping	South San Francisco	United States of America	Americas
Stephen	Stiles	Shipping	South San Francisco	United States of America	Americas
John	Seo	Shipping	South San Francisco	United States of America	Americas
Joshua	Patel	Shipping	South San Francisco	United States of America	Americas
Trenna	Rajs	Shipping	South San Francisco	United States of America	Americas
Curtis	Davies	Shipping	South San Francisco	United States of America	Americas
Randall	Matos	Shipping	South San Francisco	United States of America	Americas
Peter	Vargas	Shipping	South San Francisco	United States of America	Americas
Winston	Taylor	Shipping	South San Francisco	United States of America	Americas
Jean	Fleaur	Shipping	South San Francisco	United States of America	Americas
Martha	Sullivan	Shipping	South San Francisco	United States of America	Americas
Girard	Geoni	Shipping	South San Francisco	United States of America	Americas
Nandita	Sarchand	Shipping	South San Francisco	United States of America	Americas
Alexis	Bull	Shipping	South San Francisco	United States of America	Americas
Julia	Dellinger	Shipping	South San Francisco	United States of America	Americas
Anthony	Cabrio	Shipping	South San Francisco	United States of America	Americas
Kelly	Chung	Shipping	South San Francisco	United States of America	Americas
Jennifer	Dilly	Shipping	South San Francisco	United States of America	Americas
Timothy	Gates	Shipping	South San Francisco	United States of America	Americas
Randall	Perkins	Shipping	South San Francisco	United States of America	Americas
Sarah	Bell	Shipping	South San Francisco	United States of America	Americas
Britney	Everett	Shipping	South San Francisco	United States of America	Americas
Samuel	McCain	Shipping	South San Francisco	United States of America	Americas
Vance	Jones	Shipping	South San Francisco	United States of America	Americas
Alana	Walsh	Shipping	South San Francisco	United States of America	Americas
Kevin	Feeney	Shipping	South San Francisco	United States of America	Americas
Donald	OConnell	Shipping	South San Francisco	United States of America	Americas
Douglas	Grant	Shipping	South San Francisco	United States of America	Americas
Shelley	Higgins	Accounting	Seattle	United States of America	Americas
William	Gietz	Accounting	Seattle	United States of America	Americas
Nancy	Greenberg	Finance	Seattle	United States of America	Americas
Daniel	Faviet	Finance	Seattle	United States of America	Americas
John	Chen	Finance	Seattle	United States of America	Americas
Ismael	Sciarra	Finance	Seattle	United States of America	Americas
Jose Manuel	Urman	Finance	Seattle	United States of America	Americas
Luis	Popp	Finance	Seattle	United States of America	Americas
Steven	King	Executive	Seattle	United States of America	Americas
Neena	Kochhar	Executive	Seattle	United States of America	Americas
Lex	De Haan	Executive	Seattle	United States of America	Americas
Den	Raphaely	Purchasing	Seattle	United States of America	Americas
Alexander	Khoo	Purchasing	Seattle	United States of America	Americas
Shelli	Baida	Purchasing	Seattle	United States of America	Americas
Sigal	Tobias	Purchasing	Seattle	United States of America	Americas
Guy	Himuro	Purchasing	Seattle	United States of America	Americas
Karen	Colmenares	Purchasing	Seattle	United States of America	Americas
Jennifer	Whalen	Administration	Seattle	United States of America	Americas
Michael	Hartstein	Marketing	Toronto	Canada	Americas
Pat	Fay	Marketing	Toronto	Canada	Americas
Susan	Mavris	Human Resources	London	United Kingdom	Europe
John	Russell	Sales	Oxford	United Kingdom	Europe
Karen	Partners	Sales	Oxford	United Kingdom	Europe
Alberto	Errazuriz	Sales	Oxford	United Kingdom	Europe
Gerald	Cambrault	Sales	Oxford	United Kingdom	Europe
Eleni	Zlotkey	Sales	Oxford	United Kingdom	Europe
Peter	Tucker	Sales	Oxford	United Kingdom	Europe
David	Bernstein	Sales	Oxford	United Kingdom	Europe
Peter	Hall	Sales	Oxford	United Kingdom	Europe
Christopher	Olsen	Sales	Oxford	United Kingdom	Europe
Nanette	Cambrault	Sales	Oxford	United Kingdom	Europe
Oliver	Tuvault	Sales	Oxford	United Kingdom	Europe
Janette	King	Sales	Oxford	United Kingdom	Europe
Patrick	Sully	Sales	Oxford	United Kingdom	Europe
Allan	McEwen	Sales	Oxford	United Kingdom	Europe
Lindsey	Smith	Sales	Oxford	United Kingdom	Europe
Louise	Doran	Sales	Oxford	United Kingdom	Europe
Sarath	Sewall	Sales	Oxford	United Kingdom	Europe
Clara	Vishney	Sales	Oxford	United Kingdom	Europe
Danielle	Greene	Sales	Oxford	United Kingdom	Europe
Mattea	Marvins	Sales	Oxford	United Kingdom	Europe
David	Lee	Sales	Oxford	United Kingdom	Europe
Sundar	Ande	Sales	Oxford	United Kingdom	Europe
Amit	Banda	Sales	Oxford	United Kingdom	Europe
Lisa	Ozer	Sales	Oxford	United Kingdom	Europe
Harrison	Bloom	Sales	Oxford	United Kingdom	Europe
Tayler	Fox	Sales	Oxford	United Kingdom	Europe
William	Smith	Sales	Oxford	United Kingdom	Europe
Elizabeth	Bates	Sales	Oxford	United Kingdom	Europe
Sundita	Kumar	Sales	Oxford	United Kingdom	Europe
Ellen	Abel	Sales	Oxford	United Kingdom	Europe
Alyssa	Hutton	Sales	Oxford	United Kingdom	Europe
Jonathon	Taylor	Sales	Oxford	United Kingdom	Europe
Jack	Livingston	Sales	Oxford	United Kingdom	Europe
Charles	Johnson	Sales	Oxford	United Kingdom	Europe
Hermann	Baer	Public Relations	Munich	Germany	Europe
Kimberely	Grant				
*/


--○ 뷰(VIEW) 구조 확인
DESC VIEW_EMPLYEES;
--==>>
/*
이름              널?       유형           
--------------- -------- ------------ 
FIRST_NAME               VARCHAR2(20) 
LAST_NAME       NOT NULL VARCHAR2(25) 
DEPARTMENT_NAME          VARCHAR2(30) 
CITY                     VARCHAR2(30) 
COUNTRY_NAME             VARCHAR2(40) 
REGION_NAME              VARCHAR2(25) 

*/

--○ 뷰(VIEW) 소스 확인           --CHECK!!

SELECT VIEW_NAME, TEXT          -- TEXT
FROM USER_VIEWS                 --USER_VIEWS
WHERE VIEW_NAME = 'VIEW_EMPLOYEES';
/*
VIEW_EMPLOYEES	"SELECT E.FIRST_NAME, E.LAST_NAME
                , D.DEPARTMENT_NAME, L.CITY
                , C.COUNTRY_NAME, R.REGION_NAME
FROM EMPLOYEES E, DEPARTMENTS D, LOCATIONS L, COUNTRIES C, REGIONS R
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
  AND D.LOCATION_ID = L.LOCATION_ID(+)
  AND L.COUNTRY_ID = C.COUNTRY_ID(+)
  AND C.REGION_ID = R.REGION_ID(+)"
*/


SELECT USER
FROM DUAL;
--==>>SCOTT


SELECT *
FROM TBL_SAWON;
--==>>
/*
1002	정승민	    0002114234567	2017-11-05	2000
1003	정영훈	    8709062234567	2005-08-16	5000
1004	문제정	    9608051234567	1999-08-16	4000
1005	이은솔	    9104282234567	2018-02-22	7700
1006	곽유진	    9901192234567	2002-07-15	2000
1007	이상이	    8512161234567	1999-08-16	2000
1008	이이경	    8904051234567	2009-06-05	1000
1009	아이유	    9302022234567	2012-07-13	3000
1010	미노이	    9704252234567	2007-12-10	2000
1011	선동열	    7012181234567	1990-10-10	3000
1012	선우용녀	7005132234567	1998-08-10	2000
1013	선우선	    0203044234567	2012-07-13	1000
1014	남희석	    0502033234567	2012-07-13	1000
1015	남궁선	    0512124234567	2015-08-14	3000
1016	남진	    7108051234567	1990-10-10	2000
1001	김정현	    9804111234567	2024-11-21	100
1017	정우	    8502031234567	1999-10-10	2000
*/

--○ TBL_SAWON 테이블 백업(→ 데이터 복사 2024-12-02 09:19:10)
CREATE TABLE TBL_SAWONBACKUP
AS
SELECT *
FROM TBL_SAWON;
--==>>Table TBL_SAWONBACKUP이(가) 생성되었습니다.
--> TBL_SAWON 테이블의 데이터들만 백업을 수행
--  즉, 다른 이름의 테이블 형태로 저장해둔 상황

--○ 확인
SELECT *
FROM TBL_SAWONBACKUP;
SELECT *
FROM TBL_SAWON;



UPDATE TBL_SAWON
SET SANAME='똘똘이';
COMMIT;
--==>>
/*
17개 행 이(가) 업데이트되었습니다.

커밋 완료.
*/

SELECT *
FROM TBL_SAWON;
/*
1002	똘똘이	0002114234567	2017-11-05	2000
1003	똘똘이	8709062234567	2005-08-16	5000
1004	똘똘이	9608051234567	1999-08-16	4000
1005	똘똘이	9104282234567	2018-02-22	7700
1006	똘똘이	9901192234567	2002-07-15	2000
1007	똘똘이	8512161234567	1999-08-16	2000
1008	똘똘이	8904051234567	2009-06-05	1000
1009	똘똘이	9302022234567	2012-07-13	3000
1010	똘똘이	9704252234567	2007-12-10	2000
1011	똘똘이	7012181234567	1990-10-10	3000
1012	똘똘이	7005132234567	1998-08-10	2000
1013	똘똘이	0203044234567	2012-07-13	1000
1014	똘똘이	0502033234567	2012-07-13	1000
1015	똘똘이	0512124234567	2015-08-14	3000
1016	똘똘이	7108051234567	1990-10-10	2000
1001	똘똘이	9804111234567	2024-11-21	100
1017	똘똘이	8502031234567	1999-10-10	2000
*/


ROLLBACK;
--==>> 롤백 완료.

SELECT *
FROM TBL_SAWON;
/*
1002	똘똘이	0002114234567	2017-11-05	2000
1003	똘똘이	8709062234567	2005-08-16	5000
1004	똘똘이	9608051234567	1999-08-16	4000
1005	똘똘이	9104282234567	2018-02-22	7700
1006	똘똘이	9901192234567	2002-07-15	2000
1007	똘똘이	8512161234567	1999-08-16	2000
1008	똘똘이	8904051234567	2009-06-05	1000
1009	똘똘이	9302022234567	2012-07-13	3000
1010	똘똘이	9704252234567	2007-12-10	2000
1011	똘똘이	7012181234567	1990-10-10	3000
1012	똘똘이	7005132234567	1998-08-10	2000
1013	똘똘이	0203044234567	2012-07-13	1000
1014	똘똘이	0502033234567	2012-07-13	1000
1015	똘똘이	0512124234567	2015-08-14	3000
1016	똘똘이	7108051234567	1990-10-10	2000
1001	똘똘이	9804111234567	2024-11-21	100
1017	똘똘이	8502031234567	1999-10-10	2000
*/



-- 위와 같이 UPDATE 처리 이후에 COMMIT 을 수행하였기 떄문에
-- ROLLBACK 은 불가능한 상황이다.
-- 하지만, TBL_SAWONBACKUP 테이블에 데이터를 백업해 두었다.
-- SANAME 컬럼의 내용만 추출하여 '똘똘이' 대신 넣어줄 수 있다는 것이다.


UPDATE T BL_SAWON
SET SANAME = '김정현'
WHERE SANO=1001;

UPDATE T BL_SAWON
SET SANAME = '정승민'
WHERE SANO=1002;

UPDATE T BL_SAWON
SET SANAME = '정영훈'
WHERE SANO=1003;

--      :


UPDATE TBL_SAWON
SET SANAME= ( SELECT SANAME
              FROM TBL_SAWONBACKUP
              WHERE SANO = TBL_SAWON.SANO);
--==>> 17개 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_SAWON;
--==>>
/*
1002	정승민	    0002114234567	2017-11-05	2000
1003	정영훈	    8709062234567	2005-08-16	5000
1004	문제정	    9608051234567	1999-08-16	4000
1005	이은솔	    9104282234567	2018-02-22	7700
1006	곽유진	    9901192234567	2002-07-15	2000
1007	이상이	    8512161234567	1999-08-16	2000
1008	이이경	    8904051234567	2009-06-05	1000
1009	아이유	    9302022234567	2012-07-13	3000
1010	미노이	    9704252234567	2007-12-10	2000
1011	선동열	    7012181234567	1990-10-10	3000
1012	선우용녀	7005132234567	1998-08-10	2000
1013	선우선	    0203044234567	2012-07-13	1000
1014	남희석	    0502033234567	2012-07-13	1000
1015	남궁선	    0512124234567	2015-08-14	3000
1016	남진	    7108051234567	1990-10-10	2000
1001	김정현	    9804111234567	2024-11-21	100
1017	정우	    8502031234567	1999-10-10	2000
*/

COMMIT;
--==>>커밋 완료.



              SELECT USER
FROM DUAL;
--==>>SCOTT 


--■ ■ ■ PL/SQL ■ ■ ■--

-- 1. PL/SQL(Procedural Language extenision to Sql) 은
-- 프로그래밍 언어의 특성을 가지는 SQL 의 확장이며
--  데이터 조작과 질의 문장은 PL/SQL 의 절차적 코드 안에 포함된다.
--  또한, PL/SQL 을 사용하면 SQL로 할 수 없는 절차적 작업이  가능하다.
--  여기에서 『절차적』이라는 단어가 가지는 의미는
--  어떤 것이 어떤 과정을 거쳐 어떻게 완료되는지
--  그 방법을 정확하게 코드에 기술한다는 것을 의미한다.

-- 2. PL/SQL 은 절차적으로 표현하기 위해
--  변수를 선언할 수 있는 기능
--  참과 거짓을 구별할 수 있는 기능
--  실행 흐름을 컨트롤 할 수있는 기능 등을 제공한다.

-- 3. PL/SQL 은 블럭 구조로 되어있으며
--   블럭은 선언 부분, 실행 부분, 예외처리 부분의
--   세 부분으로 구성되어 있다.
--   또한, 반드시 실행 부분은 존재해야 하며,구조는 다음과 같다.

-- 4. 형식 및 구조
/*
[DECLARE]
        -- 선언문(declarations)
BEGIN
        -- 실행문(statements)
        
        [EXCEPTION]
            -- 예외 처리문(exception handlers)
END;
*/


--5. 변수 선언
/*
DECLARE
    변수명 자료형;
    변수명 자료형 := 초기값;
BEGIN
    PL/SQL 구문;
*/



SET SERVEROUTPUT ON;
--==>> 작업이 완료되었습니다.(0.063초)
--> 『DBMS_OUTPUT.PUT_LINE()』을 통해
-- 화면에 결과를 출력하기 위한 환경변수 설정



--○ 변수에 임의의 값을 대입하고 출력하는 PL/SQL 구문 작성
DECLARE
        -- 선언부
        D1 NUMBER :=10;
        D2 VARCHAR2(30) := 'HELLO';
        D3 VARCHAR2(20) := 'ORACLE';
BEGIN
        -- 실행부
        DBMS_OUTPUT.PUT_LINE(D1);
        DBMS_OUTPUT.PUT_LINE(D2);
        DBMS_OUTPUT.PUT_LINE(D3);
END;
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.
--==>>
/*
10
HELLO
ORACLE

PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/



--○ 변수에 임의의 값을 대입하고 출력하는 구문 작성

DECLARE
        -- 선언부
        V1 NUMBER := 20;
        V2 VARCHAR2(20) := 'HEELO';
        V3 VARCHAR2(20) := 'ORACLE';
BEGIN
        -- 실행부
        V1 := V1 + 10;          -- V1 += 10;
        V2 := V2 || '믿음이';
        V3 := V3 || 'World';
        
        DBMS_OUTPUT.PUT_LINE(V1);
        DBMS_OUTPUT.PUT_LINE(V2);
        DBMS_OUTPUT.PUT_LINE(V3);
END;
/*
30
HEELO믿음이
ORACLEWorld


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/

--○ IF문(조건문)
-- IF ~ END IF;
-- IF ~ THEN ~ ELSE ~ END IF;
-- IF ~ THEN ~ ELSIF ~ THEN ~ ELSIF ~ THEN ~ ELSE~ END IF;


-- 1. PL/SQL 의 IF 문장은 다른 언어의 IF 조건문과 거의 유사하다.
--   일치하는 조건에 따라 선택적으로 작업을 수행할 수 있도록 한다.
--   TRUE 이면 THEN 과 ELSE 사이의 문장을 수행하고
--   FALSE 나 NULL 이면 ELSE  와 END 사이의 문장을 수행하게 된다.

-- 2. 형식 및 구조
/*
IF 조건
    THEN 처리구문;
END IF;
*/


/*
IF 조건
    THEN 처리구문;
ELSE
    처리구문;
END IF;
*/


/*
IF 조건
    THEN 처리구문;
ELSIF
    THEN 처리구문;
ELSIF
    THEN 처리구문;
ELSE
    처리구문;
END IF;
*/



--○ 변수에 들어있는 값에 따라...
--  Excellent, Good, Fail 로 구분하여
--  결과를 출력하는 PL/SQL 구문을 작성한다.

DECLARE
    GRADE CHAR;
BEGIN
    --GRADE := 'A';
    --GRADE := 'B';
    GRADE := 'C';
    
    IF (GRADE = 'A')
        THEN DBMS_OUTPUT.PUT_LINE('Excellent');
    ELSIF (GRADE = 'B')
        THEN DBMS_OUTPUT.PUT_LINE('Good');
    ELSE
        DBMS_OUTPUT.PUT_LINE('Fail');
    END IF;
END;
--==>>
/*
Excellent


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/
/*
Good


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/
/*
Fail


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/



--※ 외부 입력 처리

-- 1. ACCEPT 문
-- ACCEPT 변수명 PROMPT '메세지';
-- 외부 변수로부터 입력받은 데이터를 내부 변수에 전달할 때
-- 『&외부변수명』형태로 접근하게 된다.

--○ 정수 2개를 외부로부터(사용자로부터) 입력받아
--  이들의 덧셈 연산 결과를 출력하는 PL/SQL 구문을 작성한다.

ACCEPT N1 PROMPT '첫 번째 정수를 입력하세요';
-- 사용자 입력시 N1이라는 변수에 정수값 산입
ACCEPT N2 PROMPT '두 번째 정수를 입력하세요';
-- 사용자 입력시 N2이라는 변수에 정수값 산입





DECLARE
    --선언부
    -- → 주요 변수 선언 및 초기화
    VNUM1    NUMBER := &N1;
    VNUM2    NUMBER := &N2;
    VRESULT  NUMBER := 0;
BEGIN
    --실행부
    -- → 연산 및 처리
    VRESULT := VNUM1 + VNUM2 ;
    
    -- → 결과출력
    DBMS_OUTPUT.PUT_LINE(VRESULT);
END;
--==>>
/*
300


PL/SQL 프로시저가 성공적으로 완료되었습니다
*/



--○ 사용자로부터 입력받은 금액을 화폐 단위로 출력하는 프로그램을 작성한다.
--  단, 반환 금액은 편의상 1천원 미만, 10원 이상만 가능하다고 가정한다.

/*
실행 예)
바인딩 변수 입력 대화창 → 금액 입력 : 990

입력받은 금액 총액 : 990원
화폐단위 : 오백원1, 백원 4, 오십원 1, 십원 4
*/


ACCEPT N1 PROMPT '금액을 입력하세요!' 



DECLARE
    V1 NUMBER := &N1;
    V2 NUMBER := 0;
    V3 NUMBER := 0;
    V4 NUMBER := 0;
    V5 NUMBER := 0;
BEGIN
    V2 := TRUNC(V1/500);                        --1(오백원)
    V3 := TRUNC((V1-500*V2)/100);               --4(백원)
    V4 := TRUNC(((V1-500*V2)-(100*V3))/50);
    V5 := TRUNC(((V1-500*V2)-(100*V3)-(50*V4))/10);
    
     IF  (V1 < 1000 AND V1 > 10)
        THEN DBMS_OUTPUT.PUT_LINE('총 금액은 : '|| V1);
     ELSE
        DBMS_OUTPUT.PUT_LINE('잘못입력하였습니다.');
    END IF;
    

    
    DBMS_OUTPUT.PUT_LINE('오백원 : '||V2);
    DBMS_OUTPUT.PUT_LINE('백원 : '||V3);
    DBMS_OUTPUT.PUT_LINE('오십원 : '||V4);
    DBMS_OUTPUT.PUT_LINE('십원 : '||V5);
    
END;




ACCEPT INPUT PROMPT '금액 입력';

DECLARE
        --○ 주요 변수 선언 및 초기화
        MONEWY  NUMBER := &INPUT;    -- 연산을 위해 담아둘 변수
        MONEWY2 NUMBER := &INPUT;    -- 출력을 위해 담아둘 변수(연산 과정에서 값이 변하기 떄문에...)
        M500    NUMBER;               -- 500원 짜리 갯수를 담아둘 변수
        M100    NUMBER;               -- 100원 짜리 갯수를 담아둘 변수
        M50     NUMBER;               -- 50원 짜리 갯수를 담아둘 변수
        M10     NUMBER;               -- 10원 짜리 갯수를 담아둘 변수
BEGIN
        --○ 연산 및 처리
        -- MONEY 를 500으로 나눠서 목을 취하고 나머지는 버린다. → 500원의 갯수
        M500 := TRUNC(MONEY/500);
        
        -- MONEY 를 500으로 나눠서 몫은 버리고 나머지는 취한다. → 500원의 갯수를 뺀 나머지
        MONEY := MOD(MOMEY,500);
        
        -- MONEY 를 100으로 나눠서 목을 취하고 나머지는 버린다. → 100원의 갯수
        M100 := TRUNC(MONEY/100);
        
        -- MONEY 를 100으로 나눠서 몫은 버리고 나머지는 취한다. → 100원의 갯수를 뺀 나머지
        MONEY := MOD(MOMEY,100);
        
        -- MONEY 를 50으로 나눠서 목을 취하고 나머지는 버린다. → 50원의 갯수
        M50 := TRUNC(MONEY/100);
        
        -- MONEY 를 50으로 나눠서 몫은 버리고 나머지는 취한다. → 50원의 갯수를 뺀 나머지
        MONEY := MOD(MOMEY,50);
        
        -- MONEY 를 10으로 나눠서 목을 취하고 나머지는 버린다. → 10원의 갯수
        M10 := TRUNC(MONEY/10);
        
        --○ 결과 출력
        
        DBMS_OUTPUT.PUT_LINE('입력받은 금액 총액 : ' || MONEY2 || '원');
        DBMS_OUTPUT.PUT_LINE('화페단위 : 오백원' || M500 ||
                                         ', 백원' || M100 ||
                                         ', 오십원' || M50 ||
                                         ', 십원' || M10);
        
        
END;







--○ 반복문
-- LOOP ~ END LOOP;

-- 1. 조건과 상관없이 무조건 반복하는 구문.

-- 2. 형식 및 구조
/*
LOOP
        -- 실행문;
        EXIT WHEN 조건;           -- 조건이 참인 경우 반복문을 빠져나간다.
END LOOP;
*/



--○ 1 부터 10까지의 수 출력(LOOP 문 활용)
DECLARE
    N NUMBER;
BEGIN
    N :=1;
    
    LOOP
        DBMS_OUTPUT.PUT_LINE(N);
        EXIT WHEN N>=10;
        N:= N + 1;                  --N++;      N+=1;
    END LOOP;
END;
--==>>
/*
1
2
3
4
5
6
7
8
9
10


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/

--○ WHILE 반복문
-- WILE LOOP ~ END LOOP;


-- 1. 제어 조건이 TRUE 인 동안 일련의 문장을 반복하기 위해
--   WHILE LOOP 문장을 사용한다.
--   조건은 반복이 시작될 때 체크하게 되어
--   LOOP 내의 문장이 한 번도 수행되지 않을 경우도 있다.
--   LOOP 시작할 때 조건이 FALSE 이면 반복 문장을 탈출하게 된다.


-- 2. 형식 및 구조
/*
WHILE LOOP
    -- 실행문;
END LOOP;
*/


--○ 1 부터 10까지의 수 출력 (WHILE LOOP 문 활용)

DECLARE
    N       NUMBER;
BEGIN
    N := 0;
    
    WHILE N<10 LOOP
        N:= N + 1;
        DBMS_OUTPUT.PUT_LINE(N);            -- 1 ~ 10 
    END LOOP;
END;
/*
1
2
3
4
5
6
7
8
9
10


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/



--○ FOR 반복문
-- FOR LOOP ~ END LOOP;

-- 1. 『시작 수』에서 1씩 증가하여
--    『끝냄 수』가 될 때 까지 반복 수행한다.

-- 2. 형식 및 구조
/*
FOR 카운터 [REVERSE ]IN 시작수 .. 끝냄수 LOOP   REVERSE 추가시 거꾸로 반복
        -- 실행문;
END LOOP;
*/


--○ 1부터 10까지의 수 출력(FOR LOOP 문 활용)
DECLARE
    N       NUMBER;
BEGIN
    FOR N IN 1 .. 10 LOOP
        DBMS_OUTPUT.PUT_LINE(N);
    END LOOP;
END;
/*
1
2
3
4
5
6
7
8
9
10


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/






--○ 사용자로부터 임의의 단(구구단)을 입력받아
--  해당 단수의 구구단을 출력하는 PL/SQL 구ㅡ문을 작성한다.
--  LOOP,WHILE LOOP, FOR LOOP 를 통해 해결한다.



ACCEPT INPUT PROMPT '구구단을 입력하시오';



DECLARE
    N       NUMBER;
    N2      NUMBER;
    RE      NUMBER;
BEGIN
    N := &INPUT;
    N2 := 0;
    RE := 0;
    
    LOOP
    EXIT WHEN N2>8;
    N2 := N2 + 1;
    RE := N * N2;
    DBMS_OUTPUT.PUT_LINE(N||'*'||N2||'='||RE);
    END LOOP;
END;




ACCEPT INPUT PROMPT '구구단을 입력하시오';


DECLARE
    N       NUMBER;
    N2      NUMBER;
    RE      NUMBER;
BEGIN
    N := &INPUT;
    N2 :=0;
    RE :=0;
    
    
    WHILE N2<9 LOOP
    N2 := N2 + 1;
    RE := N * N2;
    DBMS_OUTPUT.PUT_LINE(N ||'*' ||N2|| '=' ||RE);
    END LOOP;

END;






ACCEPT INPUT PROMPT '구구단을 입력하시오';

DECLARE
    N       NUMBER;
    N2      NUMBER;
    RE      NUMBER;
BEGIN
    N := &INPUT;
    N2 := 1;
    RE := 0;
    
    
        FOR N2 IN 1 .. 9 LOOP
        RE := N * N2;
        DBMS_OUTPUT.PUT_LINE(N ||' * '|| N2|| ' = '|| RE);
        END LOOP;


END;





























SELECT USER
FROM DUAL;
--==>> HR

SET SERVEROUTPUT ON;
--==>> 작업이 완료되었습니다.(0.031초)


--○ %TYPE

-- 1. 특정 테이블에 포함되어 있는 컬럼의 자료형을 참조하는 데이터타입

-- 2. 형식 및 구조
-- 변수명 데이터타입.컬럼명%TYPE [:= 초기값];

DESC EMPLOYEES;

--○ HR.EMPLOYEES 테이블의 특정 데이터를 변수에 저장하여 출력
DECLARE
    --VNAME       VARCHAR2(20);
    VNAME       EMPLOYEES.FIRST_NAME%TYPE;      --VARCHAR2(20)
BEGIN
    SELECT FIRST_NAME INTO VNAME
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID = 103;
    
    DBMS_OUTPUT.PUT_LINE(VNAME);
END;
/*
Alexander


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/



--○ %ROWTYPE

--1. 테이블의 레코드와 같은 구조의 구조체 변수를 선언(여러 개의 컬럼)

--2. 형식 및 구조
--  변수명 테이블명%ROWTYPE;

DESC EMPLOYEES;
--==>>
/*
이름             널?       유형           
-------------- -------- ------------ 
EMPLOYEE_ID    NOT NULL NUMBER(6)    
FIRST_NAME              VARCHAR2(20) 
LAST_NAME      NOT NULL VARCHAR2(25) 
EMAIL          NOT NULL VARCHAR2(25) 
PHONE_NUMBER            VARCHAR2(20) 
HIRE_DATE      NOT NULL DATE         
JOB_ID         NOT NULL VARCHAR2(10) 
SALARY                  NUMBER(8,2)  
COMMISSION_PCT          NUMBER(2,2)  
MANAGER_ID              NUMBER(6)    
DEPARTMENT_ID           NUMBER(4)    
*/


--○ HR.EMPLOYEES 테이블의 데이터 여러개를 변수에 저장하여 출력
DECLARE
    --VNAME           VARCHAR2(20);
    --VPHONE          VARCHAR2(20);
    --VEMAIL          VARCHAR2(25);
    
    
    --VNAME           EMPLOYEES.FIRST_NAME%TYPE;
    --VPHONE          EMPLOYEES.PHONE_NUMBER%TYPE;
    --VEMAIL          EMPLOYEES.EMAIL%TYPE;
    
    VEMP            EMPLOYEES%ROWTYPE;
BEGIN
    SELECT FIRST_NAME, PHONE_NUMBER, EMAIL 
      INTO VEMP.FIRST_NAME,VEMP.PHONE_NUMBER,VEMP.EMAIL
    FROM EMPLOYEES
    WHERE EMPLOYEE_ID=103;
    
    DBMS_OUTPUT.PUT_LINE(VEMP.FIRST_NAME || ' - ' || VEMP.PHONE_NUMBER || ' - ' || VEMP.EMAIL);
END;
--==>>
/*
Alexander - 590.423.4567 - AHUNOLD


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/



--○ HR.EMPLOYEES 테이블의 여러명 데이터 여러개를 변수에 저장하여 출력
DECLARE
    VEMP        EMPLOYEES%ROWTYPE;
BEGIN
    SELECT FIRST_NAME, PHONE_NUMBER,EMAIL
      INTO VEMP.FIRST_NAME, VEMP.PHONE_NUMBER, VEMP.EMAIL
    FROM EMPLOYEES;
    
    DBMS_OUTPUT.PUT_LINE(VEMP.FIRST_NAME || ' - ' || VEMP.PHONE_NUMBER || ' - ' || VEMP.EMAIL);
END;
--==>> 에러 발생 
/*
ORA-01422: exact fetch returns more than requested number of rows
ORA-06512: at line 4
01422. 00000 -  "exact fetch returns more than requested number of rows"
*Cause:    The number specified in exact fetch is less than the rows returned.
*Action:   Rewrite the query or change number of rows requested
*/
--> 여러 개의 행(ROWS) 정보를 얻어와서 담으려고 하면
--  변수에 저장하는 것 자체가 불가능한 상황...


-- 불가!!!














SELECT USER
FROM DUAL;
--==>> SCOTT


SET SERVEROUTPUT ON;
--==>> 작업이 완료되었습니다.

--○ SCOTT.TLB_INSA 테이블의 여러 명의 데이터 여러 개를 변수에 저장하여 출력
--   (단순 반복문 활용 출력)
DECLARE
    VINSA       TBL_INSA%ROWTYPE;
    VNUM        TBL_INSA.NUM%TYPE := 1001;
BEGIN

    LOOP
          SELECT NAME, TEL, BUSEO
          INTO VINSA.NAME, VINSA.TEL, VINSA.BUSEO
          FROM TBL_INSA
          WHERE NUM = VNUM;
        
          DBMS_OUTPUT.PUT_LINE(VINSA.NAME || ' - ' || VINSA.TEL || ' - ' || VINSA.BUSEO);
          
          EXIT WHEN VNUM >= 1060;
          
          VNUM := VNUM + 1;
    END LOOP;
END;

/*
홍길동 - 011-2356-4528 - 기획부
이순신 - 010-4758-6532 - 총무부
이순애 - 010-4231-1236 - 개발부

PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/


/*
홍길동 - 011-2356-4528 - 기획부
이순신 - 010-4758-6532 - 총무부
이순애 - 010-4231-1236 - 개발부
김정훈 - 019-5236-4221 - 영업부
한석봉 - 018-5211-3542 - 총무부
이기자 - 010-3214-5357 - 개발부
장인철 - 011-2345-2525 - 개발부
김영년 - 016-2222-4444 - 홍보부
나윤균 - 019-1111-2222 - 인사부
김종서 - 011-3214-5555 - 영업부
유관순 - 010-8888-4422 - 영업부
정한국 - 018-2222-4242 - 홍보부
조미숙 - 019-6666-4444 - 홍보부
황진이 - 010-3214-5467 - 개발부
이현숙 - 016-2548-3365 - 총무부
이상헌 - 010-4526-1234 - 개발부
엄용수 - 010-3254-2542 - 개발부
이성길 - 018-1333-3333 - 개발부
박문수 - 017-4747-4848 - 인사부
유영희 - 011-9595-8585 - 자재부
홍길남 - 011-9999-7575 - 개발부
이영숙 - 017-5214-5282 - 기획부
김인수 -  - 영업부
김말자 - 011-5248-7789 - 기획부
우재옥 - 010-4563-2587 - 영업부
김숙남 - 010-2112-5225 - 영업부
김영길 - 019-8523-1478 - 총무부
이남신 - 016-1818-4848 - 인사부
김말숙 - 016-3535-3636 - 총무부
정정해 - 019-6564-6752 - 총무부
지재환 - 019-5552-7511 - 기획부
심심해 - 016-8888-7474 - 자재부
김미나 - 011-2444-4444 - 영업부
이정석 - 011-3697-7412 - 기획부
정영희 -  - 개발부
이재영 - 011-9999-9999 - 자재부
최석규 - 011-7777-7777 - 홍보부
손인수 - 010-6542-7412 - 영업부
고순정 - 010-2587-7895 - 영업부
박세열 - 016-4444-7777 - 인사부
문길수 - 016-4444-5555 - 자재부
채정희 - 011-5125-5511 - 개발부
양미옥 - 016-8548-6547 - 영업부
지수환 - 011-5555-7548 - 영업부
홍원신 - 011-7777-7777 - 영업부
허경운 - 017-3333-3333 - 총무부
산마루 - 018-0505-0505 - 영업부
이기상 -  - 개발부
이미성 - 010-6654-8854 - 개발부
이미인 - 011-8585-5252 - 홍보부
권영미 - 011-5555-7548 - 영업부
권옥경 - 010-3644-5577 - 기획부
김싱식 - 011-7585-7474 - 자재부
정상호 - 016-1919-4242 - 홍보부
정한나 - 016-2424-4242 - 영업부
전용재 - 010-7549-8654 - 영업부
이미경 - 016-6542-7546 - 자재부
김신제 - 010-2415-5444 - 기획부
임수봉 - 011-4151-4154 - 개발부
김신애 - 011-4151-4444 - 개발부


PL/SQL 프로시저가 성공적으로 완료되었습니다.
*/
































SELECT USER
FROM DUAL;
--==>> SCOTT




--■■■ FUNCTION(함수) ■■■ --

-- 1. 함수란 하나 이상의 PL/SQL 문으로 구성된 서브루틴으로
--   코드를 다시 사용할 수 있도록 캡슐화 하는데 사용된다.
--   오라클에서는 오라클에 정의된 기본 제공 함수를 사용하거나
--   직접 스토어드 함수를 만들수 있다. (→ 사용자 정의 함수)
--   이 사용자 정의 함수는 시스템 함수처럼 쿼리에서 호출하거나
--   저장 프로시저 처럼 EXECUTE 문을 통해 실행할 수 있다.

--  2. 형식 및 구조
/*
CREATE [OR REPLACE] FUNCTION 함수명
[(

        매개변수1 자료형
     ,  매개변수2 자료형
)]
RETURN 데이터타입
IS
        -- 주요 변수 선언(지역 변수)
BEGIN
        -- 실행문;
        
        RETUNR 값;
        
        [EXCEPTION]
            -- 예외 처리 구문;
END;
*/


-- ※ 사용자 정의 함수(스토어드 함수)는
--    IN 파라미터(입력 매개변수)만 사용할 수 있으며
--   반드시 변환될 값의 데이터타입을 RETURN 문에 선언해야 하고,
--   FUNCTION 은 반드시 단일 값만 반환한다.

--TBL_INSA 테이블을 대상으로
-- 주민번호를 가지고 성별을 조회한다.


SELECT NAME,SSN,DECODE(SUBSTR(SSN,8,1),1,'남자',2,'여자','확인불가')"성별"
FROM TBL_INSA;



--○ FINCTION 정의(생성)
--  함수명 : FN_GENDER()
--                    ↑ SSN(주민등록번호) → 'YYMMDD-NNNNNNN'

CREATE OR REPLACE FUNCTION FN_GENDER
(
    VSSN    VARCHAR2
)
RETURN VARCHAR2
IS
        -- 주요 변수 선언
        VRESULT VARCHAR2(20);
BEGIN
        -- 연산 및 처리
        IF (SUBSTR(VSSN,8,1) IN ('1','3')) 
            THEN VRESULT := '남자';
        ELSIF  (SUBSTR(VSSN,8,1) IN ('2','4'))
            THEN VRESULT := '여자';
        ELSE
            VRESULT := '성별확인불가';
        END IF;
        
        -- 최종 결가괎 반환
        RETURN VRESULT;
END;
--==>>Function FN_GENDER이(가) 컴파일되었습니다.



--○ 임의의 정수 두 개를 매개변수(입력 파라미터)로 넘겨받아
--  A 의 B 승의 값을 반환하는 사용자 정의 함수를 만든다.
-- 함수명 : FN_POW()
/*
사용 예)
SELECT FN_POW(10,3) "결과확인"
FROM DUAL;
--==>> 1000

    FN_POW(10,3)
          ------
*/

CREATE OR REPLACE FUNCTION FN_POW
(
        A NUMBER                --10
       ,B NUMBER                --3
)
RETURN NUMBER
IS
    VRESULT NUMBER:=1;     --누적곱
    VNUM    NUMBER;
BEGIN

    FOR VNUM IN 1 .. B LOOP         -- 1 ~ 3
        VRESULT := VRESULT * A;     -- 1 * 10 * 10 * 10
    END LOOP;
    
    RETURN VRESULT;
END;











CREATE OR REPLACE FUNCTION FN_POW
(
    VNUM    NUMBER
   ,VNUM2   NUMBER
)
RETURN NUMBER
IS
    --주요 변수선언
    VRESULT NUMBER := 1;
    VNUM3   NUMBER := 1;
BEGIN
    --연산 및 처리
    LOOP
    EXIT WHEN VNUM2<VNUM3;
    VNUM3 := VNUM3 + 1;
    VRESULT := VRESULT * VNUM;
    --1          10   /  10*10
    END LOOP;
    
    --최종 결과값 반환
    RETURN VRESULT;
    
END;



CREATE OR REPLACE FUNCTION FN_POW
(
    VNUM    NUMBER
   ,VNUM2   NUMBER
)
RETURN NUMBER
IS
    --주요 변수선언
    VRESULT NUMBER := 1;
    VNUM3   NUMBER := 1;
BEGIN
    --연산 및 처리
    WHILE VNUM2<VNUM3 LOOP
    VNUM3 := VNUM3 + 1;
    VRESULT := VRESULT * VNUM;
    END LOOP;
    
    --최종 결과값 반환
    RETURN VRESULT;
    
END;



CREATE OR REPLACE FUNCTION FN_POW
(
    VNUM    NUMBER
   ,VNUM2   NUMBER
)
RETURN NUMBER
IS
    --주요 변수선언
    VRESULT NUMBER := 1;
    VNUM3   NUMBER := 1;
BEGIN
    --연산 및 처리
    FOR LOOP
    END LOOP;
    
    --최종 결과값 반환
    RETURN VRESULT;
    
END;






--○ TBL_INSA 테이블의 급여 계산 전용 함수를 정의한다.
--   급여는 (기본급*12)+수당 기반으로 연산을 수행한다.
--  함수명 : FN_PAY(기본급,수당)




CREATE OR REPLACE FUNCTION FN_PAY
(
  A NUMBER
, B NUMBER
)
RETURN NUMBER
IS
        --주요 변수 선언
        VRESULT  NUMBER;
BEGIN
        --주요 연산 및 처리
        VRESULT := (A*12)+B;
        
        --결과값 반환
        RETURN VRESULT;
END;




--○ TBL_INSA 테이블의 입사일을 기준으로
--  현재까지의 근무년수를 반환하는 함수를 정의한다.
--  단,근무년수는 소숫점 이하 한자리까지 계산한다.
-- 함수명 : FN_WORKYEAR(입사일)

CREATE OR REPLACE FUNCTION FN_WORKYEAR
(
    A   DATE
)
RETURN NUMBER
IS
        --주요 변수 정의
        VRESULT NUMBER :=0;
BEGIN
        --주요 연산 및 처리
        VRESULT := ROUND(MONTHS_BETWEEN(SYSDATE,A) /12,1);
        --ROUND(TO_CHAR(SYSDATE,'YYYY') - TO_NUMBER(SUBSTR(A,1,4)),1);
        
        --결과 반환
        RETURN VRESULT;
END;



--------------------------------------------------------------------------------


--※ 참고

-- 1. INSERT, UPDATE, DELETE, (MERGE)
-- → DML(Data Manipulation Language)
-- → COMMIT / ROLLBACK 이 필요하다

-- 2. CREATE,DROP,ALTER,(TRUNCATE)
-- → DDL(Data Definition Language)
-- → 실행하면 자동으로 COMMIT 된다.

-- 3. GRANT,REVOKE
-- → DCL(Data Control Language)
-- → 실행하면 자동으로 COMMIT 된다.

-- 4. COMMIT, ROLLBACK
-- → TCL(Transaction Contril Language)

-- 정적 PL/SQL문 → DML문,TCL문만 사용 가능하다.
-- 동적 PL/SQL문 → DML문, DDL문, DCL문, TCL문 사용 가능하다.

-- ※ 정적 SQL(정적 PL/SQL)
--> 기본적으로 사용하는 SQL 구문과
-- PL/SQL 구문 안에 SQL 구문을 직접 삽입하는 방법
--> 작성이 쉽고 성능이 좋다.

--※ 동적 SQL(동적 PL/SQL) → EXECUTE IMMEDIATE
--> 완성되지 않은 SQL 구문을 기반으로
-- 실행 중 변경 가능한 문자열 변수 또는 문자열 상수를 통해
-- SQL구문을 동적으로 완성하여 실행하는 방법
--> 사전에 정의되지 않은 SQL을 실행할 때 완성 및 확정하여 실행할 수 있다.
-- DML,TCL 외에도 DDL, DCL 사용이 가능하다.




-------------------------------------------------------------------------------

--■■■ PROCEDURE(프로시저) ■■■--

-- 1. PL/SQL 에서 가장 대표적인 구조인 스토어드 프로시저는
--    개발자가 자주 작성해야 하는 업무의 흐름을
--    미리 작성하여 데이터베이스 내에 저장해 두었다가
--    필요할 때 마다 호출하여 실행할 수 있도록  처리해 주는 구문이다.

-- 2. 형식 및 구조
/*
CREATE [OR REPLACE] PROCEUDRE 프로시저명
[( 매개변수 IN 데이터타입
,  매개변수 OUT 데이터타입
,  매개변수 INOUT 데이터타입
)]
IS
    [-- 주요 변수 선언;]
BEGIN
    -- 실행 구문;
    
    [EXCEPTION
            -- 예외 처리 구문;]
END;
*/


--※ FUNCTION 과 비교했을 때...
--  『RETURN 반환자료형』 부분이 존재하지 않으며,
--  『RETURN』문 자체도 존재하지 않으며,
--  프로시저 실행 시 넘겨주게 되는 매개변수의 종류는
--  IN, OUT, INOUT 으로 구분된다.

-- 3. 실행(호출)
/*
EXEC[UTE] 프로시저명[(인수1, 인수2)];
*/



--○ INSERT 프로시저

-- 실습 테이블 생성
-- 테이블명 : TBL_STUDENTS → 20241203_02_scott.sql 참조
-- 테이블명 : TBL_IDPW → 20241203_02_scott.sql 참조


-- 프로시저 생성
-- 프로시저명 : PRC_STUDENTS_INSERT('아이디','패스워드','이름','전화번호','주소')

CREATE OR REPLACE PROCEDURE PRC_STUDENTS_INSERT
( V_ID      IN TBL_IDPW.ID%TYPE
, V_PW      IN TBL_IDPW.PW%TYPE
, V_NAME    IN TBL_STUDENTS.NAME%TYPE
, V_TEL     IN TBL_STUDENTS.TEL%TYPE
, V_ADDR    IN TBL_STUDENTS.ADDR%TYPE
)
IS
BEGIN
    -- TBL_IDPW 테이블에 데이터 입력
    INSERT INTO TBL_IDPW(ID, PW)
    VALUES(V_ID, V_PW);
    
    -- TBL_STUDENTS 테이블에 데이터 입력
    INSERT INTO TBL_STUDENTS(ID, NAME, TEL, ADDR)
    VALUES(V_ID, V_NAME, V_TEL, V_ADDR);
    
    -- 커밋
    COMMIT;
END;
--==>> Procedure PRC_STUDENTS_INSERT이(가) 컴파일되었습니다.




--○ 데이터 입력 시 특정 항목의 데이터만 입력하면 
--   내부적으로 다른 항목이 함께 입력 처리될 수 있는 프로시저를 생성한다.
-- 프로시저명 : PRC_SUNGJUK_INSERT

-- 실습 테이블 생성
-- 테이블명 : TBL_SUNGJUK → 20241203_02_scott.sql 참조


/*
실행 예)
EXEC PRC_SUNGJUK_INSER(1, '이은솔',90,80,70);

→ 프로시저 호출로 처리된 결과
학번      이름      국어점수        영어점수        수학점수        총점      평균      등급
 1       이은솔       90               80              70            240       80        B
*/


CREATE OR REPLACE PROCEDURE PRC_SUNGJUK_INSERT
( V_HAK     IN TBL_SUNGJUK.HAKBUN%TYPE
, V_NAME    IN TBL_SUNGJUK.NAME%TYPE
, V_KOR     IN TBL_SUNGJUK.KOR%TYPE
, V_ENG     IN TBL_SUNGJUK.ENG%TYPE
, V_MAT     IN TBL_SUNGJUK.MAT%TYPE
)
IS
V_TOT     TBL_SUNGJUK.TOT%TYPE:=0;
V_AVG     TBL_SUNGJUK.AVG%TYPE:=0;
V_GRADE   TBL_SUNGJUK.GRADE%TYPE:=0;
BEGIN


    V_TOT := V_KOR + V_ENG + V_MAT;
    V_AVG := V_TOT / 3;
    
    
    
    IF V_AVG >= 90
        THEN V_GRADE :='A';
    ELSIF V_AVG >= 80
        THEN V_GRADE :='B';
    ELSIF V_AVG >= 70
        THEN V_GRADE :='C';
    ELSE V_GRADE :='D';
    END IF;
    
    

    -- TBL_SUNGJUK 테이블에 입력
    INSERT INTO TBL_SUNGJUK(HAKBUN,NAME,KOR,ENG,MAT,TOT,AVG,GRADE)
    VALUES(V_HAK,V_NAME,V_KOR,V_ENG,V_MAT,V_TOT,V_AVG,V_GRADE);
    
    COMMIT;
END;




--○ TBL_SUNGJUK 테이블에서
--  특정 학생의 점수(학번,국어점수,영어점수,수학점수)
--  데이터 수정 시 총점, 평균, 등급까지 수정하는 프로시저를 작성한다.
-- 프로시저명 : PRC_SUNGJUK_UPDATE
/*
실행 예)
EXEC PRC_SUNGJUK_UPDATE(2,50,50,50);




→ 프로시저 호출로 처리된 결과
학번      이름      국어점수        영어점수        수학점수        총점      평균      등급
 1       이은솔       90               80              70            240       80        B
 3       윤영식       50               50              50            150       50        F
*/



CREATE OR REPLACE PROCEDURE PRC_SUNGJUK_UPDATE
( V_HAKBUN      IN TBL_SUNGJUK.HAKBUN%TYPE
, V_KOR         IN TBL_SUNGJUK.KOR%TYPE
, V_ENG         IN TBL_SUNGJUK.ENG%TYPE
, V_MAT         IN TBL_SUNGJUK.MAT%TYPE
)
IS
 V_TOT    TBL_SUNGJUK.TOT%TYPE;
 V_AVG    TBL_SUNGJUK.AVG%TYPE;
 V_GRADE  TBL_SUNGJUK.GRADE%TYPE;
BEGIN
        --주요 연산 처리
        
        V_TOT := V_KOR + V_ENG + V_MAT;
        V_AVG := V_TOT / 3;
        
         IF V_AVG >= 90
        THEN V_GRADE :='A';
        ELSIF V_AVG >= 80
        THEN V_GRADE :='B';
        ELSIF V_AVG >= 70
        THEN V_GRADE :='C';
        ELSE V_GRADE :='D';
        END IF;
        
        
        UPDATE TBL_SUNGJUK
        SET KOR = V_KOR, ENG = V_ENG, MAT = V_MAT, TOT = V_TOT, AVG = V_AVG, GRADE = V_GRADE
        WHERE HAKBUN=V_HAKBUN;

        COMMIT;

END;



--○ TBL_STUDENTS 테이블에서
--   전화번호와 주소 데이터를 수정하는(변경하는) 프로시저를 작성한다.
--   단, ID 와 PW가 일치하는 경우에만 수정을 진행할 수 있도록 처리한다.
--   프로시저명 : PRC_STUDENT_UPDATE
/*
실행 예)
EXEC PRC_STUDENT_UPDATE('superman','java007$','010-1212-3434','인천 서구');

→ 프로시저로 처리된 결과
superman	정영훈	010-1111-1111	제주도 서귀포시

EXEC PRC_STUDENT_UPDATE('superman','java007$','010-1212-3434','인천 서구');

superman	정영훈	010-1212-3434	인천 서구
*/


CREATE OR REPLACE PROCEDURE PRC_STUDENTS_UPDATE
( V_ID           IN TBL_STUDENTS.ID%TYPE
, V_PW           IN TBL_IDPW.PW%TYPE
, V_TEL          IN TBL_STUDENTS.TEL%TYPE
, V_ADDR         IN TBL_STUDENTS.ADDR%TYPE
)
IS
BEGIN
    UPDATE (SELECT I.ID, I.PW, S.TEL, S.ADDR
            FROM TBL_STUDENTS S JOIN TBL_IDPW I
            ON S.ID=I.ID)T
    SET T.ADDR=V_ADDR, T.TEL=V_TEL
    WHERE T.ID = V_ID AND T.PW = V_PW;
END;





--○ TBL_INSA 테이블을 대상으로 신규 데이터 입력 프로시저를 작성한다.
--  NUM,NAME,SSN,IBSADATE,CITY,TEL,BUSEO,JIKWI,BASICPAY,SUDANG
--  구조를 갖고 있는 대상 테이블에 데이터 입력 시
--  NUM 항목(사원번호)의 값은
--  기존 부여된 사원번호 마지막 번호의 그 다음 번호를
--  자동으로 입력 처리할 수 있는 프로시저로 구성한다.
--  프로시저명 : PRC_INSA_INSERT(NAME,SSN,IBSADATE,CITY,TEL,BUSEO,JIKWI,BASICPAY,SUDANG);



/*
실행 예)
EXEC PRC_INSA_INSERT(안예지,980716-2234567,SYSDATE,'서울',010-55555-55555,'영업부','대리',5000000,5000000);

→ 프로시저 호출로 처리된 결과
1061 안예지,980716-2234567,2024-12-03,'서울',010-55555-55555,'영업부','대리',5000000,5000000
*/



CREATE OR REPLACE PROCEDURE PRC_INSA_INSERT
( QNAME      IN     TBL_INSA.NAME%TYPE
, QSSN       IN     TBL_INSA.SSN%TYPE
, QIBSADATE  IN     TBL_INSA.IBSADATE%TYPE
, QCITY      IN     TBL_INSA.CITY%TYPE
, QTEL       IN     TBL_INSA.TEL%TYPE
, QBUSEO     IN     TBL_INSA.BUSEO%TYPE
, QJIKWI     IN     TBL_INSA.JIKWI%TYPE
, QBASICPAY  IN     TBL_INSA.BASICPAY%TYPE
, QSUDANG    IN     TBL_INSA.SUDANG%TYPE
)
IS
QNUM   TBL_INSA.NUM%TYPE;
BEGIN

        SELECT MAX(NUM)+1 INTO QNUM
        FROM TBL_INSA;
        
        INSERT INTO TBL_INSA(NUM,NAME,SSN,IBSADATE,CITY,TEL,BUSEO,JIKWI,BASICPAY,SUDANG)
        VALUES(QNUM,QNAME,QSSN,QIBSADATE,QCITY,QTEL,QBUSEO,QJIKWI,QBASICPAY,QSUDANG);
        
        COMMIT;
END;
--==>>Procedure PRC_INSA_INSERT이(가) 컴파일되었습니다.





-- 실습 테이블 생성
-- 테이블명 : TBL_상품 → 20241203_02_scott.sql 참조
-- 테이블명 : TBL_입고 → 20241203_02_scott.sql 참조


--○ TBL_상품, TBL_입고 테이블을 대상으로
--   TBL_입고 테이블에 데이터 입력 시 (즉, 입고 이벤트 발생 시)
--   TBL_상품 테이블 해당 상품의 재고수량이 함께 변동될 수 있는 기능을 가진
--   프로시저를 작성한다.
--   단, 이 과정에서 입고번호는 자동 증가 처리한다. (시퀀스 사용 Ⅹ)
--   TBL_입고 테이블 구성 컬럼
--   → 입고번호, 상품코드, 입고일자, 입고수량, 입고단가
--  프로시저명 : PRC_입고_INSERT(상품코드,입고수량,입고단가)


CREATE OR REPLACE PROCEDURE PRC_입고_INSERT
(W_상품코드      IN   TBL_상품.상품코드%TYPE
,W_입고수량      IN   TBL_입고.입고수량%TYPE
,W_입고단가      IN   TBL_입고.입고단가%TYPE
)
IS
W_입고번호  TBL_입고.입고번호%TYPE;
BEGIN


INSERT INTO TBL_입고(입고번호,상품코드,입고수량,입고단가)
VALUES(W_입고번호,W_상품코드,W_입고수량,W_입고단가);

END;





















































































SELECT USER
FROM DUAL;
--==>>SCOTT

SELECT *
FROM TBL_INSA;
--==>>
/*
1001	홍길동	771212-1022432	1998-10-11	서울	011-2356-4528	기획부	부장	2610000	200000
1002	이순신	801007-1544236	2000-11-29	경기	010-4758-6532	총무부	사원	1320000	200000
1003	이순애	770922-2312547	1999-02-25	인천	010-4231-1236	개발부	부장	2550000	160000
1004	김정훈	790304-1788896	2000-10-01	전북	019-5236-4221	영업부	대리	1954200	170000
1005	한석봉	811112-1566789	2004-08-13	서울	018-5211-3542	총무부	사원	1420000	160000
1006	이기자	780505-2978541	2002-02-11	인천	010-3214-5357	개발부	과장	2265000	150000
1007	장인철	780506-1625148	1998-03-16	제주	011-2345-2525	개발부	대리	1250000	150000
1008	김영년	821011-2362514	2002-04-30	서울	016-2222-4444	홍보부	사원	950000	145000
1009	나윤균	810810-1552147	2003-10-10	경기	019-1111-2222	인사부	사원	840000	220400
1010	김종서	751010-1122233	1997-08-08	부산	011-3214-5555	영업부	부장	2540000	130000
1011	유관순	801010-2987897	2000-07-07	서울	010-8888-4422	영업부	사원	1020000	140000
1012	정한국	760909-1333333	1999-10-16	강원	018-2222-4242	홍보부	사원	880000	114000
1013	조미숙	790102-2777777	1998-06-07	경기	019-6666-4444	홍보부	대리	1601000	103000
1014	황진이	810707-2574812	2002-02-15	인천	010-3214-5467	개발부	사원	1100000	130000
1015	이현숙	800606-2954687	1999-07-26	경기	016-2548-3365	총무부	사원	1050000	104000
1016	이상헌	781010-1666678	2001-11-29	경기	010-4526-1234	개발부	과장	2350000	150000
1017	엄용수	820507-1452365	2000-08-28	인천	010-3254-2542	개발부	사원	950000	210000
1018	이성길	801028-1849534	2004-08-08	전북	018-1333-3333	개발부	사원	880000	123000
1019	박문수	780710-1985632	1999-12-10	서울	017-4747-4848	인사부	과장	2300000	165000
1020	유영희	800304-2741258	2003-10-10	전남	011-9595-8585	자재부	사원	880000	140000
1021	홍길남	801010-1111111	2001-09-07	경기	011-9999-7575	개발부	사원	875000	120000
1022	이영숙	800501-2312456	2003-02-25	전남	017-5214-5282	기획부	대리	1960000	180000
1023	김인수	731211-1214576	1995-02-23	서울		            영업부	부장	2500000	170000
1024	김말자	830225-2633334	1999-08-28	서울	011-5248-7789	기획부	대리	1900000	170000
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000
1026	김숙남	810907-2015457	2002-08-28	경기	010-2112-5225	영업부	사원	1050000	150000
1027	김영길	801216-1898752	2000-10-18	서울	019-8523-1478	총무부	과장	2340000	170000
1028	이남신	810101-1010101	2001-09-07	제주	016-1818-4848	인사부	사원	892000	110000
1029	김말숙	800301-2020202	2000-09-08	서울	016-3535-3636	총무부	사원	920000	124000
1030	정정해	790210-2101010	1999-10-17	부산	019-6564-6752	총무부	과장	2304000	124000
1031	지재환	771115-1687988	2001-01-21	서울	019-5552-7511	기획부	부장	2450000	160000
1032	심심해	810206-2222222	2000-05-05	전북	016-8888-7474	자재부	사원	880000	108000
1033	김미나	780505-2999999	1998-06-07	서울	011-2444-4444	영업부	사원	1020000	104000
1034	이정석	820505-1325468	2005-09-26	경기	011-3697-7412	기획부	사원	1100000	160000
1035	정영희	831010-2153252	2002-05-16	인천		            개발부	사원	1050000	140000
1036	이재영	701126-2852147	2003-08-10	서울	011-9999-9999	자재부	사원	960400	190000
1037	최석규	770129-1456987	1998-10-15	인천	011-7777-7777	홍보부	과장	2350000	187000
1038	손인수	791009-2321456	1999-11-15	부산	010-6542-7412	영업부	대리	2000000	150000
1039	고순정	800504-2000032	2003-12-28	경기	010-2587-7895	영업부	대리	2010000	160000
1040	박세열	790509-1635214	2000-09-10	경북	016-4444-7777	인사부	대리	2100000	130000
1041	문길수	721217-1951357	2001-12-10	충남	016-4444-5555	자재부	과장	2300000	150000
1042	채정희	810709-2000054	2003-10-17	경기	011-5125-5511	개발부	사원	1020000	200000
1043	양미옥	830504-2471523	2003-09-24	서울	016-8548-6547	영업부	사원	1100000	210000
1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000
1045	홍원신	690906-1985214	2003-03-16	전북	011-7777-7777	영업부	사원	960000	152000
1046	허경운	760105-1458752	1999-05-04	경남	017-3333-3333	총무부	부장	2650000	150000
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000
1048	이기상	790604-1415141	2001-06-07	전남		            개발부	대리	2050000	106000
1049	이미성	830908-2456548	2000-04-07	인천	010-6654-8854	개발부	사원	1300000	130000
1050	이미인	810403-2828287	2003-06-07	경기	011-8585-5252	홍보부	대리	1950000	103000
1051	권영미	790303-2155554	2000-06-04	서울	011-5555-7548	영업부	과장	2260000	104000
1052	권옥경	820406-2000456	2000-10-10	경기	010-3644-5577	기획부	사원	1020000	105000
1053	김싱식	800715-1313131	1999-12-12	전북	011-7585-7474	자재부	사원	960000	108000
1054	정상호	810705-1212141	1999-10-16	강원	016-1919-4242	홍보부	사원	980000	114000
1055	정한나	820506-2425153	2004-06-07	서울	016-2424-4242	영업부	사원	1000000	104000
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000
1057	이미경	780406-2003214	1998-02-11	경기	016-6542-7546	자재부	부장	2520000	160000
1058	김신제	800709-1321456	2003-08-08	인천	010-2415-5444	기획부	대리	1950000	180000
1059	임수봉	810809-2121244	2001-10-10	서울	011-4151-4154	개발부	사원	890000	102000
1060	김신애	810809-2111111	2001-10-10	서울	011-4151-4444	개발부	사원	900000	102000
*/


--○ 생성한 함수(FN_GENDER()) 가 제대로 작동하는지의 여부 확인

SELECT '751212-1234567' "주민번호"
        , FN_GENDER('751212-1234567')"성별확인"
FROM DUAL;
--==>>751212-1234567	남자


SELECT NAME, SSN, FN_GENDER(SSN) "함수호출결과"
FROM TBL_INSA;
--==>>
/*
홍길동	771212-1022432	남자
이순신	801007-1544236	남자
이순애	770922-2312547	여자
김정훈	790304-1788896	남자
한석봉	811112-1566789	남자
이기자	780505-2978541	여자
장인철	780506-1625148	남자
김영년	821011-2362514	여자
나윤균	810810-1552147	남자
김종서	751010-1122233	남자
유관순	801010-2987897	여자
정한국	760909-1333333	남자
조미숙	790102-2777777	여자
황진이	810707-2574812	여자
이현숙	800606-2954687	여자
이상헌	781010-1666678	남자
엄용수	820507-1452365	남자
이성길	801028-1849534	남자
박문수	780710-1985632	남자
유영희	800304-2741258	여자
홍길남	801010-1111111	남자
이영숙	800501-2312456	여자
김인수	731211-1214576	남자
김말자	830225-2633334	여자
우재옥	801103-1654442	남자
김숙남	810907-2015457	여자
김영길	801216-1898752	남자
이남신	810101-1010101	남자
김말숙	800301-2020202	여자
정정해	790210-2101010	여자
지재환	771115-1687988	남자
심심해	810206-2222222	여자
김미나	780505-2999999	여자
이정석	820505-1325468	남자
정영희	831010-2153252	여자
이재영	701126-2852147	여자
최석규	770129-1456987	남자
손인수	791009-2321456	여자
고순정	800504-2000032	여자
박세열	790509-1635214	남자
문길수	721217-1951357	남자
채정희	810709-2000054	여자
양미옥	830504-2471523	여자
지수환	820305-1475286	남자
홍원신	690906-1985214	남자
허경운	760105-1458752	남자
산마루	780505-1234567	남자
이기상	790604-1415141	남자
이미성	830908-2456548	여자
이미인	810403-2828287	여자
권영미	790303-2155554	여자
권옥경	820406-2000456	여자
김싱식	800715-1313131	남자
정상호	810705-1212141	남자
정한나	820506-2425153	여자
전용재	800605-1456987	남자
이미경	780406-2003214	여자
김신제	800709-1321456	남자
임수봉	810809-2121244	여자
김신애	810809-2111111	여자
*/



--○ 생성한 함수(FN_POW())가 제대로 작동하는지의 여부 확인
SELECT FN_POW(10,3)"결과확인"
FROM DUAL;
--==>> 1000

SELECT FN_POW(5,3)"결과확인"
FROM DUAL;
--==>> 125


SELECT NAME,BASICPAY,FN_POW(BASICPAY,2)"기본급제곱"
FROM TBL_INSA;
--==>>
/*
홍길동	2610000	6812100000000
이순신	1320000	1742400000000
이순애	2550000	6502500000000
김정훈	1954200	3818897640000
한석봉	1420000	2016400000000
이기자	2265000	5130225000000
장인철	1250000	1562500000000
김영년	950000	902500000000
나윤균	840000	705600000000
김종서	2540000	6451600000000
유관순	1020000	1040400000000
정한국	880000	774400000000
조미숙	1601000	2563201000000
황진이	1100000	1210000000000
이현숙	1050000	1102500000000
이상헌	2350000	5522500000000
엄용수	950000	902500000000
이성길	880000	774400000000
박문수	2300000	5290000000000
유영희	880000	774400000000
홍길남	875000	765625000000
이영숙	1960000	3841600000000
김인수	2500000	6250000000000
김말자	1900000	3610000000000
우재옥	1100000	1210000000000
김숙남	1050000	1102500000000
김영길	2340000	5475600000000
이남신	892000	795664000000
김말숙	920000	846400000000
정정해	2304000	5308416000000
지재환	2450000	6002500000000
심심해	880000	774400000000
김미나	1020000	1040400000000
이정석	1100000	1210000000000
정영희	1050000	1102500000000
이재영	960400	922368160000
최석규	2350000	5522500000000
손인수	2000000	4000000000000
고순정	2010000	4040100000000
박세열	2100000	4410000000000
문길수	2300000	5290000000000
채정희	1020000	1040400000000
양미옥	1100000	1210000000000
지수환	1060000	1123600000000
홍원신	960000	921600000000
허경운	2650000	7022500000000
산마루	2100000	4410000000000
이기상	2050000	4202500000000
이미성	1300000	1690000000000
이미인	1950000	3802500000000
권영미	2260000	5107600000000
권옥경	1020000	1040400000000
김싱식	960000	921600000000
정상호	980000	960400000000
정한나	1000000	1000000000000
전용재	1950000	3802500000000
이미경	2520000	6350400000000
김신제	1950000	3802500000000
임수봉	890000	792100000000
김신애	900000	810000000000
*/



--○ INSERT 프로시저 실습을 위한 테이블 생성
-- 테이블명 : TBL_STUDENTS

CREATE TABLE TBL_STUDENTS
( ID        VARCHAR2(10)
, NAME      VARCHAR2(40)
, TEL       VARCHAR2(20)
, ADDR      VARCHAR2(100)
, CONSTRAINT STUDENTS_ID_PK PRIMARY KEY(ID)
);
--==>>Table TBL_STUDENTS이(가) 생성되었습니다.

-- 테이블명 : TBL_IDPW
CREATE TABLE TBL_IDPW
( ID    VARCHAR2(10)
, PW    VARCHAR2(20)
, CONSTRAINT IDPW_ID_PK PRIMARY KEY(ID)
);
--==>> Table TBL_IDPW이(가) 생성되었습니다.

-- 한 명의 학생 정보 등록 → 두 테이블에 데이터 입력
INSERT INTO TBL_STUDENTS(ID,NAME,TEL,ADDR)
VALUES('superman','정영훈','010-1111-1111','제주도 서귀포시');
--==>> 1 행 이(가) 삽입되었습니다.
INSERT INTO TBL_IDPW(ID,PW)
VALUES('superman','java006$');
--==>> 1 행 이(가) 삽입되었습니다.

SELECT *
FROM TBL_STUDENTS;
--==>>superman	정영훈	010-1111-1111	제주도 서귀포시

SELECT *
FROM TBL_IDPW;
--==>>superman	java006$


--※ 위의 업무를 프로시저(INSERT 프로시저, 입력 프로시저)를 생성하여 처리하게 되면...
EXEC PRC_STUDENTS_INSERT('happyday','java006$','곽유진','010-2222-2222','서울 마포구');
-- 이와 같은 구문 한 줄로 양쪽 테이블에 데이터를 모두 제대로 입력할 수 있다.


--○ 생성한 프로시저(PRC_STUDENTS_INSERT)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
EXEC PRC_STUDENTS_INSERT('happyday','java006$','곽유진','010-2222-2222','서울 마포구');



SELECT *
FROM TBL_STUDENTS;
--==>>
/*
superman	정영훈	010-1111-1111	제주도 서귀포시
happyday	곽유진	010-2222-2222	서울 마포구
*/

SELECT *
FROM TBL_IDPW;
--==>>
/*
superman	java006$
happyday	java006$
*/


--○ 생성한 프로시저(PRC_STUDENTS_INSERT)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
EXEC PRC_STUDENTS_INSERT('happytest','java006$','엄서연','010-3333-3333','서울 종로구');


SELECT *
FROM TBL_STUDENTS;
/*
superman	정영훈	010-1111-1111	제주도 서귀포시
happyday	곽유진	010-2222-2222	서울 마포구
happytest	엄서연	010-3333-3333	서울 종로구
*/

SELECT *
FROM TBL_IDPW;
/*
superman	java006$
happyday	java006$
happytest	java006$
*/





--○ INSERT 프로시저 실습을 위한 테이블 생성
-- 테이블명 : TBL_SUNGJUK
CREATE TABLE TBL_SUNGJUK
( HAKBUN    NUMBER
, NAME      VARCHAR2(40)
, KOR       NUMBER(3)
, ENG       NUMBER(3)
, MAT       NUMBER(3)
, CONSTRAINT SUNGJUK_HAKBUN_PK  PRIMARY KEY(HAKBUN)
);
--==>> Table TBL_SUNGJUK이(가) 생성되었습니다.
-- 학번, 이름, 국어점수, 영어점수, 수학점수 데이터를
-- 입력받을 수 있는 실습 테이블 생성

-- 생성된 테이블에 컬럼 구조 추가
-- (총점→TOT, 평균→AVG, 등급→GRADE)
ALTER TABLE TBL_SUNGJUK
ADD (TOT NUMBER(3), AVG NUMBER(4,1), GRADE CHAR);
--==>>> Table TBL_SUNGJUK이(가) 변경되었습니다.


--※ 여기에서 추가한 컬럼에 대한 항목들은
--   프로시저 실습을 위해 추가하는 것일 뿐
--   실제 테이블 구조에 적합하지도, 바람직하지도 않은 내용이다.


-- 변경된 테이블 구조 확인
DESC TBL_SUNGJUK;
--==>>
/*
이름     널?       유형           
------ -------- ------------ 
HAKBUN NOT NULL NUMBER       
NAME            VARCHAR2(40) 
KOR             NUMBER(3)    
ENG             NUMBER(3)    
MAT             NUMBER(3)    
TOT             NUMBER(3)    
AVG             NUMBER(4,1)  
GRADE           CHAR(1)      

*/

--○ 생성한 프로시저(PRC_SUNGJUK_INSERT)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
EXEC PRC_SUNGJUK_INSERT(2, '이은솔',90,80,70);
--==>>PL/SQL 프로시저가 성공적으로 완료되었습니다.
/*
1	이은솔	90	80	70	240	80	C
2	이은솔	90	80	70	240	80	B
*/

EXEC PRC_SUNGJUK_INSERT(3, '윤영식',87,96,73);
--==>>
/*
1	이은솔	90	80	70	240	80	C
2	이은솔	90	80	70	240	80	B
3	윤영식	87	96	73	256	85.3	B
*/

SELECT *
FROM TBL_SUNGJUK;

EXEC PRC_SUNGJUK_UPDATE(2,50,50,50);

SELECT *
FROM TBL_SUNGJUK;
--==>>
/*
1	이은솔	90	80	70	240	80	    C
2	이은솔	50	50	50	150	50	    D
3	윤영식	87	96	73	256	85.3	B
*/


EXEC PRC_SUNGJUK_UPDATE(2,92,93,94);

/*
1	이은솔	90	80	70	240	80	    C
2	이은솔	92	93	94	279	93	    A
3	윤영식	87	96	73	256	85.3	B
*/





--○ 생성한 프로시저(PRC_STUDENTS_UPDATE)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
EXEC PRC_STUDENTS_UPDATE('superman','java006$','010-1212-3434','인천 서구');
--==>>PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_STUDENTS;
--==>>
/*
superman	정영훈	010-1212-3434	인천 서구
happyday	곽유진	010-2222-2222	서울 마포구
happytest	엄서연	010-3333-3333	서울 종로구
*/


EXEC PRC_STUDENTS_UPDATE('superman','java007$','010-1212-3434','인천 서구');

SELECT *
FROM TBL_STUDENTS;

--==>> PW가 맞지않을시 업데이트 되지않는것 확인











EXEC PRC_INSA_INSERT('안예지','980716-2234567',SYSDATE,'서울','010-55555-55555','영업부','대리',5000000,5000000);
--==>>PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_INSA;

--------------------------------------------------------------------------------


--○ 실습 테이블 생성
-- 테이블명 : TBL_상품
CREATE TABLE TBL_상품
( 상품코드          VARCHAR2(20)
, 상품명            VARCHAR2(100)
, 소비자가격        NUMBER
, 재고수량          NUMBER DEFAULT 0
, CONSTRAINT 상품_상품코드_PK PRIMARY KEY(상품코드)
);
--==>> Table TBL_상품이(가) 생성되었습니다.
-- TBL_상품 테이블의 상품코드를 기본키(PK) 제약조건 설정

--○ 실습 테이블
-- 테이블명 : TBL_입고
CREATE TABLE TBL_입고
( 입고번호  NUMBER
, 상품코드  VARCHAR2(20)
, 입고일자  DATE    DEFAULT SYSDATE
, 입고수량  NUMBER
, 입고단가  NUMBER
, CONSTRAINT 입고_입고번호_PK PRIMARY KEY(입고번호)
, CONSTRAINT 입고_상품코드_FK FOREIGN KEY(상품코드)
             REFERENCES TBL_상품(상품코드)
);


--TBL_입고 테이블의 입고번호를 기본키(PK) 제약조건 설정
--TBL_입고 테이블의 상품코드는 TBL_상품 테이블의 상품코드를
-- 참조할 수 있도록 외래키(FK) 제약조건 설정


--○ 데이터 입력 → TBL_상품 → 상품 등록
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('H001','홈런볼',1500);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('H002','새우깡',1200);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('H003','스윙칩',1000);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('H004','치토스',1100);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('H005','밭두렁',1000);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('H006','오감자',2000);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('H007','양파링',1700);
--==>> 1 행 이(가) 삽입되었습니다. * 7


INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('C001','초코칩',1800);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('C002','버터링',1900);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('C003','에이스',1700);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('C004','오레오',2200);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('C005','다이제',2500);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('C006','아이비',1200);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('C007','아이비',3500);
--==>> 1 행 이(가) 삽입되었습니다.


INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('E001','마이쮸',1000);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('E002','엠엔엠',1100);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('E003','아이셔',1100);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('E004','비틀즈',1200);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('E005','아폴로',1000);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('E006','새콤달',1500);
INSERT INTO TBL_상품(상품코드,상품명,소비자가격)
VALUES('E007','말랑카',1600);
--==>> 1 행 이(가) 삽입되었습니다.



--○ 확인
SELECT *
FROM TBL_상품;
--==>>
/*
H001	홈런볼	1500	0
H002	새우깡	1200	0
H003	스윙칩	1000	0
H004	치토스	1100	0
H005	밭두렁	1000	0
H006	오감자	2000	0
H007	양파링	1700	0
C001	초코칩	1800	0
C002	버터링	1900	0
C003	에이스	1700	0
C004	오레오	2200	0
C005	다이제	2500	0
C006	아이비	1200	0
C007	오예스	3500	0
E001	마이쮸	1000	0
E002	엠엔엠	1100	0
E003	아이셔	1100	0
E004	비틀즈	1200	0
E005	아폴로	1000	0
E006	새콤달	1500	0
E007	말랑카	1600	0
*/
 

COMMIT;


SELECT *
FROM TBL_입고;
















SELECT USER
FROM DUAL;
--==>> SCOTT




-- 실습 테이블 생성
-- 테이블명 : TBL_상품 → 20241203_02_scott.sql 참조
-- 테이블명 : TBL_입고 → 20241203_02_scott.sql 참조


--○ TBL_상품, TBL_입고 테이블을 대상으로
--   TBL_입고 테이블에 데이터 입력 시 (즉, 입고 이벤트 발생 시)
--   TBL_상품 테이블 해당 상품의 재고수량이 함께 변동될 수 있는 기능을 가진
--   프로시저를 작성한다.
--   단, 이 과정에서 입고번호는 자동 증가 처리한다. (시퀀스 사용 Ⅹ)
--   TBL_입고 테이블 구성 컬럼
--   → 입고번호, 상품코드, 입고일자, 입고수량, 입고단가
--  프로시저명 : PRC_입고_INSERT(상품코드,입고수량,입고단가)

-- 내가 한 풀이-----------------------------------------------------------------

CREATE OR REPLACE PROCEDURE PRC_입고_INSERT
(W_상품코드      IN   TBL_입고.상품코드%TYPE
,W_입고수량      IN   TBL_입고.입고수량%TYPE
,W_입고단가      IN   TBL_입고.입고단가%TYPE
)
IS
W_입고번호  TBL_입고.입고번호%TYPE;
BEGIN

SELECT NVL(MAX(입고번호),0) + 1 INTO W_입고번호
FROM TBL_입고;

INSERT INTO TBL_입고(입고번호,상품코드,입고수량,입고단가)
VALUES(W_입고번호,W_상품코드,W_입고수량,W_입고단가);

UPDATE TBL_상품
SET TBL_상품.재고수량 = W_입고수량 + TBL_상품.재고수량
WHERE TBL_상품.상품코드 = W_상품코드;


END;

-------------------------------------------------------------------------------

--※ TBL_입고 테이블에 입고 이벤트 발생 시...
--   관련 테이블에서 수행되어야 하는 내용
--   ① INSERT → TBL_입고
--      INSERT INTO TBL_입고(입고번호, 상품코드, 입고일자, 입고수량, 입고단가)
--      VALUES(1, 'H001',SYSDATE,20,1000)
--   ② UPDATE → TBL_상품
--      UPDATE TBL_상품
--      SET 재고수량 = 기존재고수량 + 20(→ 입고수량)
--      WHERE 상품코드 ='H001';

CREATE OR REPLACE PROCEDURE PRC_입고_INSERT
( V_상품코드      IN TBL_상품.상품코드%TYPE
, V_입고수량      IN TBL_입고.입고수량%TYPE
, V_입고단가      IN TBL_입고.입고단가%TYPE
)
IS
        -- 아래의 쿼리문을 수행하기 위해 필요한 데이터 변수로 추가 선언
        V_입고번호  TBL_입고.입고번호%TYPE;
BEGIN

            -- 선언한 변수(V_입고번호)에 값 담아내기
            SELECT NVL(MAX(입고번호),0) INTO V_입고번호
            FROM TBL_입고;

            -- 쿼리문 구성
            
            --① INSERT → TBL_입고
        INSERT INTO TBL_입고(입고번호,상품코드,입고수량, 입고단가)
        VALUES((V_입고번호+1), V_상품코드,V_입고수량,V_입고단가);
        
        
            -- UPDATE → TBL_상품
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 + V_입고수량
        WHERE 상품코드 =V_상품코드;
        
        -- 커밋
        COMMIT;
        
        
        --예외처리
        EXCEPTION 
            WHEN OTHERS THEN ROLLBACK;
END;

--==>> Procedure PRC_입고_INSERT이(가) 컴파일되었습니다.





--■■■ 프로시저 내에서의 예외 처리 ■■■--

-- 실습 테이블 생성
-- 테이블명 : TBL_MEMBER → 20241204_02_scott.sql 참조


--○ TBL_MEMEBER 테이블에서 데이터를 입력하는 프로시저를 생성
--   단, 이 프로시저를 통해 데이터를 입력할 경우
--   CITY(지역) 항목에 '서울', '경기','인천'만 입력이 가능하도록 구성한다.
--   이 지역 이외의 다른 지역을 프로시저 호출을 통해 입력하려 하는 경우
--   예외 처리를 하려고 한다.
-- 프로시저명 : PRC_MEMEBER_INSERT(이름, 전화번호, 지역)

CREATE OR REPLACE PROCEDURE PRC_MEMBER_INSERT
( V_NAME        IN TBL_MEMBER.NAME%TYPE
, V_TEL         IN TBL_MEMBER.TEL%TYPE
, V_CITY        IN TBL_MEMBER.CITY%TYPE
)
IS

    -- 실행 영역의 쿼리문 수행을 위해 필요한 데이터 변수 추가 선언
    V_NUM   TBL_MEMBER.NUM%TYPE;
    
    -- 사용자 정의 예외에 대한 변수 선언 !!
    USER_DEFINE_ERROR EXCEPTION;
    
BEGIN
        -- 프로시저를 통해 입력 액션 처리를 정상적으로 진행해야 할 데이터인지
        -- 아닌지의 여부를 가장 먼저 확인할 수 있도록 해당 위치에 코드 구성
        IF (V_CITY NOT IN ('서울','인천','경기'))--V_CITY에 '서울','인천','경기' 중 하나가 들어있지 않다면...
            -- 예외 발생! CHECK !
            THEN RAISE USER_DEFINE_ERROR;
        END IF;




        -- 추가로 선언한 변수에 값 담아내기
        SELECT NVL(MAX(NUM),0) INTO V_NUM
        FROM TBL_MEMBER;
        -- 쿼리문 구성 → INSERT 
        INSERT INTO TBL_MEMBER(NUM,NAME,TEL,CITY)
        VALUES((V_NUM+1),V_NAME,V_TEL,V_CITY);
        
        --커밋
        COMMIT;
        
        
        
        -- 예외처리
        /*
        EXCEPTION
            WHEN 이런 예외 상황이라면...
                THEN 이렇게 처리하고...
            WHEN 저런 예외 상황이라면...
                THEN 저렇게 처리해라...
                        ↓
        */
        
        /*
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-에러코드,에러내용기술);
            WHEN 저런 예외 상황이라면...
                THEN 저렇게 처리해라...
                        ↓
        */
        
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-20001,'서울,인천,경기만 입력 가능합니다.');
                    ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;
        
        
END;



-- 실습 테이블 생성
-- 테이블명 : TBL_출고 → 20241204_02_scott.sql 참조



--○ TBL_출고 테이블에 데이터 입력 시 (즉, 출고 이벤트 발생 시)
--   TBL_상품 테이블의 해당 상품의 재고수량이 변동될 수 있는 프로시저를 작성한다.
--   단, 출고번호는 입고번호와 마찬가지로 자동 증가.
--   또한, 출고수량이 재고수량보다 많은 경우...
--   출고 액션이 처리되지 않도록 구성한다.(출고가 이루어지지 않도록...)
-- 프로시저명 : PRC_출고_INSERT(상품코드,출고수량,출고단가)


-- 내가 한 풀이-----------------------------------------------------------------
CREATE OR REPLACE PROCEDURE PRC_출고_INSERT
(
  V_상품코드  IN  TBL_상품.상품코드%TYPE
, V_출고수량  IN  TBL_출고.출고수량%TYPE
, V_출고단가  IN  TBL_출고.출고단가%TYPE
)
IS
  V_출고번호   TBL_출고.출고번호%TYPE;
  V_재고수량   TBL_상품.재고수량%TYPE;
  USER_DEFINE_ERROR EXCEPTION;
BEGIN
        SELECT 재고수량 INTO V_재고수량
        FROM TBL_상품
        WHERE TBL_상품.상품코드 = V_상품코드;
     
        IF (V_재고수량 < V_출고수량)
            THEN RAISE USER_DEFINE_ERROR;
        END IF;

        SELECT NVL(MAX(출고번호),0)+1 INTO V_출고번호
        FROM TBL_출고;
        -- TBL_출고 프로시저 실행 시 테이블 입력값 작성
        INSERT INTO TBL_출고(출고번호,상품코드,출고수량,출고단가)
        VALUES(V_출고번호,V_상품코드,V_출고수량,V_출고단가);
        -- TBL_출고 프로시저 실행 시 TBL_상품 테이블 재고수량이 변동되는 값 작성
        UPDATE TBL_상품
        SET TBL_상품.재고수량 = 재고수량 - V_출고수량
        WHERE TBL_상품.상품코드 = V_상품코드;
        
        
        
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-20001,'숫자를 초과하였습니다.');
                    ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;
END;
--------------------------------------------------------------------------------




CREATE OR REPLACE PROCEDURE PRC_출고_INSERT
( V_상품코드      IN TBL_상품.상품코드%TYPE
, V_출고수량      IN TBL_출고.출고수량%TYPE
, V_출고단가      IN TBL_출고.출고단가%TYPE
)
IS
        -- 변수 선언
        V_출고번호 TBL_출고.출고번호%TYPE;
        V_재고수량 TBL_상품.재고수량%TYPE;
        
        USER_DEFINE_ERROR EXCEPTION;            -- 사용자 정의 예외
BEGIN

        -- 쿼리문 수행 이전에 수행여부 확인 → 해당 상품의 기존 재고 확인 → 출고 수량과 비교
        SELECT 재고수량 INTO V_재고수량
        FROM TBL_상품
        WHERE 상품코드 = V_상품코드;
        
        -- 출고를 정상적으로 진행해 줄 것인지에 대한 여부 확인
        --==> 파악한 재고수량보다 출고수량이 많으면... 예외 발생
        IF (V_출고수량 > V_재고수량)
            THEN RAISE USER_DEFINE_ERROR;
        END IF;
        

        -- 선언한 변수에 값 담아내기
        SELECT NVL(MAX(출고번호),0) INTO V_출고번호
        FROM TBL_출고;
        
        -- 쿼리문 구성 → INSERT → TBL 출고
        INSERT INTO TBL_출고(출고번호, 상품코드, 출고수량, 출고단가)
        VALUES((V_출고번호+1), V_상품코드, V_출고수량, V_출고단가);
        
        -- 쿼리문 구성 → UPDATE → TBL_상품
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 - V_출고수량
        WHERE 상품코드 = V_상품코드;
        
        -- 커밋
        COMMIT;
        
        -- 예외 처리
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-20002,'재고 부족!');
                     ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;
END;
--==>> Procedure PRC_출고_INSERT이(가) 컴파일되었습니다.




--○ TBL_출고 테이블에서 출고 수량을 변경(수정) 하는 프로시저를 작성한다.
-- 프로시저명 : PRC_출고_UPDATE(출고번호, 변경할수량)

--내가 한 풀이-----------------------------------------------------------------

CREATE OR REPLACE PROCEDURE PRC_출고_UPDATE
( V_출고번호        IN TBL_출고.출고번호%TYPE
, V_변경수량      IN TBL_출고.출고수량%TYPE
)
IS


V_재고수량   TBL_상품.재고수량%TYPE;
V_상품코드   TBL_상품.상품코드%TYPE;
V_출고수량   TBL_출고.출고수량%TYPE;
USER_DEFINE_ERROR EXCEPTION;            -- 사용자 정의 예외

BEGIN



-- 출고 테이블 에있는 상품코드값 받기
SELECT 상품코드 INTO V_상품코드
FROM TBL_출고
WHERE 출고번호 = V_출고번호;

--출고 테이블에 있는 출고수량값 받기               
SELECT 출고수량 INTO V_출고수량
FROM TBL_출고
WHERE 출고번호 = V_출고번호;


-- 상품 테이블에 있는 재고수량값 받기
SELECT 재고수량 INTO V_재고수량
FROM TBL_상품
WHERE 상품코드 = V_상품코드;




IF ((V_재고수량+V_출고수량) < V_변경수량)
    THEN RAISE USER_DEFINE_ERROR;
END IF;


-- 출고 테이블에있는 출고수량 초기화
UPDATE TBL_출고
SET 출고수량 = V_변경수량
WHERE 출고번호 = V_출고번호;


-- 상품테이블에 있는 재고수량 + 출고번호에 맞는  출고수량
UPDATE TBL_상품
SET 재고수량 = (재고수량+V_출고수량)-V_변경수량
WHERE 상품코드 = V_상품코드;

-- 커밋
COMMIT;

 -- 예외 처리
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-20003,'재고 부족!');
                     ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;


END;
-------------------------------------------------------------------------------

CREATE OR REPLACE PROCEDURE PRC_출고_UPDATE
(
        --① 매개변수 구성
        V_출고번호      IN  TBL_출고.출고번호%TYPE
       ,V_출고수량      IN  TBL_출고.출고수량%TYPE
)
IS

        --③ 주요 변수 선언
        V_상품코드 TBL_상품.상품코드%TYPE;
        
        --⑤ 주요 변수 추가 선언
        V_이전출고수량    TBL_출고.출고수량%TYPE;
        
        
        --⑧ 주요 변수 추가 선언
        V_재고수량 TBL_상품.재고수량%TYPE;
        
        
        --⑪ 주요 변수 추가 선언 → 사용자 정의 예외
        USER_DEFINE_ERROR EXCEPTION;
        
BEGIN

        --④ 상품코드 파악 / ⑥ 이전출고수량 파악 → 변경 수행 이전의 출고내역 확인
        SELECT 상품코드,출고수량 INTO V_상품코드,V_이전출고수량
        FROM TBL_출고
        WHERE 출고번호 = V_출고번호;
        
        
        --⑨ 출고를 정상적으로 수행해아 하는지의 여부 판단 필요
        --  재고수량, 이전출고수량, 출고수량
        
        SELECT 재고수량 INTO V_재고수량
        FROM TBL_상품
        WHERE 상품코드 = V_상품코드;
        
        
        --⑩ 파악한 재고수량, 이전출고수량, 출고수량에 따라 데이터 변경 실시 여부 판단
        --  → 『재고수량 + 이전출고수량 < 현재출고수량』인 상황이라면... 예외발생
        
        
        IF ((V_재고수량 + V_이전출고수량) < V_출고수량)
            THEN RAISE USER_DEFINE_ERROR;
        END IF;
        
        
        --② 수행 쿼리문 구성
        -- UPDATE → TBL_출고
        UPDATE TBL_출고
        SET 출고수량 = V_출고수량
        WHERE 출고번호 = V_출고번호;
        
        
        -- UPDATE → TBL_상품
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 + V_이전출고수량 - V_출고수량
        WHERE 상품코드 = V_상품코드;
        
        
        --⑦ 커밋
        COMMIT;
        
        --⑫ 예외 처리
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-20002, '재고부족!!');
                    ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;
END;
--==>> Procedure PRC_출고_UPDATE이(가) 컴파일되었습니다.






























-- 파일명 : procedure_scott(plsql)_3팀_박제훈.sql


--○ TBL_입고 테이블에서 입고수량을 수정(변경)하는 프로시저를 작성한다.
-- 프로시저명 : PRC_입고_UPDATE(입고번호, 변경할입고수량)
CREATE OR REPLACE PROCEDURE PRC_입고_UPDATE
(
    V_입고번호            IN   TBL_입고.입고번호%TYPE
,   V_변경할입고수량      IN   TBL_입고.입고수량%TYPE
)
IS
    V_상품코드       TBL_상품.상품코드%TYPE;
    V_기존입고수량   TBL_입고.입고수량%TYPE;
    V_기존재고수량   TBL_상품.재고수량%TYPE;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN

-- 주요 연산 및 처리

SELECT 상품코드 INTO V_상품코드
FROM TBL_입고
WHERE 입고번호 = V_입고번호;


SELECT 입고수량 INTO V_기존입고수량
FROM TBL_입고
WHERE 입고번호 = V_입고번호;

SELECT 재고수량 INTO V_기존재고수량
FROM TBL_상품
WHERE 상품코드 = V_상품코드;


--① 입고 테이블에서 입고수량을 변경 → 사용자가 입력한 값으로
UPDATE TBL_입고
SET 입고수량 = V_변경할입고수량
WHERE 입고번호 = V_입고번호;



IF ((V_기존재고수량+V_기존입고수량 < V_변경할입고수량))
    THEN RAISE USER_DEFINE_ERROR;
END IF;



--② 상품 테이블에서 재고수량을 변경 → 기존 재고수량 + 기존 입고수량 - 변경할입고수량
UPDATE TBL_상품
SET 재고수량 = 재고수량 + V_기존입고수량 - V_변경할입고수량
WHERE 상품코드 = V_상품코드;




 -- 예외 처리
        EXCEPTION
            WHEN USER_DEFINE_ERROR
                THEN RAISE_APPLICATION_ERROR(-20002, '재고부족!!');
                    ROLLBACK;
            WHEN OTHERS
                THEN ROLLBACK;


END;



SELECT *
FROM TBL_출고;





--○ TBL_출고 테이블에서 출고수량을 삭제하는 프로시저를 작성한다.
-- 프로시저명 : PRC_출고_DELETE(출고번호)
CREATE OR REPLACE PROCEDURE PRC_출고_DELETE
(
    V_출고번호        IN  TBL_출고.출고번호%TYPE

)
IS
    V_기존출고수량        TBL_출고.출고수량%TYPE;
    V_상품코드            TBL_상품.상품코드%TYPE;
BEGIN

-- 주요연산 처리

SELECT 출고수량 INTO V_기존출고수량
FROM TBL_출고
WHERE 출고번호 = V_출고번호;


SELECT 상품코드 INTO V_상품코드
FROM TBL_출고
WHERE 출고번호 = V_출고번호;



--① 출고 테이블에서 출고 수량을 삭제하는 DELETE 문 작성
DELETE 
FROM TBL_출고
WHERE 출고번호 = V_출고번호; 


--② 상품 테이블에서 재고수량에 기존 출고수량을 더해주는 UPDATE문 작성
UPDATE TBL_상품
SET 재고수량 = 재고수량 + V_기존출고수량
WHERE 상품코드 = V_상품코드;


END;










--○ TBL_입고 테이블에서 입고수량을 삭제하는 프로시저를 작성한다.
-- 프로시저명 : PRC_입고_DELETE(입고번호)
CREATE OR REPLACE PROCEDURE PRC_입고_DELETE
(
    V_입고번호        IN  TBL_입고.입고번호%TYPE
)
IS
    V_기존입고수량        TBL_입고.입고수량%TYPE;
    V_상품코드            TBL_상품.상품코드%TYPE;
BEGIN

-- 주요연산 처리

SELECT 입고수량 INTO V_기존입고수량
FROM TBL_입고
WHERE 입고번호 = V_입고번호;


SELECT 상품코드 INTO V_상품코드
FROM TBL_입고
WHERE 입고번호 = V_입고번호;


--① 입고 테이블에서 입고 번호에 맞는 삭제하는 DELETE 문 작성
DELETE 
FROM TBL_입고
WHERE 입고번호 = V_입고번호; 


--② 상품 테이블에서 재고수량에 기존 입고수량을 더해주는 UPDATE문 작성
UPDATE TBL_상품
SET 재고수량 = 재고수량 - V_기존입고수량
WHERE 상품코드 = V_상품코드;


END;





SELECT *
FROM TBL_입고;































SELECT USER
FROM DUAL;
--==>>SCOTT


EXEC PRC_입고_INSERT('E006',6,1000);


SELECT *
FROM TBL_상품;
/*
H001	홈런볼	1500	0
H002	새우깡	1200	0
H003	스윙칩	1000	0
H004	치토스	1100	0
H005	밭두렁	1000	0
H006	오감자	2000	0
H007	양파링	1700	0
C001	초코칩	1800	0
C002	버터링	1900	0
C003	에이스	1700	0
C004	오레오	2200	0
C005	다이제	2500	0
C006	아이비	1200	0
C007	오예스	3500	0
E001	마이쮸	1000	0
E002	엠엔엠	1100	0
E003	아이셔	1100	0
E004	비틀즈	1200	0
E005	아폴로	1000	0
E006	새콤달	1500	0
E007	말랑카	1600	0
*/

SELECT *
FROM TBL_입고;
--==>> 조회결과 없음


-- CHECK !!
SELECT NVL(MAX(입고번호),0) "결과확인" 
FROM TBL_입고;

SELECT MAX(NVL(입고번호,0))"결과확인"
FROM TBL_입고;


--○ 생성한 프로시저(PRC_입고_INSERT)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
EXEC PRC_입고_INSERT('H001',20,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_입고;
/*
1	H001	2024-12-04	20	1000
*/

SELECT *
FROM TBL_상품;
/*
H001	홈런볼	1500	20
*/


EXEC PRC_입고_INSERT('H001',20,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_입고_INSERT('H001',20,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.


EXEC PRC_입고_INSERT('H004',30,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_입고_INSERT('C004',50,2000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_입고_INSERT('C004',30,1800);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_입고_INSERT('E003',40,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_입고_INSERT('E007',30,1200);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.


SELECT *
FROM TBL_입고;
/*
1	E007	2024-12-04	3	1000
2	E006	2024-12-04	6	1000
3	H001	2024-12-04	20	1000
4	H001	2024-12-04	20	1000
5	H001	2024-12-04	20	1000
6	H004	2024-12-04	30	1000
7	C004	2024-12-04	50	2000
8	C004	2024-12-04	30	1800
9	E003	2024-12-04	40	1000
10	E007	2024-12-04	30	1200
*/

SELECT *
FROM TBL_상품;
/*
H001	홈런볼	1500	60
H002	새우깡	1200	0
H003	스윙칩	1000	0
H004	치토스	1100	30
H005	밭두렁	1000	0
H006	오감자	2000	0
H007	양파링	1700	0
C001	초코칩	1800	0
C002	버터링	1900	0
C003	에이스	1700	0
C004	오레오	2200	80
C005	다이제	2500	0
C006	아이비	1200	0
C007	오예스	3500	0
E001	마이쮸	1000	0
E002	엠엔엠	1100	0
E003	아이셔	1100	40
E004	비틀즈	1200	0
E005	아폴로	1000	0
E006	새콤달	1500	6
E007	말랑카	1600	30
*/



--------------------------------------------------------------------------------


--○ 실습 테이블 생성
-- 테이블명 : TBL_MEMEBER
CREATE TABLE TBL_MEMBER
( NUM       NUMBER
, NAME      VARCHAR2(30)
, TEL       VARCHAR2(30)
, CITY      VARCHAR2(30)
, CONSTRAINT MEMBER_NUM_PK PRIMARY KEY(NUM)
);
--==>> Table TBL_MEMBER이(가) 생성되었습니다.





--○ 생성한 프로시저(PRC_입고_INSERT)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
-- PRC_MEMBER_INSERT(이름,전화번호,지역)
EXEC PRC_MEMBER_INSERT('박제훈','010-1111-1111','서울');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_MEMBER;
/*
1	박제훈	010-1111-1111	서울
*/

EXEC PRC_MEMBER_INSERT('정승민','010-2222-2222','인천');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.


SELECT *
FROM TBL_MEMBER;
/*
1	박제훈	010-1111-1111	서울
2	정승민	010-2222-2222	인천
*/


EXEC PRC_MEMBER_INSERT('안예지','010-3333-3333','경기');
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_MEMBER;
/*
1	박제훈	010-1111-1111	서울
2	정승민	010-2222-2222	인천
3	안예지	010-3333-3333	경기
*/


EXEC PRC_MEMBER_INSERT('김믿음','010-4444-4444','제주');
--==>> 에러 발생
/*
ORA-20001: 서울,인천,경기만 입력 가능합니다.
*/


EXEC PRC_MEMBER_INSERT('곽유진','010-5555-5555','부산');
--==>> 에러 발생
/*
ORA-20001: 서울,인천,경기만 입력 가능합니다.
*/

SELECT *
FROM TBL_MEMBER;
--==>>
/*
1	박제훈	010-1111-1111	서울
2	정승민	010-2222-2222	인천
3	안예지	010-3333-3333	경기
*/

--------------------------------------------------------------------------------

DESC TBL_입고;

--○ 실습 테이블 생성
-- 테이블명 : TBL_출고
CREATE TABLE TBL_출고
( 출고번호  NUMBER
, 상품코드  VARCHAR2(20)
, 출고일자  DATE    DEFAULT SYSDATE
, 출고수량  NUMBER
, 출고단가  NUMBER
);
--==>>Table TBL_출고이(가) 생성되었습니다.


--○ TBL_출고 테이블의 출고번호에 PK 제약조건 지정
ALTER TABLE TBL_출고
ADD CONSTRAINT 출고_출고번호_PK PRIMARY KEY(출고번호);
--==>> Table TBL_출고이(가) 변경되었습니다.


--○ TBL_출고 테이블의 상품코드는 TBL_상품  테이블의 상품코드를
--   참조할 수 있도록 외래키(FK) 제약조건 지정
ALTER TABLE TBL_출고
ADD CONSTRAINT 출고_상품코드_FK FOREIGN KEY(상품코드)
                REFERENCES TBL_상품(상품코드);
--==>> Table TBL_출고이(가) 변경되었습니다.







--○ 생성한 프로시저(PRC_출고_INSERT)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
-- 프로시저명 : PRC_출고_INSERT(상품코드,출고수량,출고단가)

EXEC PRC_출고_INSERT('C004',-90,2100);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_출고;
--==>> 1	C004	2024-12-04	10	2100

SELECT *
FROM TBL_상품;
/*
            :
C004	오레오	2200	70
            :
*/


EXEC PRC_출고_INSERT('E003',50,1000);
/*
ORA-20002: 재고 부족!
*/

EXEC PRC_출고_INSERT('E003',10,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.


SELECT *
FROM TBL_상품;

/*
            :
E003	아이셔	1100	30
            :
*/





EXEC PRC_출고_INSERT('H001',10,1000);
--==>>PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_출고_INSERT('H004',10,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_출고_INSERT('C004',10,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_출고_INSERT('E003',5,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.

EXEC PRC_출고_INSERT('E007',5,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다.





SELECT *
FROM TBL_상품;
/*
H001	홈런볼	1500	50
H002	새우깡	1200	0
H003	스윙칩	1000	0
H004	치토스	1100	20
H005	밭두렁	1000	0
H006	오감자	2000	0
H007	양파링	1700	0
C001	초코칩	1800	0
C002	버터링	1900	0
C003	에이스	1700	0
C004	오레오	2200	60
C005	다이제	2500	0
C006	아이비	1200	0
C007	오예스	3500	0
E001	마이쮸	1000	-80
E002	엠엔엠	1100	0
E003	아이셔	1100	0
E004	비틀즈	1200	0
E005	아폴로	1000	0
E006	새콤달	1500	6
E007	말랑카	1600	0
*/










TRUNCATE TABLE TBL_입고;
--==>> Table TBL_입고이(가) 잘렸습니다.


TRUNCATE TABLE TBL_출고;
--==>> Table TBL_출고이(가) 잘렸습니다.


UPDATE TBL_상품
SET 재고수량 = 0;
--==>>21개 행 이(가) 업데이트되었습니다.


SELECT *
FROM TBL_입고;
--==>> 조회 결과 없음

SELECT *
FROM TBL_출고;
--==>> 조회 결과 없음

SELECT *
FROM TBL_상품;
/*
H001	홈런볼	1500	0
H002	새우깡	1200	0
H003	스윙칩	1000	0
H004	치토스	1100	0
H005	밭두렁	1000	0
H006	오감자	2000	0
H007	양파링	1700	0
C001	초코칩	1800	0
C002	버터링	1900	0
C003	에이스	1700	0
C004	오레오	2200	0
C005	다이제	2500	0
C006	아이비	1200	0
C007	오예스	3500	0
E001	마이쮸	1000	0
E002	엠엔엠	1100	0
E003	아이셔	1100	0
E004	비틀즈	1200	0
E005	아폴로	1000	0
E006	새콤달	1500	0
E007	말랑카	1600	0
*/

COMMIT;


-- 입고 이벤트 발생
EXEC PRC_입고_INSERT('H001',20,1000);
EXEC PRC_입고_INSERT('H001',10,1000);
EXEC PRC_입고_INSERT('H002',20,1000);
EXEC PRC_입고_INSERT('H002',10,1000);
EXEC PRC_입고_INSERT('H003',20,1000);
EXEC PRC_입고_INSERT('H003',10,1000);
EXEC PRC_입고_INSERT('H006',20,1000);
EXEC PRC_입고_INSERT('H006',10,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다. * 8

EXEC PRC_입고_INSERT('C001',20,1000);
EXEC PRC_입고_INSERT('C001',10,1000);
EXEC PRC_입고_INSERT('C002',20,1000);
EXEC PRC_입고_INSERT('C002',10,1000);
EXEC PRC_입고_INSERT('C003',20,1000);
EXEC PRC_입고_INSERT('C003',10,1000);
EXEC PRC_입고_INSERT('C006',20,1000);
EXEC PRC_입고_INSERT('C006',10,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다. * 8

EXEC PRC_입고_INSERT('E001',20,1000);
EXEC PRC_입고_INSERT('E001',10,1000);
EXEC PRC_입고_INSERT('E002',20,1000);
EXEC PRC_입고_INSERT('E002',10,1000);
EXEC PRC_입고_INSERT('E003',20,1000);
EXEC PRC_입고_INSERT('E003',10,1000);
EXEC PRC_입고_INSERT('E006',20,1000);
EXEC PRC_입고_INSERT('E006',10,1000);
--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다. * 8


-- 출고 이벤트 발생
EXEC PRC_출고_INSERT('H001',5,1000);
EXEC PRC_출고_INSERT('H001',10,1000);
EXEC PRC_출고_INSERT('H003',5,1000);
EXEC PRC_출고_INSERT('H003',10,1000);

EXEC PRC_출고_INSERT('C001',5,1000);
EXEC PRC_출고_INSERT('C001',10,1000);
EXEC PRC_출고_INSERT('C003',5,1000);
EXEC PRC_출고_INSERT('C003',10,1000);

EXEC PRC_출고_INSERT('E001',5,1000);
EXEC PRC_출고_INSERT('E001',10,1000);
EXEC PRC_출고_INSERT('E003',5,1000);
EXEC PRC_출고_INSERT('E003',10,1000);

--==>> PL/SQL 프로시저가 성공적으로 완료되었습니다. * 12

SELECT *
FROM TBL_출고;

SELECT *
FROM TBL_입고;
/*
1	H001	2024-12-04	20	1000
2	H001	2024-12-04	10	1000
3	H002	2024-12-04	20	1000
4	H002	2024-12-04	10	1000
5	H003	2024-12-04	20	1000
6	H003	2024-12-04	10	1000
7	H006	2024-12-04	20	1000
8	H006	2024-12-04	10	1000
9	C001	2024-12-04	20	1000
10	C001	2024-12-04	10	1000
11	C002	2024-12-04	20	1000
12	C002	2024-12-04	10	1000
13	C003	2024-12-04	20	1000
14	C003	2024-12-04	10	1000
15	C006	2024-12-04	20	1000
16	C006	2024-12-04	10	1000
17	E001	2024-12-04	20	1000
18	E001	2024-12-04	10	1000
19	E002	2024-12-04	20	1000
20	E002	2024-12-04	10	1000
21	E003	2024-12-04	20	1000
22	E003	2024-12-04	10	1000
23	E006	2024-12-04	20	1000
24	E006	2024-12-04	10	1000
*/

SELECT *
FROM TBL_상품;
/*
H001	홈런볼	1500	15
H002	새우깡	1200	30
H003	스윙칩	1000	15
H004	치토스	1100	0
H005	밭두렁	1000	0
H006	오감자	2000	30
H007	양파링	1700	0
C001	초코칩	1800	15
C002	버터링	1900	30
C003	에이스	1700	15
C004	오레오	2200	0
C005	다이제	2500	0
C006	아이비	1200	30
C007	오예스	3500	0
E001	마이쮸	1000	15
E002	엠엔엠	1100	30
E003	아이셔	1100	15
E004	비틀즈	1200	0
E005	아폴로	1000	0
E006	새콤달	1500	30
E007	말랑카	1600	0
*/


--○ 생성한 프로시저(PRC_출고_UPDATE)가 제대로 작동하는지의 여부 확인
-- → 프로시저 호출
-- 프로시저명 : PRC_출고_UPDATE(출고번호, 변경할수량)

EXEC PRC_출고_UPDATE(12, 30);
--『재고15 / 이전출고10』인 아이셔 출고내역(출고번호12) 변경 → 30
--==>> 에러발생
/*
ORA-20002: 재고부족!!
*/


EXEC PRC_출고_UPDATE(12, 25);
--==>>PL/SQL 프로시저가 성공적으로 완료되었습니다.

SELECT *
FROM TBL_출고;
/*
1	H001	2024-12-04	5	1000
2	H001	2024-12-04	10	1000
3	H003	2024-12-04	5	1000
4	H003	2024-12-04	10	1000
5	C001	2024-12-04	5	1000
6	C001	2024-12-04	10	1000
7	C003	2024-12-04	5	1000
8	C003	2024-12-04	10	1000
9	E001	2024-12-04	5	1000
10	E001	2024-12-04	10	1000
11	E003	2024-12-04	5	1000
12	E003	2024-12-04	25	1000            -- CHECK 10 → 25
*/

SELECT *
FROM TBL_상품;
/*
            :
E003	아이셔	1100	0
            :
*/



























SELECT USER
FROM DUAL;
--==>> SCOTT



-- ■■■ CURSOR(커서) ■■■--

-- 1. 오라클에서 하나의 레코드가 아닌 여러 레코드로 구성된
--    작업 영역에서 SQL문을 실행하고 그 과정에서 발생한 정보를
--    저장하기 위하여 커서(CURSOR)를 사용하며,
--    커서에는 암시적으로 커서와 명시적 커서가 있다.

-- 2. 암시적 커서는 모든 SQL 문에 존재하며,
--    SQL 실행 후 오직 하나의 행(ROW)만 출력하게 된다.
--    그러나 SQL 문을 실행한 결과물(RESULT SET)이
--    여러 행(ROW)으로 구성된 경우
--    커서(CURSOR)를 명시적으로 선언해야 여러 행(ROW)을 다룰 수 있다.




--○ 커서 이용 전 상황(단일 행 접근 시)
SET SERVEROUTPUT ON;

DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
BEGIN
    SELECT NAME, TEL INTO V_NAME, V_TEL
    FROM TBL_INSA
    WHERE NUM = 1001;
    
    DBMS_OUTPUT.PUT_LINE(V_NAME || ',' || V_TEL);
END;
--==>>홍길동,011-2356-4528


--○ 커서 이용 전 상황(다중 행 접근 시)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
BEGIN
    SELECT NAME, TEL INTO V_NAME, V_TEL
    FROM TBL_INSA;
    
    DBMS_OUTPUT.PUT_LINE(V_NAME || ',' || V_TEL);
END;
--==>> 에러 발생
/*
ORA-01422: exact fetch returns more than requested number of rows
*/

--○ 커서 이용 전 상황(다중 행 접근 시 → 반복문을 활용하는 경우)
DECLARE
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
    V_NUM   TBL_INSA.NUM%TYPE:=1001;
BEGIN

    LOOP
        SELECT NAME, TEL INTO V_NAME, V_TEL
        FROM TBL_INSA
        WHERE NUM = V_NUM;
    
        DBMS_OUTPUT.PUT_LINE(V_NAME || ',' || V_TEL);
        V_NUM := V_NUM + 1;
    
        EXIT WHEN V_NUM >= 1062;
    END LOOP;
    
END;




--○ 커서 이용 상황(다중 행 접근 시 → 반복문을 활용하는 경우)
DECLARE
    -- 주요 변수 선언
    V_NAME  TBL_INSA.NAME%TYPE;
    V_TEL   TBL_INSA.TEL%TYPE;
    
    -- 커서 이용을 위한 커서 변수 선언(→ 커서 정의)
    CURSOR CUR_INSA_SELECT
    IS
    SELECT NAME, TEL
    FROM TBL_INSA;
BEGIN
    -- 커서 오픈
    OPEN CUR_INSA_SELECT;
    
    -- 커서 오픈 시 쏟아져나오는 데이터들 처리(잡아내기 → 반복처리)
    LOOP
        -- 한 행 한행 끄집어내어 가져오는 행위 → 『FETCH』
        FETCH CUR_INSA_SELECT INTO V_NAME, V_TEL;
        
        -- 반복문을 빠져나가는 조건 → 커서의 데이터 모두 소진 시 ....
        EXIT WHEN CUR_INSA_SELECT%NOTFOUND;
        
        -- 출력
        DBMS_OUTPUT.PUT_LINE(V_NAME || ',' || V_TEL);
    
    
    END LOOP;

    -- 커서 클로즈
    CLOSE CUR_INSA_SELECT;
END;


--------------------------------------------------------------------------------


--■■■ TRIGGER(트리거) ■■■--

-- 사전적인 의미 : 방아쇠, 촉발시키다, 야기하다, 유발하다.

-- 1. TRIGGER(트리거)란 DML 작업 즉, INSERT, UPDATE, DELETE 와 같은 작입이 일어날 때
--    자동적으로 실행되는(유발되는, 촉발되는) 객체로
--    이와 같은 특징을 강조하여(부각시켜) DML TRIGGER 라고 부르기도 한다.
--    TRIGGER(트리거)는 데이터 무결성 뿐 아니라
--    다음과 같은 직업에도 널리 사용된다.

--    ·자동으로 파생된 열 값 생성
--    ·잘못된 트랜잭션 방지
--    ·복잡한 보안 권한 강제 수행
--    ·분산 데이터베이스 노드 상에서 참조 무결성 강제 수행
--    ·복잡한 업무 규칙 강제 적용
--    ·투명한 이벤트 로깅 제공
--    ·복잡한 감사 제공
--    ·동기 테이블 복제 유지관리
--    ·테이블 엑세스 통계 수집

-- 2. TRIGGER(트리거) 내에서는 COMMIT, ROLLBACK 구문을 사용할 수 없다.

-- 3. 특징 및 종류

--    ·BEFORE STATEMENT TRIGGER
--      SQL 구문이 실행되기 전에 그 문장에 대해 한 번 실행
--    ·BEFORE ROW TRIGGER
--      SQL 구문이 실행되기 전에(DML 작업을 수행하기 전에)
--    ·AFTER STATEMENT TRIGGER
--      SQL 구문이 실행된 후 그 문장에 대해 한 번 실행
--    ·AFTER ROW TRIGGER
--      SQL 구문이 실행된 후에(DML 작업을 수행한 후에)
--      각 행(ROW)에 대해 한 번씩 실행


-- 4. 형식 및 구조
/*
CREATE [OR REPLACE] TRIGGER 트리거명
        [BEFORE] || [AFTER] 
        이벤트1 [OR 이벤트2 [OR 이벤트3]] ON 테이블명
        [FOR EACH ROW [WHEN TRIGGER 조건]]
[DECLARE]
    -- 선언 구문;
BEGIN
    -- 실행 구문;
END;
*/


---■■■ AFTER STATEMENT TRIGGER 상황 실습 ■■■--

-- ※ DML 작업에 대한 이벤트 기록



-- 실습 테이블 생성
-- 테이블명 : TBL_상품 → 20241205_02_scott.sql 참조
-- 테이블명 : TBL_EVENTLOG → 20241205_02_scott.sql 참조




















































































SELECT USER
FROM DUAL;
--==>> SCOTT


-- 실습 테이블 생성
-- 테이블명 : TBL_TEST1
CREATE TABLE TBL_TEST1
( ID        NUMBER
, NAME      VARCHAR2(30)
, TEL       VARCHAR2(60)
);
--==>> Table TBL_TEST1이(가) 생성되었습니다.


-- 생성된 테이블에 제약조건 추가
-- ID 컬럼에 PK 제약조건 지정
ALTER TABLE TBL_TEST1
ADD (CONSTRAINT TEST1_ID_PK PRIMARY KEY(ID));
--==>> Table TBL_TEST1이(가) 변경되었습니다.


-- 실습 테이블 생성
-- 테이블명 : TBL_EVENTLOG
CREATE TABLE TBL_EVENTLOG
( MEMO VARCHAR2(200)
, ILJA DATE DEFAULT SYSDATE
);
--==>>Table TBL_EVENTLOG이(가) 생성되었습니다.



SELECT *
FROM TBL_TEST1;
--==>> 조회 결과 없음

SELECT *
FROM TBL_EVENTLOG;
--==>> 조회 결과 없음




--날짜 세션 정보 설정
ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';
--==>>Session이(가) 변경되었습니다.



-- 실습 테이블 생성
-- 테이블명 : TBL_EVENTLOGSELECT USER
FROM DUAL;
--==>> SCOTT
---■■■ AFTER STATEMENT TRIGGER 상황 실습 ■■■--
-- ※ DML 작업에 대한 이벤트 기록


--○ 트리거(TRIGGER) 생성
-- 트리거명 : TRG_EVENTLOG
CREATE OR REPLACE TRIGGER TRG_EVENTLOG
    AFTER
    INSERT OR UPDATE OR DELETE ON TBL_TEST1
DECLARE
BEGIN
    -- 이벤트 종류 구분(→ 조건문을 통한 분기)
    -- 조건에 대한 키워드 CHECK!
    IF   (INSERTING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
            VALUES('INSERT 쿼리문이 수행되었습니다.');
    ELSIF (UPDATING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
            VALUES('UPDATE 쿼리문이 수행되었습니다.');
    ELSIF (DELETING)
        THEN INSERT INTO TBL_EVENTLOG(MEMO)
            VALUES('DELETE 쿼리문이 수행되었습니다.');
    END IF;
END;
--==>>Trigger TRG_EVENTLOG이(가) 컴파일되었습니다.



---■■■ BEFOR STATEMENT TRIGGER 상황 실습 ■■■--
-- ※ DML 작업 수행 전에 작업 가능여부 확인
--    (보안 정책 적용 / 업무 규칙 적용)


--○ TRIGGER(트리거) 작성
--  트리거명 : TRG_TEST1_DML

CREATE OR REPLACE TRIGGER TRG_TEST1_DML 
    BEFORE
    INSERT OR UPDATE OR DELETE ON TBL_TEST1
BEGIN
        IF (시간이 오전 8시 이전이거나... 오후 6시 이후라면....)
            THEN 작업을 수행하지 못하도록 처리하겠다.
        END IF
END;




CREATE OR REPLACE TRIGGER TRG_TEST1_DML 
    BEFORE
    INSERT OR UPDATE OR DELETE ON TBL_TEST1
BEGIN
        IF (TO_CHAR(SYSDATE,'HH24:MI:SS') <= '08:00:00' OR TO_CHAR(SYSDATE,'HH24:MI:SS') >= '18:00:00')
            THEN 예외를 발생시키도록 처리하겠다.
        END IF;
END;


CREATE OR REPLACE TRIGGER TRG_TEST1_DML 
    BEFORE
    INSERT OR UPDATE OR DELETE ON TBL_TEST1
BEGIN
        IF (TO_NUMBER(TO_CHAR(SYSDATE,'HH24')) < 8 OR TO_NUMBER(TO_CHAR(SYSDATE,'HH24')) > 17)
            THEN RAISE_APPLICATION_ERROR(-20003, '작업은 08:00 ~ 18:00 까지만 가능합니다.');
        END IF;
END;










--■■■ BEFORE ROW TRIGGER 상황 실습 ■■■--
--※ 참조 관계가 설정된 데이터(자식) 삭제를 먼저 수행하는 모델

-- 10:33:11
--○ TRIGGER(트리거) 작성
-- 트리거명 : TRG_TEST2_DELETE
CREATE OR REPLACE TRIGGER TRG_TEST2_DELETE
        BEFORE 
        DELETE ON TBL_TEST2
        FOR EACH ROW
DECLARE
BEGIN
    DELETE 
    FROM TBL_TEST3
    WHERE CODE = :OLD.CODE;
END;
--==>>Trigger TRG_TEST2_DELETE이(가) 컴파일되었습니다.


--※ 『:OLD』
--   참조 전 열의 값
--   (INSERT : 입력하기 이전 자료 즉, 입력할 자료, DELETE : 삭제하기 이전 자료 즉, 삭제할 자료)

--※ UPDATE →  개념적으로 DELETE 그리고 INSERTT 가 결합된 형태로 이해하자
--              이 과정에서 UPDATE 하기 이전의 자료는 『:OLD』
--              이 과정에서 UPDATE 한 이후의 자료는 『:NEW』






--■■■ AFTER ROW TRIGGER 상황 실습 ■■■--
--※ 참조 관계의 테이블 관련 트랜잭션 처리


-- TBL_상품 , TBL_입고, TBL_출고

--○ TBL_입고 테이블의 데이터 입력 시(입고 이벤트 발생 시)
--   TBL_상품 테이블의 재고수량 변동 트리거 작성
CREATE OR REPLACE TRIGGER TRG_IBGO
    AFTER
    INSERT ON TBL_입고
    FOR EACH ROW
BEGIN
    IF (INSERTING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 + 새로입고되는입고수량
             WHERE 상품코드 = 새로입고되는상품코드;
    END IF;
END;




CREATE OR REPLACE TRIGGER TRG_IBGO
    AFTER
    INSERT ON TBL_입고                --INSERT INTO TBL_입고 (...) VALUES (... 'H001', ... 10, ...)
    FOR EACH ROW
BEGIN
    IF (INSERTING)
        THEN UPDATE TBL_상품
             SET 재고수량 = 재고수량 + :NEW.입고수량
             WHERE 상품코드 = :NEW.상품코드;
    END IF;
END;
--==>> Trigger TRG_IBGO이(가) 컴파일되었습니다.






--○ TBL_상품, TBL_입고, TBL_출고 의 관계에서
--  입고수량, 재고수량의 트랜잭션 처리가 이루어질 수 있도록 
--  TRG_IBGO 트리거를 수정한다.

CREATE OR REPLACE TRIGGER TRG_IBGO
    AFTER
    INSERT OR UPDATE OR DELETE ON TBL_입고  -- 트리거는 AFTER(작업 후) 실행되며, TBL_입고 테이블에 대해 작동합니다.
    FOR EACH ROW
DECLARE 
    -- TBL_상품 테이블의 재고수량 컬럼 값을 저장할 변수 선언
    V_재고수량 TBL_상품.재고수량%TYPE;
BEGIN
    -- INSERT 작업 시 실행되는 로직
    IF (INSERTING)
        THEN 
        -- TBL_입고 테이블에 새로 입력된 입고수량만큼 TBL_상품의 재고수량 증가
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 + :NEW.입고수량
        WHERE 상품코드 = :NEW.상품코드;

    -- UPDATE 작업 시 실행되는 로직
    ELSIF (UPDATING)
        THEN 
        -- 상품코드에 해당하는 현재 재고수량을 TBL_상품 테이블에서 가져옴
        SELECT 재고수량 INTO V_재고수량
        FROM TBL_상품
        WHERE 상품코드 = :NEW.상품코드;

        -- 재고수량이 기존 입고수량과 새 입고수량의 합보다 작으면 오류 발생
        IF (V_재고수량 < :OLD.입고수량 + :NEW.입고수량)
            THEN RAISE_APPLICATION_ERROR(-20002, '재고 부족!');
        END IF;

        -- TBL_상품의 재고수량 갱신 (기존 입고수량 제거 후 새 입고수량 추가)
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 - :OLD.입고수량 + :NEW.입고수량
        WHERE 상품코드 = :NEW.상품코드;

    -- DELETE 작업 시 실행되는 로직
    ELSIF (DELETING)
        THEN 
        -- 삭제된 입고수량만큼 TBL_상품의 재고수량 감소
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 - :OLD.입고수량
        WHERE 상품코드 = :OLD.상품코드;
    END IF;
END;




--○ TBL_상품, TBL_입고, TBL_출고 의 관계에서
--  입고수량, 재고수량의 트랜잭션 처리가 이루어질 수 있도록 
--  TRG_CHULGO 트리거를 수정한다.


CREATE OR REPLACE TRIGGER TRG_CHULGO
    -- TBL_출고 테이블에 대해 INSERT, UPDATE, DELETE 작업 발생 시 실행되는 트리거입니다.
    AFTER
    INSERT OR UPDATE OR DELETE ON TBL_출고  -- 트리거가 AFTER(작업 후) 실행되며, TBL_출고 테이블에서 작동함.
    FOR EACH ROW
DECLARE
    -- TBL_상품 테이블의 재고수량 컬럼 값을 저장할 변수 선언
    V_재고수량 TBL_상품.재고수량%TYPE;
    -- TBL_출고 테이블의 출고수량 컬럼 값을 저장할 변수 선언
    V_출고수량 TBL_출고.출고수량%TYPE;
BEGIN
    -- INSERT 작업 시 실행되는 로직
    IF (INSERTING)
        THEN 
        -- 상품코드에 해당하는 재고수량을 TBL_상품 테이블에서 가져옴
        SELECT 재고수량 INTO V_재고수량
        FROM TBL_상품
        WHERE 상품코드 = :NEW.상품코드;
              
        -- 재고수량이 출고수량보다 적으면 오류 발생
        IF (V_재고수량 < :NEW.출고수량)
            THEN RAISE_APPLICATION_ERROR(-20002, '재고 부족!');
        END IF;
             
        -- 출고된 수량만큼 TBL_상품의 재고수량을 감소
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 - :NEW.출고수량
        WHERE 상품코드 = :NEW.상품코드;

    -- UPDATE 작업 시 실행되는 로직
    ELSIF (UPDATING)
        THEN 
        -- 상품코드에 해당하는 현재 재고수량을 TBL_상품 테이블에서 가져옴
        SELECT 재고수량 INTO V_재고수량
        FROM TBL_상품
        WHERE 상품코드 = :NEW.상품코드;
             
        -- 기존 출고수량을 더한 재고수량이 새 출고수량보다 적으면 오류 발생
        IF (V_재고수량 + :OLD.출고수량 < :NEW.출고수량)
            THEN RAISE_APPLICATION_ERROR(-20002, '재고 부족!');
        END IF;
        
        -- TBL_상품의 재고수량을 갱신 (기존 출고수량 복구 후 새 출고수량 차감)
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 + :OLD.출고수량 - :NEW.출고수량
        WHERE 상품코드 = :NEW.상품코드;

    -- DELETE 작업 시 실행되는 로직
    ELSIF (DELETING)
        THEN 
        -- 출고 취소된 수량만큼 TBL_상품의 재고수량을 증가
        UPDATE TBL_상품
        SET 재고수량 = 재고수량 + :OLD.출고수량
        WHERE 상품코드 = :OLD.상품코드;
    END IF;
END;



































SELECT USER
FROM DUAL;
--==>>SCOTT

SELECT *
FROM TBL_TEST1;
--==>> 조회 결과 없음

SELECT *
FROM TBL_EVENTLOG;
--==>> 조회 결과 없음





--○ TBL_TEST1 테이블에 데이터 입력
INSERT INTO TBL_TEST1(ID,NAME,TEL)
VALUES(1, '안석창','010-1111-1111');
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_TEST1(ID,NAME,TEL)
VALUES(2, '정영훈','010-2222-2222');
--==>>1 행 이(가) 삽입되었습니다.

INSERT INTO TBL_TEST1(ID,NAME,TEL)
VALUES(3, '박지우','010-3333-3333');
--==>>1 행 이(가) 삽입되었습니다.


INSERT INTO TBL_TEST1(ID,NAME,TEL)
VALUES(4, '이은솔','010-4444-4444');
--==>>1 행 이(가) 삽입되었습니다.


--○ TBL_TEST1 테이블의 데이터 수정
UPDATE TBL_TEST1
SET NAME = '박세진'
WHERE ID = 1;
--==>>1 행 이(가) 업데이트되었습니다.

UPDATE TBL_TEST1
SET NAME = '정영훈'
WHERE ID = 2;
--==>>1 행 이(가) 업데이트되었습니다.

SELECT *
FROM TBL_TEST1;
--==>>
/*
1	박세진	010-1111-1111
2	정영훈	010-2222-2222
3	김민승	010-3333-3333
4	이은솔	010-4444-4444
*/


COMMIT;
--==>> 커밋 완료.


--○ TBL_TEST1 테이블의 데이터 삭제
DELETE
FROM TBL_TEST1
WHERE ID = 4;
--==>>1 행 이(가) 삭제되었습니다.

DELETE
FROM TBL_TEST1
WHERE ID = 3;
--==>>1 행 이(가) 삭제되었습니다.

DELETE
FROM TBL_TEST1
WHERE ID = 2;
--==>>1 행 이(가) 삭제되었습니다.

DELETE
FROM TBL_TEST1
WHERE ID = 1;
--==>>1 행 이(가) 삭제되었습니다.

SELECT *
FROM TBL_TEST1;
--==>> 조회 결과 없음

ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';

SELECT *
FROM TBL_EVENTLOG;
--==>>
/*
INSERT 쿼리문이 수행되었습니다.	2024-12-06 09:18:59
INSERT 쿼리문이 수행되었습니다.	2024-12-06 09:19:23
INSERT 쿼리문이 수행되었습니다.	2024-12-06 09:19:45
INSERT 쿼리문이 수행되었습니다.	2024-12-06 09:20:02
UPDATE 쿼리문이 수행되었습니다.	2024-12-06 09:21:11
UPDATE 쿼리문이 수행되었습니다.	2024-12-06 09:21:35
UPDATE 쿼리문이 수행되었습니다.	2024-12-06 09:23:09
UPDATE 쿼리문이 수행되었습니다.	2024-12-06 09:23:16
DELETE 쿼리문이 수행되었습니다.	2024-12-06 09:24:11
DELETE 쿼리문이 수행되었습니다.	2024-12-06 09:24:38
DELETE 쿼리문이 수행되었습니다.	2024-12-06 09:24:51
DELETE 쿼리문이 수행되었습니다.	2024-12-06 09:25:24
*/

--○ 오라클 서버의 시간이 09:45 인 상태로 테스트
INSERT INTO TBL_TEST1(ID,NAME,TEL)
VALUES(5, '곽유진','010-5555-5555');
--==>>1 행 이(가) 삽입되었습니다.

UPDATE TBL_TEST1
SET NAME = '공찬민', TEL = '010-6666-6666'
WHERE ID = 5;
--==>> 1 행 이(가) 업데이트되었습니다.

DELETE
FROM TBL_TEST1
WHERE ID = 5;
--==>>1 행 이(가) 삭제되었습니다.

COMMIT;
--==>> 커밋 완료.





--○ 오라클 서버의 시간이 22:02 인 상태로 테스트

INSERT INTO TBL_TEST1(ID,NAME,TEL)
VALUES(6,'엄서연','010-6666-6666');
--==>> 에러 발생
/*
ORA-20003: 작업은 08:00 ~ 18:00 까지만 가능합니다.
*/

SELECT *
FROM TBL_TEST1;
--==>> 조회 결과 없음


--○ 실습 테이블 생성(BEFORE ROW TRIGGER 실습 진행을 위한 테이블)
-- 테이블명 : TBL_TEST2 → 부모 테이블
CREATE TABLE TBL_TEST2
( CODE NUMBER
, NAME VARCHAR2(40)
, CONSTRAINT TEST2_CODE_PK PRIMARY KEY(CODE)
);
--==>>Table TBL_TEST2이(가) 생성되었습니다.





--○ 실습 테이블 생성(BEFORE ROW TRIGGER 실습 진행을 위한 테이블)
-- 테이블명 : TBL_TEST3 → 자식 테이블
CREATE TABLE TBL_TEST3
( SID   NUMBER
, CODE  NUMBER
, SU    NUMBER
, CONSTRAINT TEST3_SID_PK PRIMARY KEY(SID)
, CONSTRAINT TEST3_CODE_FK FOREIGN KEY(CODE)
            REFERENCES TBL_TEST2(CODE)
);
--==>> Table TBL_TEST3이(가) 생성되었습니다.



--○ 부모 테이블에 데이터 입력
INSERT INTO TBL_TEST2(CODE,NAME) VALUES(1, '냉장고');
INSERT INTO TBL_TEST2(CODE,NAME) VALUES(2, '세탁기');
INSERT INTO TBL_TEST2(CODE,NAME) VALUES(3, '건조기');
--==>> 1 행 이(가) 삽입되었습니다.

SELECT *
FROM TBL_TEST2;
--==>>
/*
1	냉장고
2	세탁기
3	건조기
*/

COMMIT;
--==>> 커밋 완료.


--○ 자식 테이블에 데이터 입력
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(1, 1, 20);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(2, 1, 30);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(3, 1, 40);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(4, 2, 20);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(5, 2, 30);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(6, 2, 40);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(7, 1, 30);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(8, 1, 20);
INSERT INTO TBL_TEST3(SID, CODE, SU) VALUES(9, 2, 20);
--==>> 1 행 이(가) 삽입되었습니다.


DROP TABLE TBL_TEST2;


SELECT *
FROM TBL_TEST3;
/*
1	1	20
2	1	30
3	1	40
4	1	20
5	1	30
6	1	40
7	1	30
8	1	20
9	1	20
*/

COMMIT;
--==>> 커밋 완료.



SELECT C.SID,P.CODE,P.NAME,C.SU
FROM TBL_TEST2 P JOIN TBL_TEST3 C
ON P.CODE = C.CODE;
/*
1	1	냉장고	20
2	1	냉장고	30
3	1	냉장고	40
4	2	세탁기	20
5	2	세탁기	30
6	2	세탁기	40
7	1	냉장고	30
8	1	냉장고	20
9	2	세탁기	20
*/


DELETE
FROM TBL_TEST2
WHERE CODE = 1;
--==>> 에러 발생
/*
ORA-02292: integrity constraint (SCOTT.TEST3_CODE_FK) violated - child record found
*/

DELETE 
FROM TBL_TEST2
WHERE CODE = 2;
--==>> 에러 발생
/*
ORA-02292: integrity constraint (SCOTT.TEST3_CODE_FK) violated - child record found
*/


DELETE 
FROM TBL_TEST2
WHERE CODE = 3;
--==>> 1 행 이(가) 삭제되었습니다.




-- ※ 트리거 작성 이후 다시 테스트

DELETE
FROM TBL_TEST2
WHERE CODE = 1;
--==>>1 행 이(가) 삭제되었습니다.

SELECT *
FROM TBL_TEST2;
--==>>
/*
2	세탁기
*/
SELECT *
FROM TBL_TEST3;
--==>>
/*
4	2	20
5	2	30
6	2	40
9	2	20
*/

SELECT C.SID,P.CODE,P.NAME,C.SU
FROM TBL_TEST2 P JOIN TBL_TEST3 C
ON P.CODE = C.CODE;
--==>>
/*
4	2	세탁기	20
5	2	세탁기	30
6	2	세탁기	40
9	2	세탁기	20
*/


COMMIT;
--==>> 커밋 완료.


DELETE
FROM TBL_TEST2
WHERE CODE = 2;
--==>>1 행 이(가) 삭제되었습니다.


SELECT *
FROM TBL_TEST2;
--==>> 조회 결과 없음


SELECT *
FROM TBL_TEST3;
--==>> 조회 결과 없음

COMMIT;
--==>> 커밋 완료.

--------------------------------------------------------------------------------

SELECT *
FROM TBL_상품;
/*
H001	홈런볼	1500	15
H002	새우깡	1200	30
H003	스윙칩	1000	15
H004	치토스	1100	0
H005	밭두렁	1000	0
H006	오감자	2000	30
H007	양파링	1700	0
C001	초코칩	1800	15
C002	버터링	1900	30
C003	에이스	1700	15
C004	오레오	2200	0
C005	다이제	2500	0
C006	아이비	1200	30
C007	오예스	3500	0
E001	마이쮸	1000	15
E002	엠엔엠	1100	30
E003	아이셔	1100	0
E004	비틀즈	1200	0
E005	아폴로	1000	0
E006	새콤달	1500	30
E007	말랑카	1600	0
*/

SELECT *
FROM TBL_입고;
/*
1	H001	2024-12-04 15:23:02	20	1000
2	H001	2024-12-04 15:23:02	10	1000
3	H002	2024-12-04 15:23:02	20	1000
4	H002	2024-12-04 15:23:02	10	1000
5	H003	2024-12-04 15:23:02	20	1000
6	H003	2024-12-04 15:23:02	10	1000
7	H006	2024-12-04 15:23:02	20	1000
8	H006	2024-12-04 15:23:02	10	1000
9	C001	2024-12-04 15:23:02	20	1000
10	C001	2024-12-04 15:23:02	10	1000
11	C002	2024-12-04 15:23:02	20	1000
12	C002	2024-12-04 15:23:02	10	1000
13	C003	2024-12-04 15:23:02	20	1000
14	C003	2024-12-04 15:23:02	10	1000
15	C006	2024-12-04 15:23:02	20	1000
16	C006	2024-12-04 15:23:02	10	1000
17	E001	2024-12-04 15:23:02	20	1000
18	E001	2024-12-04 15:23:02	10	1000
19	E002	2024-12-04 15:23:02	20	1000
20	E002	2024-12-04 15:23:02	10	1000
21	E003	2024-12-04 15:23:02	20	1000
22	E003	2024-12-04 15:23:02	10	1000
23	E006	2024-12-04 15:23:02	20	1000
24	E006	2024-12-04 15:23:02	10	1000
*/

SELECT *
FROM TBL_출고;
/*
1	H001	2024-12-04 15:26:06	5	1000
2	H001	2024-12-04 15:26:06	10	1000
3	H003	2024-12-04 15:26:06	5	1000
4	H003	2024-12-04 15:26:06	10	1000
5	C001	2024-12-04 15:26:10	5	1000
6	C001	2024-12-04 15:26:10	10	1000
7	C003	2024-12-04 15:26:10	5	1000
8	C003	2024-12-04 15:26:10	10	1000
9	E001	2024-12-04 15:26:14	5	1000
10	E001	2024-12-04 15:26:14	10	1000
11	E003	2024-12-04 15:26:14	5	1000
12	E003	2024-12-04 15:26:14	25	1000
*/



--○ 입고 테이블에 입고 이벤트 발생
INSERT INTO TBL_입고(입고번호,상품코드,입고수량,입고단가)
VALUES(25,'H004',100,1000);
--==>>1 행 이(가) 삽입되었습니다.

SELECT *
FROM TBL_입고;
/*
                :
                :
25	H004	2024-12-06 23:25:03	100	1000

*/

SELECT *
FROM TBL_상품;
--==>>
/*
                :
H004	치토스	1100	100
                :
*/

COMMIT;
--==>> 커밋 완료.





INSERT INTO TBL_출고(출고번호,상품코드,출고수량,출고단가)
VALUES(13,'H001',10,1000);



DELETE
FROM TBL_출고
WHERE 출고번호 = 1;


SELECT *
FROM TBL_출고;
SELECT *
FROM TBL_상품;




ROLLBACK;




SELECT USER
FROM DUAL;
--==>>SCOTT




--■■■ PACKAGE(패키지) ■■■--

--1. PL/SQL 의 패키지는 관계되는 타입, 프로그램 객체.
--   서브 프로그램(PRODECURE, FUNCTION 등) 을
--   논리적으로 묶어놓은 것으로
--   오라클에서 제공하는 패키지 중 하나가 바로 『DBMS_OUTPUT』이다.

--2. 패키지는 서로 유사한 업무에 사용되는 여러 개의 프로시저와 함수를
--   하나의 패키지로 만들어 관리함으로써 향후 유지보수가 편리하고
--   전체 프로그램을 모듈화 할 수 있는 장점이 있다.

--3. 패키지는 명세부(PACKAGE SPECIFICATION)와
--   몸체부(PACKAGE BODY)로 구성되어 있으며,
--   명세 부분에는 TYPE, CONSTRAINT, VARIABLE, EXCEPTION, 
--   CURSOR, SUBPROGRAM 등이 선언되고
--   몸체 부분에는 이들의 실제 내용이 존재하게 된다.
--   그리고 호출할 때에는 『패키지명.프로시저명』형식의 참조를 이용해야 한다.


--4. 형식 및 구조(명세부)
/*
CREATE [OR RAPLACE] PACKAGE 패키지명
IS
    전역변수 선언;
    커서 선언;
    예외 선언;
    함수 선언;
    프로시저 선언;
        :
END 패키지명;
*/
--5. 형식 및 구조(몸체부)
/*
CREATE [OR REPLACE] PACKAGE BODY 패키지명
IS
    FUNCTION 함수명[(인수, ...)]
    RETURN 자료형
    IS
        변수 선언;
    BRGIN
        함수 몸체 구성 코드;
        RETURN 값;
    END;
    
    PROCEDURE 프리시저명[(인수, ...)]
    IS  
        변수 선언;
    BEGIN
        프로시저 몸체 구성 코드;
    END;
END 패키지명;
*/


--○ 주민번호 입력 시 성별을 반환하는 함수
--  이 함수를 구성요소로 취하는 패키지 작성

-- 함수 준비
CREATE OR REPLACE FUNCTION FN_GENDER(V_SSN VARCHAR2)
RETURN VARCHAR2
IS
    V_RESULT VARCHAR2(20);
BEGIN
    IF(SUBSTR(V_SSN,8,1) IN ('1','3'))
        THEN V_RESULT := '남자';
    ELSIF (SUBSTR(V_SSN,8,1) IN ('2','4'))
        THEN V_RESULT := '여자';
    ELSE
        V_RESULT := '성별확인불가';
    END IF;
    
    RETURN V_RESULT;
END;
--==>> Function FN_GENDER이(가) 컴파일되었습니다.



-- 패키지 등록

--1. 명세부 작성
CREATE OR REPLACE PACKAGE INSA_PACK
IS
    FUNCTION FN_GENDER(V_SSN VARCHAR2)
    RETURN VARCHAR2;
    
END INSA_PACK;
--==>> Package INSA_PACK이(가) 컴파일되었습니다.


--2. 몸체부 작성
CREATE OR REPLACE PACKAGE BODY INSA_PACK
IS
    FUNCTION FN_GENDER(V_SSN VARCHAR2)
    RETURN VARCHAR2
    IS
        V_RESULT VARCHAR2(20);
    BEGIN
        IF(SUBSTR(V_SSN,8,1) IN ('1','3'))
            THEN V_RESULT := '남자';
        ELSIF (SUBSTR(V_SSN,8,1) IN ('2','4'))
            THEN V_RESULT := '여자';
        ELSE
            V_RESULT := '성별확인불가';
        END IF;
        
        RETURN V_RESULT;
    END;
END INSA_PACK;
--==>>Package Body INSA_PACK이(가) 컴파일되었습니다.








SELECT USER
FROM DUAL;
--==>>SCOTT



--○ 구성한 패키지가 유효한지 확인(테스트)
--  → 패키지에 논리적으로 구성된 함수 호출 확인
SELECT INSA_PACK.FN_GENDER('950612-1639329')"호출 확인"
FROM DUAL;
--==>>남자


SELECT NAME, SSN, INSA_PACK.FN_GENDER(SSN)"호출 확인"
FROM TBL_INSA;
--==>>
/*
홍길동	771212-1022432	남자
이순신	801007-1544236	남자
이순애	770922-2312547	여자
김정훈	790304-1788896	남자
한석봉	811112-1566789	남자
이기자	780505-2978541	여자
장인철	780506-1625148	남자
김영년	821011-2362514	여자
나윤균	810810-1552147	남자
김종서	751010-1122233	남자
유관순	801010-2987897	여자
정한국	760909-1333333	남자
조미숙	790102-2777777	여자
황진이	810707-2574812	여자
이현숙	800606-2954687	여자
이상헌	781010-1666678	남자
엄용수	820507-1452365	남자
이성길	801028-1849534	남자
박문수	780710-1985632	남자
유영희	800304-2741258	여자
홍길남	801010-1111111	남자
이영숙	800501-2312456	여자
김인수	731211-1214576	남자
김말자	830225-2633334	여자
우재옥	801103-1654442	남자
김숙남	810907-2015457	여자
김영길	801216-1898752	남자
이남신	810101-1010101	남자
김말숙	800301-2020202	여자
정정해	790210-2101010	여자
지재환	771115-1687988	남자
심심해	810206-2222222	여자
김미나	780505-2999999	여자
이정석	820505-1325468	남자
정영희	831010-2153252	여자
이재영	701126-2852147	여자
최석규	770129-1456987	남자
손인수	791009-2321456	여자
고순정	800504-2000032	여자
박세열	790509-1635214	남자
문길수	721217-1951357	남자
채정희	810709-2000054	여자
양미옥	830504-2471523	여자
지수환	820305-1475286	남자
홍원신	690906-1985214	남자
허경운	760105-1458752	남자
산마루	780505-1234567	남자
이기상	790604-1415141	남자
이미성	830908-2456548	여자
이미인	810403-2828287	여자
권영미	790303-2155554	여자
권옥경	820406-2000456	여자
김싱식	800715-1313131	남자
정상호	810705-1212141	남자
정한나	820506-2425153	여자
전용재	800605-1456987	남자
이미경	780406-2003214	여자
김신제	800709-1321456	남자
임수봉	810809-2121244	여자
김신애	810809-2111111	여자
안예지	980716-2234567	여자
*/SELECT USER
FROM DUAL;
--==>>SCOTT


--> 성적 테이블 생성 (TBL_SCORE)
CREATE TABLE TBL_SCORE          
(SC_CODE NUMBER     NOT NULL
,SG_CODE NUMBER     NOT NULL
,OPS_CODE NUMBER    NOT NULL
,CHUL NUMBER
,SIL NUMBER
,PIL NUMBER
);
--==>> Table TBL_SCORE이(가) 생성되었습니다.


--> 관리자 테이블 생성(TBL_ADMIN)
CREATE TABLE TBL_ADMIN          
(AD_CODE NUMBER      NOT NULL
,AD_NAME VARCHAR2(20)    NOT NULL
,PW      VARCHAR2(30)    NOT NULL
);
--==>>Table TBL_ADMIN이(가) 생성되었습니다.



--> ADMIN TABLE 제약조건 추가 (AD_CODE) >> PK
ALTER TABLE TBL_ADMIN           
ADD CONSTRAINT ADMIN_AD_CODE_PK PRIMARY KEY(AD_CODE);
--==>>Table TBL_ADMIN이(가) 변경되었습니다.


--> SCORE TABLE 제약조건 추가 (SC_CODE) >> PK
ALTER TABLE TBL_SCORE 
ADD CONSTRAINT SCORE_SC_CODE_PK PRIMARY KEY(SC_CODE);
--==>>Table TBL_SCORE이(가) 변경되었습니다.


--> SCORE TABLE 과 TBL_SUGANG TABLE 외래키 지정
ALTER TABLE TBL_SCORE 
ADD CONSTRAINT SCORE_SG_CODE_FK FOREIGN KEY(SG_CODE)
                    REFERENCES TBL_SUGANG(SG_CODE);
--==>> Table TBL_SCORE이(가) 변경되었습니다.








--> 출결,실기,필기 제약조건 변경 0에서 100까지의 수 지정
ALTER TABLE TBL_SCORE
ADD CONSTRAINT SCORE_CHUL_CK CHECK(CHUL BETWEEN 0 AND 100);
--==>>Table TBL_SCORE이(가) 변경되었습니다.
ALTER TABLE TBL_SCORE
ADD CONSTRAINT SCORE_SIL_CK CHECK(SIL BETWEEN 0 AND 100);
--==>>Table TBL_SCORE이(가) 변경되었습니다.
ALTER TABLE TBL_SCORE
ADD CONSTRAINT SCORE_PIL_CK CHECK(PIL BETWEEN 0 AND 100);
--==>>Table TBL_SCORE이(가) 변경되었습니다.


-- TBL_SCORE INSERT 할 벨류값 정의(성적코드,수강신청코드,개설과목코드,출결,실기,필기)
INSERT INTO TBL_SCORE(SC_CODE,SG_CODE,OPS_CODE,CHUL,SIL,PIL)
VALUES(1,1,1,30,40,30);
INSERT INTO TBL_SCORE(SC_CODE,SG_CODE,OPS_CODE,CHUL,SIL,PIL)
VALUES(2,2,2,20,40,40);
INSERT INTO TBL_SCORE(SC_CODE,SG_CODE,OPS_CODE,CHUL,SIL,PIL)
VALUES(3,3,3,10,40,60);
-- TBL_ADMIN INSERT 할 벨류값 정의 
INSERT INTO TBL_ADMIN(AD_CODE,AD_NAME,PW)
VALUES(90001,'박제훈','JAVA006');
INSERT INTO TBL_ADMIN(AD_CODE,AD_NAME,PW)
VALUES(90002,'윤영식','JAVA007');
INSERT INTO TBL_ADMIN(AD_CODE,AD_NAME,PW)
VALUES(90003,'엄서연','JAVA008');
INSERT INTO TBL_ADMIN(AD_CODE,AD_NAME,PW)
VALUES(90004,'정승민','JAVA009');




/*
- 관리자는 여러 명의 교수자를 사전에 등록할 수 있어야 한다. → 인서트

- 입력 정보는 (교수자 이름, 주민등록번호 뒷자리)를 기본으로 등록하고, 
  주민등록번호 뒷자리는 교수자 본인이 로그인 시 패스워드로 사용되도록 한다. 
  
- 해당 교수자가 로그인 과정을 통해 자신이 강의한 과목의 성적 처리 업무를
  수행할 수 있어야 한다. 
  --==>> 개설과목 정보테이블에 있는 출결 실기 필기 비중 인서트
  
- 관리자는 등록된 모든 교수자의 정보를 출력하여 볼 수 있어야 한다. 
  --==>> 교수자 정보 뷰로 만들기

- 출력 정보는 교수자 명, 배정된 과목명, 과목 기간(시작 연월일, 끝 연월일), 교재 명, 강의실, 
  강의 진행 여부(강의 예정, 강의 중, 강의 종료)를 출력한다. 
  --==>> 조인 활용하여 뷰로 생성
  
- 관리자는 입력된 교수자 정보에 대하여 수정, 삭제할 수 있어야 한다.
*/




SELECT P.PRO_NAME"교수자명",O.STA_DATE"시작연월일",O.END_DATE"끝연월일"
FROM TBL_PROFESSORS P JOIN TBL_OPSUB O
ON P.PRO_CODE = O.PRO_CODE;






SELECT USER
FROM DUAL;
--==>> PJH



--○ 테이블 생성
-- 테이블명 : TBL_ORAUSERTEST
CREATE TABLE TBL_ORAUSERTEST
(   NO          NUMBER(10)
    ,NAME        VARCHAR2(30)
);
--==>> 에러 발생
/*
ORA-01031: insufficient privileges
01031. 00000 -  "insufficient privileges"
*Cause:    An attempt was made to perform a database operation without
           the necessary privileges.
*Action:   Ask your database administrator or designated security
           administrator to grant you the necessary privileges
*/

--> 현재 PJH 계정은 CREATE SESSION 권한만 갖고 있으며
--  테이블을 생성할 수 있는 권한은 갖고있지 않은 상태이다.
--  그러므로 이 계정이 테이블을 생성하기 위해서는
--  관리자로부터 테이블 생성 권한을 부여받아야 한다.


--○ SYS로 부터... CREATE TABLE 권한을 부여받은 후
--   다시 테이블 생성
-- 테이블명 : TBL_ORAUSERTEST
CREATE TABLE TBL_ORAUSERTEST
(   NO          NUMBER(10)
    ,NAME        VARCHAR2(30)
);
/*
ORA-01950: no privileges on tablespace 'TBS_EDUA'
01950. 00000 -  "no privileges on tablespace '%s'"
*Cause:    User does not have privileges to allocate an extent in the
           specified tablespace.
*Action:   Grant the user the appropriate system privileges or grant the user
           space resource on the tablespace.
*/

--> 테이블 생성 권한(CREATE TABLE)까지 부여받은 상황이지만
--  PJH 사용자 계정의 기본 테이블 스페이스(DEFAULT TABLE SPACE : TBS_EDUA)에 대한
--  사용 권한(할당량)을 부여받지 못한 상태.
--  그러므로 이 테이블스페이스를 사용할 수 있는 권한이 없다는
--  에러메세지를 오라클이 출력해 주고 있는 상황.


--○ SYS로 부터... 테이블스페이스(TBS_EDUA)에 대한 할당량을 부여받은 이후
--   다시 테이블 생성
-- 테이블명 : TBL_ORAUSERTEST
CREATE TABLE TBL_ORAUSERTEST
(   NO          NUMBER(10)
    ,NAME        VARCHAR2(30)
);
--==>> Table TBL_ORAUSERTEST이(가) 생성되었습니다.

--※ 자신에게 부여된 할당량 조회

SELECT *
FROM USER_TS_QUOTAS;
--==>> TBS_EDUA	65536	-1	8	-1	NO
--                     ---
--                    무제한
SELECT USER
FROM DUAL;
--==>> SCOTT


--○ 테이블 생성 (SCOTT.TBL_INSA)
CREATE TABLE TBL_INSA
( NUM      NUMBER(5)    NOT NULL
, NAME     VARCHAR2(20) NOT NULL
, SSN      VARCHAR2(14) NOT NULL
, IBSADATE DATE         NOT NULL
, CITY     VARCHAR2(10)
, TEL      VARCHAR2(15)
, BUSEO    VARCHAR2(15) NOT NULL
, JIKWI    VARCHAR2(15) NOT NULL
, BASICPAY NUMBER(10)   NOT NULL
, SUDANG   NUMBER(10)   NOT NULL
, CONSTRAINT TBL_INSA_NUM_PK PRIMARY KEY(NUM)
);
--==>> Table TBL_INSA이(가) 생성되었습니다.


--※ 세션 기본값 설정
ALTER SESSION SET NLS_DATE_FORMAT ='YYYY-MM-DD';
--==>> Session이(가) 변경되었습니다.


--○ 데이터 입력
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1001, '홍길동', '771212-1022432', '1998-10-11', '서울', '011-2356-4528', '기획부', '부장', 2610000, 200000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1002, '이순신', '801007-1544236', '2000-11-29', '경기', '010-4758-6532', '총무부', '사원', 1320000, 200000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1003, '이순애', '770922-2312547', '1999-02-25', '인천', '010-4231-1236', '개발부', '부장', 2550000, 160000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1004, '김정훈', '790304-1788896', '2000-10-01', '전북', '019-5236-4221', '영업부', '대리', 1954200, 170000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1005, '한석봉', '811112-1566789', '2004-08-13', '서울', '018-5211-3542', '총무부', '사원', 1420000, 160000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1006, '이기자', '780505-2978541', '2002-02-11', '인천', '010-3214-5357', '개발부', '과장', 2265000, 150000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1007, '장인철', '780506-1625148', '1998-03-16', '제주', '011-2345-2525', '개발부', '대리', 1250000, 150000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1008, '김영년', '821011-2362514', '2002-04-30', '서울', '016-2222-4444', '홍보부', '사원', 950000 , 145000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1009, '나윤균', '810810-1552147', '2003-10-10', '경기', '019-1111-2222', '인사부', '사원', 840000 , 220400);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1010, '김종서', '751010-1122233', '1997-08-08', '부산', '011-3214-5555', '영업부', '부장', 2540000, 130000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1011, '유관순', '801010-2987897', '2000-07-07', '서울', '010-8888-4422', '영업부', '사원', 1020000, 140000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1012, '정한국', '760909-1333333', '1999-10-16', '강원', '018-2222-4242', '홍보부', '사원', 880000 , 114000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1013, '조미숙', '790102-2777777', '1998-06-07', '경기', '019-6666-4444', '홍보부', '대리', 1601000, 103000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1014, '황진이', '810707-2574812', '2002-02-15', '인천', '010-3214-5467', '개발부', '사원', 1100000, 130000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1015, '이현숙', '800606-2954687', '1999-07-26', '경기', '016-2548-3365', '총무부', '사원', 1050000, 104000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1016, '이상헌', '781010-1666678', '2001-11-29', '경기', '010-4526-1234', '개발부', '과장', 2350000, 150000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1017, '엄용수', '820507-1452365', '2000-08-28', '인천', '010-3254-2542', '개발부', '사원', 950000 , 210000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1018, '이성길', '801028-1849534', '2004-08-08', '전북', '018-1333-3333', '개발부', '사원', 880000 , 123000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1019, '박문수', '780710-1985632', '1999-12-10', '서울', '017-4747-4848', '인사부', '과장', 2300000, 165000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1020, '유영희', '800304-2741258', '2003-10-10', '전남', '011-9595-8585', '자재부', '사원', 880000 , 140000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1021, '홍길남', '801010-1111111', '2001-09-07', '경기', '011-9999-7575', '개발부', '사원', 875000 , 120000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1022, '이영숙', '800501-2312456', '2003-02-25', '전남', '017-5214-5282', '기획부', '대리', 1960000, 180000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1023, '김인수', '731211-1214576', '1995-02-23', '서울', NULL           , '영업부', '부장', 2500000, 170000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1024, '김말자', '830225-2633334', '1999-08-28', '서울', '011-5248-7789', '기획부', '대리', 1900000, 170000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1025, '우재옥', '801103-1654442', '2000-10-01', '서울', '010-4563-2587', '영업부', '사원', 1100000, 160000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1026, '김숙남', '810907-2015457', '2002-08-28', '경기', '010-2112-5225', '영업부', '사원', 1050000, 150000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1027, '김영길', '801216-1898752', '2000-10-18', '서울', '019-8523-1478', '총무부', '과장', 2340000, 170000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1028, '이남신', '810101-1010101', '2001-09-07', '제주', '016-1818-4848', '인사부', '사원', 892000 , 110000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1029, '김말숙', '800301-2020202', '2000-09-08', '서울', '016-3535-3636', '총무부', '사원', 920000 , 124000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1030, '정정해', '790210-2101010', '1999-10-17', '부산', '019-6564-6752', '총무부', '과장', 2304000, 124000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1031, '지재환', '771115-1687988', '2001-01-21', '서울', '019-5552-7511', '기획부', '부장', 2450000, 160000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1032, '심심해', '810206-2222222', '2000-05-05', '전북', '016-8888-7474', '자재부', '사원', 880000 , 108000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1033, '김미나', '780505-2999999', '1998-06-07', '서울', '011-2444-4444', '영업부', '사원', 1020000, 104000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1034, '이정석', '820505-1325468', '2005-09-26', '경기', '011-3697-7412', '기획부', '사원', 1100000, 160000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1035, '정영희', '831010-2153252', '2002-05-16', '인천', NULL           , '개발부', '사원', 1050000, 140000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1036, '이재영', '701126-2852147', '2003-08-10', '서울', '011-9999-9999', '자재부', '사원', 960400 , 190000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1037, '최석규', '770129-1456987', '1998-10-15', '인천', '011-7777-7777', '홍보부', '과장', 2350000, 187000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1038, '손인수', '791009-2321456', '1999-11-15', '부산', '010-6542-7412', '영업부', '대리', 2000000, 150000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1039, '고순정', '800504-2000032', '2003-12-28', '경기', '010-2587-7895', '영업부', '대리', 2010000, 160000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1040, '박세열', '790509-1635214', '2000-09-10', '경북', '016-4444-7777', '인사부', '대리', 2100000, 130000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1041, '문길수', '721217-1951357', '2001-12-10', '충남', '016-4444-5555', '자재부', '과장', 2300000, 150000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1042, '채정희', '810709-2000054', '2003-10-17', '경기', '011-5125-5511', '개발부', '사원', 1020000, 200000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1043, '양미옥', '830504-2471523', '2003-09-24', '서울', '016-8548-6547', '영업부', '사원', 1100000, 210000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1044, '지수환', '820305-1475286', '2004-01-21', '서울', '011-5555-7548', '영업부', '사원', 1060000, 220000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1045, '홍원신', '690906-1985214', '2003-03-16', '전북', '011-7777-7777', '영업부', '사원', 960000 , 152000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1046, '허경운', '760105-1458752', '1999-05-04', '경남', '017-3333-3333', '총무부', '부장', 2650000, 150000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1047, '산마루', '780505-1234567', '2001-07-15', '서울', '018-0505-0505', '영업부', '대리', 2100000, 112000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1048, '이기상', '790604-1415141', '2001-06-07', '전남', NULL           , '개발부', '대리', 2050000, 106000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1049, '이미성', '830908-2456548', '2000-04-07', '인천', '010-6654-8854', '개발부', '사원', 1300000, 130000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1050, '이미인', '810403-2828287', '2003-06-07', '경기', '011-8585-5252', '홍보부', '대리', 1950000, 103000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1051, '권영미', '790303-2155554', '2000-06-04', '서울', '011-5555-7548', '영업부', '과장', 2260000, 104000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1052, '권옥경', '820406-2000456', '2000-10-10', '경기', '010-3644-5577', '기획부', '사원', 1020000, 105000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1053, '김싱식', '800715-1313131', '1999-12-12', '전북', '011-7585-7474', '자재부', '사원', 960000 , 108000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1054, '정상호', '810705-1212141', '1999-10-16', '강원', '016-1919-4242', '홍보부', '사원', 980000 , 114000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1055, '정한나', '820506-2425153', '2004-06-07', '서울', '016-2424-4242', '영업부', '사원', 1000000, 104000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1056, '전용재', '800605-1456987', '2004-08-13', '인천', '010-7549-8654', '영업부', '대리', 1950000, 200000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1057, '이미경', '780406-2003214', '1998-02-11', '경기', '016-6542-7546', '자재부', '부장', 2520000, 160000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1058, '김신제', '800709-1321456', '2003-08-08', '인천', '010-2415-5444', '기획부', '대리', 1950000, 180000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1059, '임수봉', '810809-2121244', '2001-10-10', '서울', '011-4151-4154', '개발부', '사원', 890000 , 102000);
INSERT INTO TBL_INSA (NUM, NAME, SSN, IBSADATE, CITY, TEL, BUSEO, JIKWI, BASICPAY, SUDANG)
VALUES (1060, '김신애', '810809-2111111', '2001-10-10', '서울', '011-4151-4444', '개발부', '사원', 900000 , 102000);
--==>>1 행 이(가) 삽입되었습니다. * 60


--○ 커밋
COMMIT;


SELECT *
FROM TBL_INSA;
--==>>
/*
1001	홍길동	771212-1022432	1998-10-11	서울	011-2356-4528	기획부	부장	2610000	200000
1002	이순신	801007-1544236	2000-11-29	경기	010-4758-6532	총무부	사원	1320000	200000
1003	이순애	770922-2312547	1999-02-25	인천	010-4231-1236	개발부	부장	2550000	160000
1004	김정훈	790304-1788896	2000-10-01	전북	019-5236-4221	영업부	대리	1954200	170000
1005	한석봉	811112-1566789	2004-08-13	서울	018-5211-3542	총무부	사원	1420000	160000
1006	이기자	780505-2978541	2002-02-11	인천	010-3214-5357	개발부	과장	2265000	150000
1007	장인철	780506-1625148	1998-03-16	제주	011-2345-2525	개발부	대리	1250000	150000
1008	김영년	821011-2362514	2002-04-30	서울	016-2222-4444	홍보부	사원	950000	145000
1009	나윤균	810810-1552147	2003-10-10	경기	019-1111-2222	인사부	사원	840000	220400
1010	김종서	751010-1122233	1997-08-08	부산	011-3214-5555	영업부	부장	2540000	130000
1011	유관순	801010-2987897	2000-07-07	서울	010-8888-4422	영업부	사원	1020000	140000
1012	정한국	760909-1333333	1999-10-16	강원	018-2222-4242	홍보부	사원	880000	114000
1013	조미숙	790102-2777777	1998-06-07	경기	019-6666-4444	홍보부	대리	1601000	103000
1014	황진이	810707-2574812	2002-02-15	인천	010-3214-5467	개발부	사원	1100000	130000
1015	이현숙	800606-2954687	1999-07-26	경기	016-2548-3365	총무부	사원	1050000	104000
1016	이상헌	781010-1666678	2001-11-29	경기	010-4526-1234	개발부	과장	2350000	150000
1017	엄용수	820507-1452365	2000-08-28	인천	010-3254-2542	개발부	사원	950000	210000
1018	이성길	801028-1849534	2004-08-08	전북	018-1333-3333	개발부	사원	880000	123000
1019	박문수	780710-1985632	1999-12-10	서울	017-4747-4848	인사부	과장	2300000	165000
1020	유영희	800304-2741258	2003-10-10	전남	011-9595-8585	자재부	사원	880000	140000
1021	홍길남	801010-1111111	2001-09-07	경기	011-9999-7575	개발부	사원	875000	120000
1022	이영숙	800501-2312456	2003-02-25	전남	017-5214-5282	기획부	대리	1960000	180000
1023	김인수	731211-1214576	1995-02-23	서울		영업부	부장	2500000	170000
1024	김말자	830225-2633334	1999-08-28	서울	011-5248-7789	기획부	대리	1900000	170000
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000
1026	김숙남	810907-2015457	2002-08-28	경기	010-2112-5225	영업부	사원	1050000	150000
1027	김영길	801216-1898752	2000-10-18	서울	019-8523-1478	총무부	과장	2340000	170000
1028	이남신	810101-1010101	2001-09-07	제주	016-1818-4848	인사부	사원	892000	110000
1029	김말숙	800301-2020202	2000-09-08	서울	016-3535-3636	총무부	사원	920000	124000
1030	정정해	790210-2101010	1999-10-17	부산	019-6564-6752	총무부	과장	2304000	124000
1031	지재환	771115-1687988	2001-01-21	서울	019-5552-7511	기획부	부장	2450000	160000
1032	심심해	810206-2222222	2000-05-05	전북	016-8888-7474	자재부	사원	880000	108000
1033	김미나	780505-2999999	1998-06-07	서울	011-2444-4444	영업부	사원	1020000	104000
1034	이정석	820505-1325468	2005-09-26	경기	011-3697-7412	기획부	사원	1100000	160000
1035	정영희	831010-2153252	2002-05-16	인천		개발부	사원	1050000	140000
1036	이재영	701126-2852147	2003-08-10	서울	011-9999-9999	자재부	사원	960400	190000
1037	최석규	770129-1456987	1998-10-15	인천	011-7777-7777	홍보부	과장	2350000	187000
1038	손인수	791009-2321456	1999-11-15	부산	010-6542-7412	영업부	대리	2000000	150000
1039	고순정	800504-2000032	2003-12-28	경기	010-2587-7895	영업부	대리	2010000	160000
1040	박세열	790509-1635214	2000-09-10	경북	016-4444-7777	인사부	대리	2100000	130000
1041	문길수	721217-1951357	2001-12-10	충남	016-4444-5555	자재부	과장	2300000	150000
1042	채정희	810709-2000054	2003-10-17	경기	011-5125-5511	개발부	사원	1020000	200000
1043	양미옥	830504-2471523	2003-09-24	서울	016-8548-6547	영업부	사원	1100000	210000
1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000
1045	홍원신	690906-1985214	2003-03-16	전북	011-7777-7777	영업부	사원	960000	152000
1046	허경운	760105-1458752	1999-05-04	경남	017-3333-3333	총무부	부장	2650000	150000
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000
1048	이기상	790604-1415141	2001-06-07	전남		개발부	대리	2050000	106000
1049	이미성	830908-2456548	2000-04-07	인천	010-6654-8854	개발부	사원	1300000	130000
1050	이미인	810403-2828287	2003-06-07	경기	011-8585-5252	홍보부	대리	1950000	103000
1051	권영미	790303-2155554	2000-06-04	서울	011-5555-7548	영업부	과장	2260000	104000
1052	권옥경	820406-2000456	2000-10-10	경기	010-3644-5577	기획부	사원	1020000	105000
1053	김싱식	800715-1313131	1999-12-12	전북	011-7585-7474	자재부	사원	960000	108000
1054	정상호	810705-1212141	1999-10-16	강원	016-1919-4242	홍보부	사원	980000	114000
1055	정한나	820506-2425153	2004-06-07	서울	016-2424-4242	영업부	사원	1000000	104000
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000
1057	이미경	780406-2003214	1998-02-11	경기	016-6542-7546	자재부	부장	2520000	160000
1058	김신제	800709-1321456	2003-08-08	인천	010-2415-5444	기획부	대리	1950000	180000
1059	임수봉	810809-2121244	2001-10-10	서울	011-4151-4154	개발부	사원	890000	102000
1060	김신애	810809-2111111	2001-10-10	서울	011-4151-4444	개발부	사원	900000	102000
*/

------------------------------------------------------------------------------------------------------------
-- 박제훈_3팀

--01. TBL_INSA 테이블 전체자료 조회
SELECT *
FROM TBL_INSA;
/*
1001	홍길동	771212-1022432	1998-10-11	서울	011-2356-4528	기획부	부장	2610000	200000
1002	이순신	801007-1544236	2000-11-29	경기	010-4758-6532	총무부	사원	1320000	200000
1003	이순애	770922-2312547	1999-02-25	인천	010-4231-1236	개발부	부장	2550000	160000
1004	김정훈	790304-1788896	2000-10-01	전북	019-5236-4221	영업부	대리	1954200	170000
1005	한석봉	811112-1566789	2004-08-13	서울	018-5211-3542	총무부	사원	1420000	160000
1006	이기자	780505-2978541	2002-02-11	인천	010-3214-5357	개발부	과장	2265000	150000
1007	장인철	780506-1625148	1998-03-16	제주	011-2345-2525	개발부	대리	1250000	150000
1008	김영년	821011-2362514	2002-04-30	서울	016-2222-4444	홍보부	사원	950000	145000
1009	나윤균	810810-1552147	2003-10-10	경기	019-1111-2222	인사부	사원	840000	220400
1010	김종서	751010-1122233	1997-08-08	부산	011-3214-5555	영업부	부장	2540000	130000
1011	유관순	801010-2987897	2000-07-07	서울	010-8888-4422	영업부	사원	1020000	140000
1012	정한국	760909-1333333	1999-10-16	강원	018-2222-4242	홍보부	사원	880000	114000
1013	조미숙	790102-2777777	1998-06-07	경기	019-6666-4444	홍보부	대리	1601000	103000
1014	황진이	810707-2574812	2002-02-15	인천	010-3214-5467	개발부	사원	1100000	130000
1015	이현숙	800606-2954687	1999-07-26	경기	016-2548-3365	총무부	사원	1050000	104000
1016	이상헌	781010-1666678	2001-11-29	경기	010-4526-1234	개발부	과장	2350000	150000
1017	엄용수	820507-1452365	2000-08-28	인천	010-3254-2542	개발부	사원	950000	210000
1018	이성길	801028-1849534	2004-08-08	전북	018-1333-3333	개발부	사원	880000	123000
1019	박문수	780710-1985632	1999-12-10	서울	017-4747-4848	인사부	과장	2300000	165000
1020	유영희	800304-2741258	2003-10-10	전남	011-9595-8585	자재부	사원	880000	140000
1021	홍길남	801010-1111111	2001-09-07	경기	011-9999-7575	개발부	사원	875000	120000
1022	이영숙	800501-2312456	2003-02-25	전남	017-5214-5282	기획부	대리	1960000	180000
1023	김인수	731211-1214576	1995-02-23	서울		영업부	부장	2500000	170000
1024	김말자	830225-2633334	1999-08-28	서울	011-5248-7789	기획부	대리	1900000	170000
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000
1026	김숙남	810907-2015457	2002-08-28	경기	010-2112-5225	영업부	사원	1050000	150000
1027	김영길	801216-1898752	2000-10-18	서울	019-8523-1478	총무부	과장	2340000	170000
1028	이남신	810101-1010101	2001-09-07	제주	016-1818-4848	인사부	사원	892000	110000
1029	김말숙	800301-2020202	2000-09-08	서울	016-3535-3636	총무부	사원	920000	124000
1030	정정해	790210-2101010	1999-10-17	부산	019-6564-6752	총무부	과장	2304000	124000
1031	지재환	771115-1687988	2001-01-21	서울	019-5552-7511	기획부	부장	2450000	160000
1032	심심해	810206-2222222	2000-05-05	전북	016-8888-7474	자재부	사원	880000	108000
1033	김미나	780505-2999999	1998-06-07	서울	011-2444-4444	영업부	사원	1020000	104000
1034	이정석	820505-1325468	2005-09-26	경기	011-3697-7412	기획부	사원	1100000	160000
1035	정영희	831010-2153252	2002-05-16	인천		개발부	사원	1050000	140000
1036	이재영	701126-2852147	2003-08-10	서울	011-9999-9999	자재부	사원	960400	190000
1037	최석규	770129-1456987	1998-10-15	인천	011-7777-7777	홍보부	과장	2350000	187000
1038	손인수	791009-2321456	1999-11-15	부산	010-6542-7412	영업부	대리	2000000	150000
1039	고순정	800504-2000032	2003-12-28	경기	010-2587-7895	영업부	대리	2010000	160000
1040	박세열	790509-1635214	2000-09-10	경북	016-4444-7777	인사부	대리	2100000	130000
1041	문길수	721217-1951357	2001-12-10	충남	016-4444-5555	자재부	과장	2300000	150000
1042	채정희	810709-2000054	2003-10-17	경기	011-5125-5511	개발부	사원	1020000	200000
1043	양미옥	830504-2471523	2003-09-24	서울	016-8548-6547	영업부	사원	1100000	210000
1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000
1045	홍원신	690906-1985214	2003-03-16	전북	011-7777-7777	영업부	사원	960000	152000
1046	허경운	760105-1458752	1999-05-04	경남	017-3333-3333	총무부	부장	2650000	150000
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000
1048	이기상	790604-1415141	2001-06-07	전남		개발부	대리	2050000	106000
1049	이미성	830908-2456548	2000-04-07	인천	010-6654-8854	개발부	사원	1300000	130000
1050	이미인	810403-2828287	2003-06-07	경기	011-8585-5252	홍보부	대리	1950000	103000
1051	권영미	790303-2155554	2000-06-04	서울	011-5555-7548	영업부	과장	2260000	104000
1052	권옥경	820406-2000456	2000-10-10	경기	010-3644-5577	기획부	사원	1020000	105000
1053	김싱식	800715-1313131	1999-12-12	전북	011-7585-7474	자재부	사원	960000	108000
1054	정상호	810705-1212141	1999-10-16	강원	016-1919-4242	홍보부	사원	980000	114000
1055	정한나	820506-2425153	2004-06-07	서울	016-2424-4242	영업부	사원	1000000	104000
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000
1057	이미경	780406-2003214	1998-02-11	경기	016-6542-7546	자재부	부장	2520000	160000
1058	김신제	800709-1321456	2003-08-08	인천	010-2415-5444	기획부	대리	1950000	180000
1059	임수봉	810809-2121244	2001-10-10	서울	011-4151-4154	개발부	사원	890000	102000
1060	김신애	810809-2111111	2001-10-10	서울	011-4151-4444	개발부	사원	900000	102000
*/

02. SCOTT 사용자 소유 테이블 목록 확인(2가지 구문 활용)
SELECT *
FROM TAB;
/*
BIN$/heIc+XMQZWMap/CiWtdXw==$0	TABLE	
BIN$qyuS6fO+R5CpKpdzvaYN0A==$0	TABLE	
BIN$u7VO/tRaRRKO4UTSc8ByQA==$0	TABLE	
BONUS	TABLE	
DEPT	TABLE	
EMP	TABLE	
EMPCOPY	TABLE	
SALGRADE	TABLE	
TBL_AAA	TABLE	
TBL_BOARD	TABLE	
TBL_DEPT	TABLE	
TBL_EMP	TABLE	
TBL_EXAMPLE1	TABLE	
TBL_EXAMPLE2	TABLE	
TBL_FILES	TABLE	
TBL_INSA	TABLE	
TBL_SAWON	TABLE	
TBL_SAWON2	VIEW	
TBL_WATCH	TABLE	
VIEW_SAWON	VIEW	
VIEW_SAWON2	VIEW	
VIEW_TEST	VIEW	
*/

--03. TBL_INSA 테이블 구조 확인
DESC TBL_INSA;
--==>>
/*
이름       널?       유형           
-------- -------- ------------ 
NUM      NOT NULL NUMBER(5)    
NAME     NOT NULL VARCHAR2(20) 
SSN      NOT NULL VARCHAR2(14) 
IBSADATE NOT NULL DATE         
CITY              VARCHAR2(10) 
TEL               VARCHAR2(15) 
BUSEO    NOT NULL VARCHAR2(15) 
JIKWI    NOT NULL VARCHAR2(15) 
BASICPAY NOT NULL NUMBER(10)   
SUDANG   NOT NULL NUMBER(10)
*/

--04. TBL_INSA 테이블의 이름(NAME), 기본급(BASICPAY) 조회
SELECT NAME,BASICPAY
FROM TBL_INSA;
/*
홍길동	2610000
이순신	1320000
이순애	2550000
김정훈	1954200
한석봉	1420000
이기자	2265000
장인철	1250000
김영년	950000
나윤균	840000
김종서	2540000
유관순	1020000
정한국	880000
조미숙	1601000
황진이	1100000
이현숙	1050000
이상헌	2350000
엄용수	950000
이성길	880000
박문수	2300000
유영희	880000
홍길남	875000
이영숙	1960000
김인수	2500000
김말자	1900000
우재옥	1100000
김숙남	1050000
김영길	2340000
이남신	892000
김말숙	920000
정정해	2304000
지재환	2450000
심심해	880000
김미나	1020000
이정석	1100000
정영희	1050000
이재영	960400
최석규	2350000
손인수	2000000
고순정	2010000
박세열	2100000
문길수	2300000
채정희	1020000
양미옥	1100000
지수환	1060000
홍원신	960000
허경운	2650000
산마루	2100000
이기상	2050000
이미성	1300000
이미인	1950000
권영미	2260000
권옥경	1020000
김싱식	960000
정상호	980000
정한나	1000000
전용재	1950000
이미경	2520000
김신제	1950000
임수봉	890000
김신애	900000
*/

--05. TBL_INSA 테이블의 이름(NAME), 기본급(BASICPAY), 수당(SUDANG), 기본급+수당 조회
SELECT NAME,BASICPAY,SUDANG,BASICPAY+SUDANG
FROM TBL_INSA;
/*
홍길동	2610000	200000	2810000
이순신	1320000	200000	1520000
이순애	2550000	160000	2710000
김정훈	1954200	170000	2124200
한석봉	1420000	160000	1580000
이기자	2265000	150000	2415000
장인철	1250000	150000	1400000
김영년	950000	145000	1095000
나윤균	840000	220400	1060400
김종서	2540000	130000	2670000
유관순	1020000	140000	1160000
정한국	880000	114000	994000
조미숙	1601000	103000	1704000
황진이	1100000	130000	1230000
이현숙	1050000	104000	1154000
이상헌	2350000	150000	2500000
엄용수	950000	210000	1160000
이성길	880000	123000	1003000
박문수	2300000	165000	2465000
유영희	880000	140000	1020000
홍길남	875000	120000	995000
이영숙	1960000	180000	2140000
김인수	2500000	170000	2670000
김말자	1900000	170000	2070000
우재옥	1100000	160000	1260000
김숙남	1050000	150000	1200000
김영길	2340000	170000	2510000
이남신	892000	110000	1002000
김말숙	920000	124000	1044000
정정해	2304000	124000	2428000
지재환	2450000	160000	2610000
심심해	880000	108000	988000
김미나	1020000	104000	1124000
이정석	1100000	160000	1260000
정영희	1050000	140000	1190000
이재영	960400	190000	1150400
최석규	2350000	187000	2537000
손인수	2000000	150000	2150000
고순정	2010000	160000	2170000
박세열	2100000	130000	2230000
문길수	2300000	150000	2450000
채정희	1020000	200000	1220000
양미옥	1100000	210000	1310000
지수환	1060000	220000	1280000
홍원신	960000	152000	1112000
허경운	2650000	150000	2800000
산마루	2100000	112000	2212000
이기상	2050000	106000	2156000
이미성	1300000	130000	1430000
이미인	1950000	103000	2053000
권영미	2260000	104000	2364000
권옥경	1020000	105000	1125000
김싱식	960000	108000	1068000
정상호	980000	114000	1094000
정한나	1000000	104000	1104000
전용재	1950000	200000	2150000
이미경	2520000	160000	2680000
김신제	1950000	180000	2130000
임수봉	890000	102000	992000
김신애	900000	102000	1002000
*/

--06. TBL_INSA 테이블의 이름(NAME), 출신도(CITY), 부서명(BUSEO) 조회. 별칭(ALIAS) 사용.
SELECT NAME"이름",CITY"출신도",BUSEO"부서명"
FROM TBL_INSA;
/*
홍길동	서울	기획부
이순신	경기	총무부
이순애	인천	개발부
김정훈	전북	영업부
한석봉	서울	총무부
이기자	인천	개발부
장인철	제주	개발부
김영년	서울	홍보부
나윤균	경기	인사부
김종서	부산	영업부
유관순	서울	영업부
정한국	강원	홍보부
조미숙	경기	홍보부
황진이	인천	개발부
이현숙	경기	총무부
이상헌	경기	개발부
엄용수	인천	개발부
이성길	전북	개발부
박문수	서울	인사부
유영희	전남	자재부
홍길남	경기	개발부
이영숙	전남	기획부
김인수	서울	영업부
김말자	서울	기획부
우재옥	서울	영업부
김숙남	경기	영업부
김영길	서울	총무부
이남신	제주	인사부
김말숙	서울	총무부
정정해	부산	총무부
지재환	서울	기획부
심심해	전북	자재부
김미나	서울	영업부
이정석	경기	기획부
정영희	인천	개발부
이재영	서울	자재부
최석규	인천	홍보부
손인수	부산	영업부
고순정	경기	영업부
박세열	경북	인사부
문길수	충남	자재부
채정희	경기	개발부
양미옥	서울	영업부
지수환	서울	영업부
홍원신	전북	영업부
허경운	경남	총무부
산마루	서울	영업부
이기상	전남	개발부
이미성	인천	개발부
이미인	경기	홍보부
권영미	서울	영업부
권옥경	경기	기획부
김싱식	전북	자재부
정상호	강원	홍보부
정한나	서울	영업부
전용재	인천	영업부
이미경	경기	자재부
김신제	인천	기획부
임수봉	서울	개발부
김신애	서울	개발부
*/

-- 07. 서울 사람의 이름(NAME), 출신도(CITY), 부서명(BUSEO), 직위(JIKWI) 조회
SELECT NAME"이름",CITY"출신도",BUSEO"부서명",JIKWI"직위"
FROM TBL_INSA
WHERE CITY='서울';
/*
홍길동	서울	기획부	부장
한석봉	서울	총무부	사원
김영년	서울	홍보부	사원
유관순	서울	영업부	사원
박문수	서울	인사부	과장
김인수	서울	영업부	부장
김말자	서울	기획부	대리
우재옥	서울	영업부	사원
김영길	서울	총무부	과장
김말숙	서울	총무부	사원
지재환	서울	기획부	부장
김미나	서울	영업부	사원
이재영	서울	자재부	사원
양미옥	서울	영업부	사원
지수환	서울	영업부	사원
산마루	서울	영업부	대리
권영미	서울	영업부	과장
정한나	서울	영업부	사원
임수봉	서울	개발부	사원
김신애	서울	개발부	사원
*/

--08. 출신도가 서울 사람이면서       → WHERE 구문
--    기본급이 150만원 이상인 사람   → WHERE 구문
--    조회 (NAME, CITY, BASICPAY, SSN)
    SELECT NAME,CITY,BASICPAY,SSN
    FROM TBL_INSA
    WHERE CITY='서울' OR BASICPAY>1500000; 
    /*
    홍길동	서울	2610000	771212-1022432
이순애	인천	2550000	770922-2312547
김정훈	전북	1954200	790304-1788896
한석봉	서울	1420000	811112-1566789
이기자	인천	2265000	780505-2978541
김영년	서울	950000	821011-2362514
김종서	부산	2540000	751010-1122233
유관순	서울	1020000	801010-2987897
조미숙	경기	1601000	790102-2777777
이상헌	경기	2350000	781010-1666678
박문수	서울	2300000	780710-1985632
이영숙	전남	1960000	800501-2312456
김인수	서울	2500000	731211-1214576
김말자	서울	1900000	830225-2633334
우재옥	서울	1100000	801103-1654442
김영길	서울	2340000	801216-1898752
김말숙	서울	920000	800301-2020202
정정해	부산	2304000	790210-2101010
지재환	서울	2450000	771115-1687988
김미나	서울	1020000	780505-2999999
이재영	서울	960400	701126-2852147
최석규	인천	2350000	770129-1456987
손인수	부산	2000000	791009-2321456
고순정	경기	2010000	800504-2000032
박세열	경북	2100000	790509-1635214
문길수	충남	2300000	721217-1951357
양미옥	서울	1100000	830504-2471523
지수환	서울	1060000	820305-1475286
허경운	경남	2650000	760105-1458752
산마루	서울	2100000	780505-1234567
이기상	전남	2050000	790604-1415141
이미인	경기	1950000	810403-2828287
권영미	서울	2260000	790303-2155554
정한나	서울	1000000	820506-2425153
전용재	인천	1950000	800605-1456987
이미경	경기	2520000	780406-2003214
김신제	인천	1950000	800709-1321456
임수봉	서울	890000	810809-2121244
김신애	서울	900000	810809-2111111
    */
    

--09. 출신도가 '인천' 이면서, 기본급이 100만원이상 ~ 200만원 미만인 경우만 모든정보 조회.

SELECT *
FROM TBL_INSA
WHERE CITY='인천' AND BASICPAY BETWEEN 1000000 AND 2000000;
/*
1014	황진이	810707-2574812	2002-02-15	인천	010-3214-5467	개발부	사원	1100000	130000
1035	정영희	831010-2153252	2002-05-16	인천		개발부	사원	1050000	140000
1049	이미성	830908-2456548	2000-04-07	인천	010-6654-8854	개발부	사원	1300000	130000
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000
1058	김신제	800709-1321456	2003-08-08	인천	010-2415-5444	기획부	대리	1950000	180000
*/


--10. 출신도가 서울 사람이거나 부서가 개발부인 자료 조회 (NAME, CITY, BUSEO)
SELECT NAME,CITY,BUSEO
FROM TBL_INSA
WHERE CITY='서울' OR BUSEO='개발부';
/*
홍길동	서울	기획부
이순애	인천	개발부
한석봉	서울	총무부
이기자	인천	개발부
장인철	제주	개발부
김영년	서울	홍보부
유관순	서울	영업부
황진이	인천	개발부
이상헌	경기	개발부
엄용수	인천	개발부
이성길	전북	개발부
박문수	서울	인사부
홍길남	경기	개발부
김인수	서울	영업부
김말자	서울	기획부
우재옥	서울	영업부
김영길	서울	총무부
김말숙	서울	총무부
지재환	서울	기획부
김미나	서울	영업부
정영희	인천	개발부
이재영	서울	자재부
채정희	경기	개발부
양미옥	서울	영업부
지수환	서울	영업부
산마루	서울	영업부
이기상	전남	개발부
이미성	인천	개발부
권영미	서울	영업부
정한나	서울	영업부
임수봉	서울	개발부
김신애	서울	개발부
*/

--11. 출신도가 서울, 경기인 사람만 조회 (NAME, CITY, BUSEO). IN 연산자 사용.
SELECT NAME,CITY,BUSEO
FROM TBL_INSA
WHERE CITY IN ('서울','경기');
/*
홍길동	서울	기획부
이순신	경기	총무부
한석봉	서울	총무부
김영년	서울	홍보부
나윤균	경기	인사부
유관순	서울	영업부
조미숙	경기	홍보부
이현숙	경기	총무부
이상헌	경기	개발부
박문수	서울	인사부
홍길남	경기	개발부
김인수	서울	영업부
김말자	서울	기획부
우재옥	서울	영업부
김숙남	경기	영업부
김영길	서울	총무부
김말숙	서울	총무부
지재환	서울	기획부
김미나	서울	영업부
이정석	경기	기획부
이재영	서울	자재부
고순정	경기	영업부
채정희	경기	개발부
양미옥	서울	영업부
지수환	서울	영업부
산마루	서울	영업부
이미인	경기	홍보부
권영미	서울	영업부
권옥경	경기	기획부
정한나	서울	영업부
이미경	경기	자재부
임수봉	서울	개발부
김신애	서울	개발부
*/

--12. 부서가 '개발부' 이거나 '영업부'인 사원의 모든정보 조회. IN 연산자 사용.
SELECT *
FROM TBL_INSA
WHERE BUSEO IN ('개발부','영업부');
/*
1003	이순애	770922-2312547	1999-02-25	인천	010-4231-1236	개발부	부장	2550000	160000
1004	김정훈	790304-1788896	2000-10-01	전북	019-5236-4221	영업부	대리	1954200	170000
1006	이기자	780505-2978541	2002-02-11	인천	010-3214-5357	개발부	과장	2265000	150000
1007	장인철	780506-1625148	1998-03-16	제주	011-2345-2525	개발부	대리	1250000	150000
1010	김종서	751010-1122233	1997-08-08	부산	011-3214-5555	영업부	부장	2540000	130000
1011	유관순	801010-2987897	2000-07-07	서울	010-8888-4422	영업부	사원	1020000	140000
1014	황진이	810707-2574812	2002-02-15	인천	010-3214-5467	개발부	사원	1100000	130000
1016	이상헌	781010-1666678	2001-11-29	경기	010-4526-1234	개발부	과장	2350000	150000
1017	엄용수	820507-1452365	2000-08-28	인천	010-3254-2542	개발부	사원	950000	210000
1018	이성길	801028-1849534	2004-08-08	전북	018-1333-3333	개발부	사원	880000	123000
1021	홍길남	801010-1111111	2001-09-07	경기	011-9999-7575	개발부	사원	875000	120000
1023	김인수	731211-1214576	1995-02-23	서울		영업부	부장	2500000	170000
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000
1026	김숙남	810907-2015457	2002-08-28	경기	010-2112-5225	영업부	사원	1050000	150000
1033	김미나	780505-2999999	1998-06-07	서울	011-2444-4444	영업부	사원	1020000	104000
1035	정영희	831010-2153252	2002-05-16	인천		개발부	사원	1050000	140000
1038	손인수	791009-2321456	1999-11-15	부산	010-6542-7412	영업부	대리	2000000	150000
1039	고순정	800504-2000032	2003-12-28	경기	010-2587-7895	영업부	대리	2010000	160000
1042	채정희	810709-2000054	2003-10-17	경기	011-5125-5511	개발부	사원	1020000	200000
1043	양미옥	830504-2471523	2003-09-24	서울	016-8548-6547	영업부	사원	1100000	210000
1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000
1045	홍원신	690906-1985214	2003-03-16	전북	011-7777-7777	영업부	사원	960000	152000
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000
1048	이기상	790604-1415141	2001-06-07	전남		개발부	대리	2050000	106000
1049	이미성	830908-2456548	2000-04-07	인천	010-6654-8854	개발부	사원	1300000	130000
1051	권영미	790303-2155554	2000-06-04	서울	011-5555-7548	영업부	과장	2260000	104000
1055	정한나	820506-2425153	2004-06-07	서울	016-2424-4242	영업부	사원	1000000	104000
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000
1059	임수봉	810809-2121244	2001-10-10	서울	011-4151-4154	개발부	사원	890000	102000
1060	김신애	810809-2111111	2001-10-10	서울	011-4151-4444	개발부	사원	900000	102000
*/


--13. 급여(BASICPAY + SUDANG)가 250만원 이상인 사람 조회. → WHERE 구문
--    단, 필드명은 한글로 출력. → 별칭(ALIAS)
--    (NAME, BASICPAY, SUDANG, BASICPAY+SUDANG);
    
    SELECT NAME"이름",BASICPAY"급여",SUDANG"수당",BASICPAY+SUDANG"총합"
    FROM TBL_INSA
    WHERE BASICPAY+SUDANG < 15000000;
    /*
    홍길동	2610000	200000	2810000
이순신	1320000	200000	1520000
이순애	2550000	160000	2710000
김정훈	1954200	170000	2124200
한석봉	1420000	160000	1580000
이기자	2265000	150000	2415000
장인철	1250000	150000	1400000
김영년	950000	145000	1095000
나윤균	840000	220400	1060400
김종서	2540000	130000	2670000
유관순	1020000	140000	1160000
정한국	880000	114000	994000
조미숙	1601000	103000	1704000
황진이	1100000	130000	1230000
이현숙	1050000	104000	1154000
이상헌	2350000	150000	2500000
엄용수	950000	210000	1160000
이성길	880000	123000	1003000
박문수	2300000	165000	2465000
유영희	880000	140000	1020000
홍길남	875000	120000	995000
이영숙	1960000	180000	2140000
김인수	2500000	170000	2670000
김말자	1900000	170000	2070000
우재옥	1100000	160000	1260000
김숙남	1050000	150000	1200000
김영길	2340000	170000	2510000
이남신	892000	110000	1002000
김말숙	920000	124000	1044000
정정해	2304000	124000	2428000
지재환	2450000	160000	2610000
심심해	880000	108000	988000
김미나	1020000	104000	1124000
이정석	1100000	160000	1260000
정영희	1050000	140000	1190000
이재영	960400	190000	1150400
최석규	2350000	187000	2537000
손인수	2000000	150000	2150000
고순정	2010000	160000	2170000
박세열	2100000	130000	2230000
문길수	2300000	150000	2450000
채정희	1020000	200000	1220000
양미옥	1100000	210000	1310000
지수환	1060000	220000	1280000
홍원신	960000	152000	1112000
허경운	2650000	150000	2800000
산마루	2100000	112000	2212000
이기상	2050000	106000	2156000
이미성	1300000	130000	1430000
이미인	1950000	103000	2053000
권영미	2260000	104000	2364000
권옥경	1020000	105000	1125000
김싱식	960000	108000	1068000
정상호	980000	114000	1094000
정한나	1000000	104000	1104000
전용재	1950000	200000	2150000
이미경	2520000	160000	2680000
김신제	1950000	180000	2130000
임수봉	890000	102000	992000
김신애	900000	102000	1002000
    */

--14. 주민번호를 기준으로 남자(성별 자릿수가 1, 3)만 조회. 
    ( 이름(NAME), 주민번호(SSN) )
    단, SUBSTR() 함수 이용.;
    
    SELECT NAME"이름", SSN"주민번호"
    FROM TBL_INSA
    WHERE SUBSTR(SSN,8,1) IN (1,3);
    /*
    홍길동	771212-1022432
이순신	801007-1544236
김정훈	790304-1788896
한석봉	811112-1566789
장인철	780506-1625148
나윤균	810810-1552147
김종서	751010-1122233
정한국	760909-1333333
이상헌	781010-1666678
엄용수	820507-1452365
이성길	801028-1849534
박문수	780710-1985632
홍길남	801010-1111111
김인수	731211-1214576
우재옥	801103-1654442
김영길	801216-1898752
이남신	810101-1010101
지재환	771115-1687988
이정석	820505-1325468
최석규	770129-1456987
박세열	790509-1635214
문길수	721217-1951357
지수환	820305-1475286
홍원신	690906-1985214
허경운	760105-1458752
산마루	780505-1234567
이기상	790604-1415141
김싱식	800715-1313131
정상호	810705-1212141
전용재	800605-1456987
김신제	800709-1321456
    */

--15. 주민번호를 기준으로 80년대 태어난 사람만 조회. 
    ( 이름(NAME), 주민번호(SSN) );
    
    SELECT NAME"이름",SSN"주민번호"
    FROM TBL_INSA
    WHERE SUBSTR(SSN,1,1) IN (8);
    /*
    이순신	801007-1544236
한석봉	811112-1566789
김영년	821011-2362514
나윤균	810810-1552147
유관순	801010-2987897
황진이	810707-2574812
이현숙	800606-2954687
엄용수	820507-1452365
이성길	801028-1849534
유영희	800304-2741258
홍길남	801010-1111111
이영숙	800501-2312456
김말자	830225-2633334
우재옥	801103-1654442
김숙남	810907-2015457
김영길	801216-1898752
이남신	810101-1010101
김말숙	800301-2020202
심심해	810206-2222222
이정석	820505-1325468
정영희	831010-2153252
고순정	800504-2000032
채정희	810709-2000054
양미옥	830504-2471523
지수환	820305-1475286
이미성	830908-2456548
이미인	810403-2828287
권옥경	820406-2000456
김싱식	800715-1313131
정상호	810705-1212141
정한나	820506-2425153
전용재	800605-1456987
김신제	800709-1321456
임수봉	810809-2121244
김신애	810809-2111111
    */
    
    

--16. 서울 사람 중에서 70년대 태어난 사람만 조회. SUBSTR() 함수 이용.;

    SELECT NAME"이름",SSN"주민번호"
    FROM TBL_INSA
    WHERE CITY='서울' AND SUBSTR(SSN,1,1) IN (7);


--17. 서울 사람 중에서 70년대 태어난 남자만 조회. SUBSTR() 함수 이용.;

    SELECT NAME"이름",SSN"주민번호"
    FROM TBL_INSA
    WHERE CITY='서울' AND SUBSTR(SSN,1,1) IN (7) AND SUBSTR(SSN,8,1) IN (1,3);



--18. 서울 사람이면서 김씨만 조회
--    단, 성씨가 한 글자라는 가정. 
--    ( 이름, 출신도 )
--    SUBSTR() 함수 이용.;
    
    
    SELECT NAME"이름",CITY"출신도"
    FROM TBL_INSA
    WHERE CITY='서울' AND SUBSTR(NAME,1,1) LIKE ('김%');
    


--19. 2000년도에 입사한 사람 조회. (이름, 출신도, 입사일).;

SELECT NAME"이름",CITY"출신도",IBSADATE"입사일"
FROM TBL_INSA
WHERE TO_CHAR(IBSADATE,'YYYY') LIKE ('2___');




--20. 2000년 10월에 입사한 사람 조회. (이름, 출신도, 입사일).

SELECT NAME"이름",CITY"출신도",IBSADATE"입사일"
FROM TBL_INSA
WHERE TO_CHAR(IBSADATE,'YYYY-MM') IN('2000-10');


--21. 주민번호를 기준으로 직원의 나이 조회.
--단, 모든 직원이 1900년대에 태어났다는 가정. (이름, 주민번호, 나이)
    
    SELECT NAME"이름",SSN"주민번호",CASE WHEN SUBSTR(SSN,8,1) IN (1,2)THEN 2024 - (SUBSTR(SSN,1,2) + 1899) END "나이"
    FROM TBL_INSA;
    /*
    홍길동	771212-1022432	48
이순신	801007-1544236	45
이순애	770922-2312547	48
김정훈	790304-1788896	46
한석봉	811112-1566789	44
이기자	780505-2978541	47
장인철	780506-1625148	47
김영년	821011-2362514	43
나윤균	810810-1552147	44
김종서	751010-1122233	50
유관순	801010-2987897	45
정한국	760909-1333333	49
조미숙	790102-2777777	46
황진이	810707-2574812	44
이현숙	800606-2954687	45
이상헌	781010-1666678	47
엄용수	820507-1452365	43
이성길	801028-1849534	45
박문수	780710-1985632	47
유영희	800304-2741258	45
홍길남	801010-1111111	45
이영숙	800501-2312456	45
김인수	731211-1214576	52
김말자	830225-2633334	42
우재옥	801103-1654442	45
김숙남	810907-2015457	44
김영길	801216-1898752	45
이남신	810101-1010101	44
김말숙	800301-2020202	45
정정해	790210-2101010	46
지재환	771115-1687988	48
심심해	810206-2222222	44
김미나	780505-2999999	47
이정석	820505-1325468	43
정영희	831010-2153252	42
이재영	701126-2852147	55
최석규	770129-1456987	48
손인수	791009-2321456	46
고순정	800504-2000032	45
박세열	790509-1635214	46
문길수	721217-1951357	53
채정희	810709-2000054	44
양미옥	830504-2471523	42
지수환	820305-1475286	43
홍원신	690906-1985214	56
허경운	760105-1458752	49
산마루	780505-1234567	47
이기상	790604-1415141	46
이미성	830908-2456548	42
이미인	810403-2828287	44
권영미	790303-2155554	46
권옥경	820406-2000456	43
김싱식	800715-1313131	45
정상호	810705-1212141	44
정한나	820506-2425153	43
전용재	800605-1456987	45
이미경	780406-2003214	47
김신제	800709-1321456	45
임수봉	810809-2121244	44
김신애	810809-2111111	44
    */

--22. 주민번호 기준으로 현재 나이대가 20대인 사람만 조회.

SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,2)
            THEN SUBSTR(2024 - (SUBSTR(SSN,1,2) + 1899),1,1) LIKE '2_' END "나이"
FROM TBL_INSA;
--==>> 결과 無




--23. 주민번호 기준으로 5월 생만 조회. 
--    단, SUBSTR() 함수 이용.
    
    SELECT SSN"주민번호"
    FROM TBL_INSA
    WHERE SUBSTR(SSN,4,1) IN (5);
    /*
    780505-2978541
780506-1625148
820507-1452365
800501-2312456
780505-2999999
820505-1325468
800504-2000032
790509-1635214
830504-2471523
780505-1234567
820506-2425153
    */
    
    
    

--24. 주민번호 기준으로 5월 생만 조회. 
--    단, TO_CHAR() 함수 이용.
    
    SELECT SSN"주민번호"
    FROM TBL_INSA
    WHERE SUBSTR(TO_CHAR(SSN),4,1) IN (5);
    /*
    780505-2978541
780506-1625148
820507-1452365
800501-2312456
780505-2999999
820505-1325468
800504-2000032
790509-1635214
830504-2471523
780505-1234567
820506-2425153
    */
    
    
    
    

--25. 출신도 내림차순으로 정렬하고, 출신도가 같으면 기본급 내림차순 정렬 조회.

SELECT *
FROM TBL_INSA
ORDER BY 5,9 DESC;

/*
1054	정상호	810705-1212141	1999-10-16	강원	016-1919-4242	홍보부	사원	980000	114000
1012	정한국	760909-1333333	1999-10-16	강원	018-2222-4242	홍보부	사원	880000	114000
1057	이미경	780406-2003214	1998-02-11	경기	016-6542-7546	자재부	부장	2520000	160000
1016	이상헌	781010-1666678	2001-11-29	경기	010-4526-1234	개발부	과장	2350000	150000
1039	고순정	800504-2000032	2003-12-28	경기	010-2587-7895	영업부	대리	2010000	160000
1050	이미인	810403-2828287	2003-06-07	경기	011-8585-5252	홍보부	대리	1950000	103000
1013	조미숙	790102-2777777	1998-06-07	경기	019-6666-4444	홍보부	대리	1601000	103000
1002	이순신	801007-1544236	2000-11-29	경기	010-4758-6532	총무부	사원	1320000	200000
1034	이정석	820505-1325468	2005-09-26	경기	011-3697-7412	기획부	사원	1100000	160000
1026	김숙남	810907-2015457	2002-08-28	경기	010-2112-5225	영업부	사원	1050000	150000
1015	이현숙	800606-2954687	1999-07-26	경기	016-2548-3365	총무부	사원	1050000	104000
1042	채정희	810709-2000054	2003-10-17	경기	011-5125-5511	개발부	사원	1020000	200000
1052	권옥경	820406-2000456	2000-10-10	경기	010-3644-5577	기획부	사원	1020000	105000
1021	홍길남	801010-1111111	2001-09-07	경기	011-9999-7575	개발부	사원	875000	120000
1009	나윤균	810810-1552147	2003-10-10	경기	019-1111-2222	인사부	사원	840000	220400
1046	허경운	760105-1458752	1999-05-04	경남	017-3333-3333	총무부	부장	2650000	150000
1040	박세열	790509-1635214	2000-09-10	경북	016-4444-7777	인사부	대리	2100000	130000
1010	김종서	751010-1122233	1997-08-08	부산	011-3214-5555	영업부	부장	2540000	130000
1030	정정해	790210-2101010	1999-10-17	부산	019-6564-6752	총무부	과장	2304000	124000
1038	손인수	791009-2321456	1999-11-15	부산	010-6542-7412	영업부	대리	2000000	150000
1001	홍길동	771212-1022432	1998-10-11	서울	011-2356-4528	기획부	부장	2610000	200000
1023	김인수	731211-1214576	1995-02-23	서울		영업부	부장	2500000	170000
1031	지재환	771115-1687988	2001-01-21	서울	019-5552-7511	기획부	부장	2450000	160000
1027	김영길	801216-1898752	2000-10-18	서울	019-8523-1478	총무부	과장	2340000	170000
1019	박문수	780710-1985632	1999-12-10	서울	017-4747-4848	인사부	과장	2300000	165000
1051	권영미	790303-2155554	2000-06-04	서울	011-5555-7548	영업부	과장	2260000	104000
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000
1024	김말자	830225-2633334	1999-08-28	서울	011-5248-7789	기획부	대리	1900000	170000
1005	한석봉	811112-1566789	2004-08-13	서울	018-5211-3542	총무부	사원	1420000	160000
1043	양미옥	830504-2471523	2003-09-24	서울	016-8548-6547	영업부	사원	1100000	210000
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000
1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000
1033	김미나	780505-2999999	1998-06-07	서울	011-2444-4444	영업부	사원	1020000	104000
1011	유관순	801010-2987897	2000-07-07	서울	010-8888-4422	영업부	사원	1020000	140000
1055	정한나	820506-2425153	2004-06-07	서울	016-2424-4242	영업부	사원	1000000	104000
1036	이재영	701126-2852147	2003-08-10	서울	011-9999-9999	자재부	사원	960400	190000
1008	김영년	821011-2362514	2002-04-30	서울	016-2222-4444	홍보부	사원	950000	145000
1029	김말숙	800301-2020202	2000-09-08	서울	016-3535-3636	총무부	사원	920000	124000
1060	김신애	810809-2111111	2001-10-10	서울	011-4151-4444	개발부	사원	900000	102000
1059	임수봉	810809-2121244	2001-10-10	서울	011-4151-4154	개발부	사원	890000	102000
1003	이순애	770922-2312547	1999-02-25	인천	010-4231-1236	개발부	부장	2550000	160000
1037	최석규	770129-1456987	1998-10-15	인천	011-7777-7777	홍보부	과장	2350000	187000
1006	이기자	780505-2978541	2002-02-11	인천	010-3214-5357	개발부	과장	2265000	150000
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000
1058	김신제	800709-1321456	2003-08-08	인천	010-2415-5444	기획부	대리	1950000	180000
1049	이미성	830908-2456548	2000-04-07	인천	010-6654-8854	개발부	사원	1300000	130000
1014	황진이	810707-2574812	2002-02-15	인천	010-3214-5467	개발부	사원	1100000	130000
1035	정영희	831010-2153252	2002-05-16	인천		개발부	사원	1050000	140000
1017	엄용수	820507-1452365	2000-08-28	인천	010-3254-2542	개발부	사원	950000	210000
1048	이기상	790604-1415141	2001-06-07	전남		개발부	대리	2050000	106000
1022	이영숙	800501-2312456	2003-02-25	전남	017-5214-5282	기획부	대리	1960000	180000
1020	유영희	800304-2741258	2003-10-10	전남	011-9595-8585	자재부	사원	880000	140000
1004	김정훈	790304-1788896	2000-10-01	전북	019-5236-4221	영업부	대리	1954200	170000
1053	김싱식	800715-1313131	1999-12-12	전북	011-7585-7474	자재부	사원	960000	108000
1045	홍원신	690906-1985214	2003-03-16	전북	011-7777-7777	영업부	사원	960000	152000
1018	이성길	801028-1849534	2004-08-08	전북	018-1333-3333	개발부	사원	880000	123000
1032	심심해	810206-2222222	2000-05-05	전북	016-8888-7474	자재부	사원	880000	108000
1007	장인철	780506-1625148	1998-03-16	제주	011-2345-2525	개발부	대리	1250000	150000
1028	이남신	810101-1010101	2001-09-07	제주	016-1818-4848	인사부	사원	892000	110000
1041	문길수	721217-1951357	2001-12-10	충남	016-4444-5555	자재부	과장	2300000	150000
*/




--26. 서울 사람 중에서 기본급+수당(→급여) 내림차순으로 정렬.
--    ( 이름, 출신도, 기본급+수당 );
    
    SELECT NAME"이름",CITY"출신도",BASICPAY+SUDANG"기본급+수당"
    FROM TBL_INSA
    WHERE CITY = '서울'
    ORDER BY 3 DESC;
    
    /*
    홍길동	서울	2810000
김인수	서울	2670000
지재환	서울	2610000
김영길	서울	2510000
박문수	서울	2465000
권영미	서울	2364000
산마루	서울	2212000
김말자	서울	2070000
한석봉	서울	1580000
양미옥	서울	1310000
지수환	서울	1280000
우재옥	서울	1260000
유관순	서울	1160000
이재영	서울	1150400
김미나	서울	1124000
정한나	서울	1104000
김영년	서울	1095000
김말숙	서울	1044000
김신애	서울	1002000
임수봉	서울	992000
    */

--27. 여자 중 부서 오름차순으로 정렬하고, 부서가 같으면 기본급 내림차순 정렬. 
--    ( 이름, 주민번호, 부서, 기본급 );
    
    SELECT NAME"이름",SSN"주민번호",BUSEO"부서",BASICPAY"기본급"
    FROM TBL_INSA
    WHERE SUBSTR(SSN,8,1) IN (2,4)
    ORDER BY 3 ASC,4 DESC;
    /*
    이순애	770922-2312547	개발부	2550000
이기자	780505-2978541	개발부	2265000
이미성	830908-2456548	개발부	1300000
황진이	810707-2574812	개발부	1100000
정영희	831010-2153252	개발부	1050000
채정희	810709-2000054	개발부	1020000
김신애	810809-2111111	개발부	900000
임수봉	810809-2121244	개발부	890000
이영숙	800501-2312456	기획부	1960000
김말자	830225-2633334	기획부	1900000
권옥경	820406-2000456	기획부	1020000
권영미	790303-2155554	영업부	2260000
고순정	800504-2000032	영업부	2010000
손인수	791009-2321456	영업부	2000000
양미옥	830504-2471523	영업부	1100000
김숙남	810907-2015457	영업부	1050000
김미나	780505-2999999	영업부	1020000
유관순	801010-2987897	영업부	1020000
정한나	820506-2425153	영업부	1000000
이미경	780406-2003214	자재부	2520000
이재영	701126-2852147	자재부	960400
유영희	800304-2741258	자재부	880000
심심해	810206-2222222	자재부	880000
정정해	790210-2101010	총무부	2304000
이현숙	800606-2954687	총무부	1050000
김말숙	800301-2020202	총무부	920000
이미인	810403-2828287	홍보부	1950000
조미숙	790102-2777777	홍보부	1601000
김영년	821011-2362514	홍보부	950000
    */

--28. 남자 중 나이를 기준으로 오름차순 정렬하여 조회.

SELECT NUM,NAME,SSN,IBSADATE,CITY,TEL,BUSEO,JIKWI,BASICPAY,SUDANG
        ,CASE WHEN SUBSTR(SSN,8,1) IN (1,2) THEN 2024 - (SUBSTR(SSN,1,2) + 1899) END "나이"
FROM TBL_INSA
WHERE SUBSTR(SSN,8,1) IN (1,3)
ORDER BY 11 ASC;
/*
1017	엄용수	820507-1452365	2000-08-28	인천	010-3254-2542	개발부	사원	950000	210000	43
1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000	43
1034	이정석	820505-1325468	2005-09-26	경기	011-3697-7412	기획부	사원	1100000	160000	43
1054	정상호	810705-1212141	1999-10-16	강원	016-1919-4242	홍보부	사원	980000	114000	44
1005	한석봉	811112-1566789	2004-08-13	서울	018-5211-3542	총무부	사원	1420000	160000	44
1009	나윤균	810810-1552147	2003-10-10	경기	019-1111-2222	인사부	사원	840000	220400	44
1028	이남신	810101-1010101	2001-09-07	제주	016-1818-4848	인사부	사원	892000	110000	44
1058	김신제	800709-1321456	2003-08-08	인천	010-2415-5444	기획부	대리	1950000	180000	45
1002	이순신	801007-1544236	2000-11-29	경기	010-4758-6532	총무부	사원	1320000	200000	45
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000	45
1053	김싱식	800715-1313131	1999-12-12	전북	011-7585-7474	자재부	사원	960000	108000	45
1027	김영길	801216-1898752	2000-10-18	서울	019-8523-1478	총무부	과장	2340000	170000	45
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000	45
1021	홍길남	801010-1111111	2001-09-07	경기	011-9999-7575	개발부	사원	875000	120000	45
1018	이성길	801028-1849534	2004-08-08	전북	018-1333-3333	개발부	사원	880000	123000	45
1004	김정훈	790304-1788896	2000-10-01	전북	019-5236-4221	영업부	대리	1954200	170000	46
1048	이기상	790604-1415141	2001-06-07	전남		개발부	대리	2050000	106000	46
1040	박세열	790509-1635214	2000-09-10	경북	016-4444-7777	인사부	대리	2100000	130000	46
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000	47
1016	이상헌	781010-1666678	2001-11-29	경기	010-4526-1234	개발부	과장	2350000	150000	47
1007	장인철	780506-1625148	1998-03-16	제주	011-2345-2525	개발부	대리	1250000	150000	47
1019	박문수	780710-1985632	1999-12-10	서울	017-4747-4848	인사부	과장	2300000	165000	47
1031	지재환	771115-1687988	2001-01-21	서울	019-5552-7511	기획부	부장	2450000	160000	48
1001	홍길동	771212-1022432	1998-10-11	서울	011-2356-4528	기획부	부장	2610000	200000	48
1037	최석규	770129-1456987	1998-10-15	인천	011-7777-7777	홍보부	과장	2350000	187000	48
1012	정한국	760909-1333333	1999-10-16	강원	018-2222-4242	홍보부	사원	880000	114000	49
1046	허경운	760105-1458752	1999-05-04	경남	017-3333-3333	총무부	부장	2650000	150000	49
1010	김종서	751010-1122233	1997-08-08	부산	011-3214-5555	영업부	부장	2540000	130000	50
1023	김인수	731211-1214576	1995-02-23	서울		영업부	부장	2500000	170000	52
1041	문길수	721217-1951357	2001-12-10	충남	016-4444-5555	자재부	과장	2300000	150000	53
1045	홍원신	690906-1985214	2003-03-16	전북	011-7777-7777	영업부	사원	960000	152000	56
*/

--29. 서울 지역 사람들 중에서 입사일이 빠른 사람을 먼저 볼 수 있도록 조회.

SELECT *
FROM TBL_INSA
WHERE CITY = '서울'
ORDER BY 4 ASC;
/*
1023	김인수	731211-1214576	1995-02-23	서울		영업부	부장	2500000	170000
1033	김미나	780505-2999999	1998-06-07	서울	011-2444-4444	영업부	사원	1020000	104000
1001	홍길동	771212-1022432	1998-10-11	서울	011-2356-4528	기획부	부장	2610000	200000
1024	김말자	830225-2633334	1999-08-28	서울	011-5248-7789	기획부	대리	1900000	170000
1019	박문수	780710-1985632	1999-12-10	서울	017-4747-4848	인사부	과장	2300000	165000
1051	권영미	790303-2155554	2000-06-04	서울	011-5555-7548	영업부	과장	2260000	104000
1011	유관순	801010-2987897	2000-07-07	서울	010-8888-4422	영업부	사원	1020000	140000
1029	김말숙	800301-2020202	2000-09-08	서울	016-3535-3636	총무부	사원	920000	124000
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000
1027	김영길	801216-1898752	2000-10-18	서울	019-8523-1478	총무부	과장	2340000	170000
1031	지재환	771115-1687988	2001-01-21	서울	019-5552-7511	기획부	부장	2450000	160000
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000
1059	임수봉	810809-2121244	2001-10-10	서울	011-4151-4154	개발부	사원	890000	102000
1060	김신애	810809-2111111	2001-10-10	서울	011-4151-4444	개발부	사원	900000	102000
1008	김영년	821011-2362514	2002-04-30	서울	016-2222-4444	홍보부	사원	950000	145000
1036	이재영	701126-2852147	2003-08-10	서울	011-9999-9999	자재부	사원	960400	190000
1043	양미옥	830504-2471523	2003-09-24	서울	016-8548-6547	영업부	사원	1100000	210000
1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000
1055	정한나	820506-2425153	2004-06-07	서울	016-2424-4242	영업부	사원	1000000	104000
1005	한석봉	811112-1566789	2004-08-13	서울	018-5211-3542	총무부	사원	1420000	160000
*/


--30. 성씨가 김씨가 아닌 사람 조회. 
--    단, 성씨는 한 글자라고 가정.
--    ( 이름, 출신도, 기본급 ).

SELECT NAME"이름",CITY"출신도",BASICPAY"기본급"
FROM TBL_INSA
WHERE NAME NOT LIKE ('김%');
/*
홍길동	서울	2610000
이순신	경기	1320000
이순애	인천	2550000
한석봉	서울	1420000
이기자	인천	2265000
장인철	제주	1250000
나윤균	경기	840000
유관순	서울	1020000
정한국	강원	880000
조미숙	경기	1601000
황진이	인천	1100000
이현숙	경기	1050000
이상헌	경기	2350000
엄용수	인천	950000
이성길	전북	880000
박문수	서울	2300000
유영희	전남	880000
홍길남	경기	875000
이영숙	전남	1960000
우재옥	서울	1100000
이남신	제주	892000
정정해	부산	2304000
지재환	서울	2450000
심심해	전북	880000
이정석	경기	1100000
정영희	인천	1050000
이재영	서울	960400
최석규	인천	2350000
손인수	부산	2000000
고순정	경기	2010000
박세열	경북	2100000
문길수	충남	2300000
채정희	경기	1020000
양미옥	서울	1100000
지수환	서울	1060000
홍원신	전북	960000
허경운	경남	2650000
산마루	서울	2100000
이기상	전남	2050000
이미성	인천	1300000
이미인	경기	1950000
권영미	서울	2260000
권옥경	경기	1020000
정상호	강원	980000
정한나	서울	1000000
전용재	인천	1950000
이미경	경기	2520000
임수봉	서울	890000
*/


31. 출신도가 서울, 부산, 대구 이면서
    전화번호에 5 또는 7이 포함된 데이터를 조회하되
    부서명의 마지막 부는 출력되지 않도록함. (개발부 → 개발)
    ( 이름, 출신도, 부서명, 전화번호 );
    
    
    SELECT THEN END
    FROM TBL_INSA;
    
    
    
    
    
    

--32. 전화번호가 있으면 '-'을 제거하여 조회하고, 
--    없으면 '전화번호없음'으로 조회.
    
    
    
    SELECT CASE WHEN TEL IS NULL THEN '전화번호 없음' 
                WHEN TEL IS NOT NULL THEN REPLACE(TEL,'-','') END"전화번호" 
    FROM TBL_INSA;
    
    /*
    01123564528
01047586532
01042311236
01952364221
01852113542
01032145357
01123452525
01622224444
01911112222
01132145555
01088884422
01822224242
01966664444
01032145467
01625483365
01045261234
01032542542
01813333333
01747474848
01195958585
01199997575
01752145282
전화번호 없음
01152487789
01045632587
01021125225
01985231478
01618184848
01635353636
01965646752
01955527511
01688887474
01124444444
01136977412
전화번호 없음
01199999999
01177777777
01065427412
01025877895
01644447777
01644445555
01151255511
01685486547
01155557548
01177777777
01733333333
01805050505
전화번호 없음
01066548854
01185855252
01155557548
01036445577
01175857474
01619194242
01624244242
01075498654
01665427546
01024155444
01141514154
01141514444
    */
    
    
    
    
    
    

추가문제. (기본 문제 풀이가 모두 끝난 후 작성한다.)
          HR계정의 EMPLOYEES 테이블에서 커미션 받는 사람의 수와
          안받는 사람의 수를 조회한다.
          출력형태 ---------------
              구분        인원수
          ------------------------
          커미션받는사원    XXX
          커미션없는사원    XXX
          모든사원          XXX
          


33. TBL_INSA 테이블에서 BASICPAY + SUDANG 이 
    100만원 미만, 100만원 이상~200만원 미만, 
    200만원 이상인 직원들의 수 조회.
    
 
    SELECT NUM,NAME,SSN,IBSADATE,CITY,TEL,BUSEO,JIKWI
    FROM TBL_INSA;
    
    

34. TBL_INSA 테이블에서 주민번호를 가지고 생년월일의 년도별 직원수 조회.




--35. 주민번호를 기준으로 월별 오름차순, 월이 같으면 년도 내림차순 조회.
--    (이름, 주민번호);
    
    
    
    SELECT NAME"이름",SSN"주민번호"
    FROM TBL_INSA
    ORDER BY SUBSTR(SSN,3,4) ASC,SUBSTR(SSN,1,2) DESC;
    
    /*
    이남신	810101-1010101
조미숙	790102-2777777
허경운	760105-1458752
최석규	770129-1456987
심심해	810206-2222222
정정해	790210-2101010
김말자	830225-2633334
김말숙	800301-2020202
권영미	790303-2155554
유영희	800304-2741258
김정훈	790304-1788896
지수환	820305-1475286
이미인	810403-2828287
권옥경	820406-2000456
이미경	780406-2003214
이영숙	800501-2312456
양미옥	830504-2471523
고순정	800504-2000032
이정석	820505-1325468
산마루	780505-1234567
김미나	780505-2999999
이기자	780505-2978541
정한나	820506-2425153
장인철	780506-1625148
엄용수	820507-1452365
박세열	790509-1635214
이기상	790604-1415141
전용재	800605-1456987
이현숙	800606-2954687
정상호	810705-1212141
황진이	810707-2574812
채정희	810709-2000054
김신제	800709-1321456
박문수	780710-1985632
김싱식	800715-1313131
임수봉	810809-2121244
김신애	810809-2111111
나윤균	810810-1552147
홍원신	690906-1985214
김숙남	810907-2015457
이미성	830908-2456548
정한국	760909-1333333
이순애	770922-2312547
이순신	801007-1544236
손인수	791009-2321456
정영희	831010-2153252
홍길남	801010-1111111
유관순	801010-2987897
이상헌	781010-1666678
김종서	751010-1122233
김영년	821011-2362514
이성길	801028-1849534
우재옥	801103-1654442
한석봉	811112-1566789
지재환	771115-1687988
이재영	701126-2852147
김인수	731211-1214576
홍길동	771212-1022432
김영길	801216-1898752
문길수	721217-1951357
    */
    
    

--36. 입사일을 기준으로  월별 오름차순, 월이 같으면 년도 내림차순 조회.
--    단, 모든 정보 조회.
--    (주의. 입사일은 자료형이 DATE이다.);
    
    
    
    SELECT *
    FROM TBL_INSA
    ORDER BY TO_CHAR(IBSADATE,'MM') ASC ,TO_CHAR(IBSADATE,'YYYY') DESC;
    
    /*
    1044	지수환	820305-1475286	2004-01-21	서울	011-5555-7548	영업부	사원	1060000	220000
1031	지재환	771115-1687988	2001-01-21	서울	019-5552-7511	기획부	부장	2450000	160000
1022	이영숙	800501-2312456	2003-02-25	전남	017-5214-5282	기획부	대리	1960000	180000
1006	이기자	780505-2978541	2002-02-11	인천	010-3214-5357	개발부	과장	2265000	150000
1014	황진이	810707-2574812	2002-02-15	인천	010-3214-5467	개발부	사원	1100000	130000
1003	이순애	770922-2312547	1999-02-25	인천	010-4231-1236	개발부	부장	2550000	160000
1057	이미경	780406-2003214	1998-02-11	경기	016-6542-7546	자재부	부장	2520000	160000
1023	김인수	731211-1214576	1995-02-23	서울		영업부	부장	2500000	170000
1045	홍원신	690906-1985214	2003-03-16	전북	011-7777-7777	영업부	사원	960000	152000
1007	장인철	780506-1625148	1998-03-16	제주	011-2345-2525	개발부	대리	1250000	150000
1008	김영년	821011-2362514	2002-04-30	서울	016-2222-4444	홍보부	사원	950000	145000
1049	이미성	830908-2456548	2000-04-07	인천	010-6654-8854	개발부	사원	1300000	130000
1035	정영희	831010-2153252	2002-05-16	인천		개발부	사원	1050000	140000
1032	심심해	810206-2222222	2000-05-05	전북	016-8888-7474	자재부	사원	880000	108000
1046	허경운	760105-1458752	1999-05-04	경남	017-3333-3333	총무부	부장	2650000	150000
1055	정한나	820506-2425153	2004-06-07	서울	016-2424-4242	영업부	사원	1000000	104000
1050	이미인	810403-2828287	2003-06-07	경기	011-8585-5252	홍보부	대리	1950000	103000
1048	이기상	790604-1415141	2001-06-07	전남		개발부	대리	2050000	106000
1051	권영미	790303-2155554	2000-06-04	서울	011-5555-7548	영업부	과장	2260000	104000
1033	김미나	780505-2999999	1998-06-07	서울	011-2444-4444	영업부	사원	1020000	104000
1013	조미숙	790102-2777777	1998-06-07	경기	019-6666-4444	홍보부	대리	1601000	103000
1047	산마루	780505-1234567	2001-07-15	서울	018-0505-0505	영업부	대리	2100000	112000
1011	유관순	801010-2987897	2000-07-07	서울	010-8888-4422	영업부	사원	1020000	140000
1015	이현숙	800606-2954687	1999-07-26	경기	016-2548-3365	총무부	사원	1050000	104000
1056	전용재	800605-1456987	2004-08-13	인천	010-7549-8654	영업부	대리	1950000	200000
1018	이성길	801028-1849534	2004-08-08	전북	018-1333-3333	개발부	사원	880000	123000
1005	한석봉	811112-1566789	2004-08-13	서울	018-5211-3542	총무부	사원	1420000	160000
1058	김신제	800709-1321456	2003-08-08	인천	010-2415-5444	기획부	대리	1950000	180000
1036	이재영	701126-2852147	2003-08-10	서울	011-9999-9999	자재부	사원	960400	190000
1026	김숙남	810907-2015457	2002-08-28	경기	010-2112-5225	영업부	사원	1050000	150000
1017	엄용수	820507-1452365	2000-08-28	인천	010-3254-2542	개발부	사원	950000	210000
1024	김말자	830225-2633334	1999-08-28	서울	011-5248-7789	기획부	대리	1900000	170000
1010	김종서	751010-1122233	1997-08-08	부산	011-3214-5555	영업부	부장	2540000	130000
1034	이정석	820505-1325468	2005-09-26	경기	011-3697-7412	기획부	사원	1100000	160000
1043	양미옥	830504-2471523	2003-09-24	서울	016-8548-6547	영업부	사원	1100000	210000
1021	홍길남	801010-1111111	2001-09-07	경기	011-9999-7575	개발부	사원	875000	120000
1028	이남신	810101-1010101	2001-09-07	제주	016-1818-4848	인사부	사원	892000	110000
1029	김말숙	800301-2020202	2000-09-08	서울	016-3535-3636	총무부	사원	920000	124000
1040	박세열	790509-1635214	2000-09-10	경북	016-4444-7777	인사부	대리	2100000	130000
1020	유영희	800304-2741258	2003-10-10	전남	011-9595-8585	자재부	사원	880000	140000
1009	나윤균	810810-1552147	2003-10-10	경기	019-1111-2222	인사부	사원	840000	220400
1042	채정희	810709-2000054	2003-10-17	경기	011-5125-5511	개발부	사원	1020000	200000
1059	임수봉	810809-2121244	2001-10-10	서울	011-4151-4154	개발부	사원	890000	102000
1060	김신애	810809-2111111	2001-10-10	서울	011-4151-4444	개발부	사원	900000	102000
1025	우재옥	801103-1654442	2000-10-01	서울	010-4563-2587	영업부	사원	1100000	160000
1027	김영길	801216-1898752	2000-10-18	서울	019-8523-1478	총무부	과장	2340000	170000
1004	김정훈	790304-1788896	2000-10-01	전북	019-5236-4221	영업부	대리	1954200	170000
1052	권옥경	820406-2000456	2000-10-10	경기	010-3644-5577	기획부	사원	1020000	105000
1012	정한국	760909-1333333	1999-10-16	강원	018-2222-4242	홍보부	사원	880000	114000
1030	정정해	790210-2101010	1999-10-17	부산	019-6564-6752	총무부	과장	2304000	124000
1054	정상호	810705-1212141	1999-10-16	강원	016-1919-4242	홍보부	사원	980000	114000
1001	홍길동	771212-1022432	1998-10-11	서울	011-2356-4528	기획부	부장	2610000	200000
1037	최석규	770129-1456987	1998-10-15	인천	011-7777-7777	홍보부	과장	2350000	187000
1016	이상헌	781010-1666678	2001-11-29	경기	010-4526-1234	개발부	과장	2350000	150000
1002	이순신	801007-1544236	2000-11-29	경기	010-4758-6532	총무부	사원	1320000	200000
1038	손인수	791009-2321456	1999-11-15	부산	010-6542-7412	영업부	대리	2000000	150000
1039	고순정	800504-2000032	2003-12-28	경기	010-2587-7895	영업부	대리	2010000	160000
1041	문길수	721217-1951357	2001-12-10	충남	016-4444-5555	자재부	과장	2300000	150000
1053	김싱식	800715-1313131	1999-12-12	전북	011-7585-7474	자재부	사원	960000	108000
1019	박문수	780710-1985632	1999-12-10	서울	017-4747-4848	인사부	과장	2300000	165000
    */
    
    
--37. 전체인원수, 남자인원수, 여자인원수를 동시 조회.

SELECT COUNT(*),COUNT(T.남자),COUNT(T.여자)
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3) THEN'남자' END"남자"
       ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4) THEN '여자' END"여자"
FROM TBL_INSA
WHERE SUBSTR(SSN,8,1) IN (1,2)
)T;

--==>> 60	31	29




--38. 개발부, 영업부, 총무부 인원수 조회.  COUNT(), DECODE() 함수 이용.


SELECT COUNT(T.개발)"개발부",COUNT(T.영업)"영업부",COUNT(T.총무)"총무부"
FROM
(
SELECT DECODE(SUBSTR(BUSEO,1,2),'개발','당첨')"개발",DECODE(SUBSTR(BUSEO,1,2),'영업','당첨2')"영업"
        ,DECODE(SUBSTR(BUSEO,1,2),'총무','당첨3')"총무"
FROM TBL_INSA
)T;

--==>>14	16	7


--39. 서울 사람의 남자 인원수 조회.


SELECT COUNT(*)
FROM TBL_INSA
WHERE CITY = '서울' AND SUBSTR(SSN,8,1) IN (1,3);
--==>>9



--40. 부서가 영업부이고, 남자 인원수, 여자 인원수 조회.  COUNT(), DECODE() 함수 이용.


SELECT COUNT(T.남자)"남자 인원수",COUNT(T.여자)"여자 인원수"
FROM
(
SELECT DECODE(SUBSTR(SSN,8,1),'1','남자')"남자"
        ,DECODE(SUBSTR(SSN,8,1),'2','여자')"여자"
FROM TBL_INSA
WHERE BUSEO LIKE ('영업부')
)T;
--==>>8	8


--41. 개발부, 영업부, 총무부 인원수 조회. 단, 지역은 '서울'로 한정.

SELECT COUNT(T.개발부)"개발부",COUNT(T.영업부)"영업부",COUNT(T.총무부)"총무부"
FROM
(
SELECT CASE WHEN BUSEO LIKE ('개발부') THEN'당첨' END"개발부"
      ,CASE WHEN BUSEO LIKE ('영업부') THEN'당첨' END"영업부"
      ,CASE WHEN BUSEO LIKE ('총무부') THEN'당첨' END"총무부"
FROM TBL_INSA
WHERE CITY = '서울'
)T;
--==>>2	9	3


--42. 서울 사람의 남자와 여자의 기본급합 조회.


SELECT CASE WHEN T.성별 IS NULL THEN '합계' ELSE T.성별 END "성별"
        ,SUM(T.기본급합)
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1) THEN'남자' ELSE '여자' END "성별"
        , BASICPAY+SUDANG"기본급합"
FROM TBL_INSA
WHERE CITY = '서울' AND SUBSTR(SSN,8,1) IN (1,2)
)T
GROUP BY ROLLUP(T.성별);
/*
남자	19397000
여자	14415400
합계	33812400
*/





--43. 남자와 여자의 기본급 평균값 조회. AVG(), DECODE() 함수 이용.

SELECT CASE WHEN T.성별 IS NULL THEN '합계' ELSE T.성별 END "성별"
        ,ROUND(AVG(T.기본급합))"평균값"
FROM 
(
SELECT DECODE((SUBSTR(SSN,8,1)),'1','남자','2','여자')"성별"
        ,BASICPAY+SUDANG"기본급합"
FROM TBL_INSA
WHERE CITY = '서울' AND SUBSTR(SSN,8,1) IN (1,2)
)T
GROUP BY ROLLUP(T.성별);
/*
남자	2155222
여자	1310491
합계	1690620
*/

SELECT *
FROM TBL_INSA;


--44. 개발부의 남자, 여자 기본급 평균값 조회.


SELECT CASE WHEN T.성별 IS NULL THEN '합계' ELSE T.성별 END "성별"
        ,ROUND(AVG(T.기본급합))
FROM 
(
SELECT DECODE((SUBSTR(SSN,8,1)),'1','남자','2','여자')"성별"
        ,BASICPAY+SUDANG"기본급합"
FROM TBL_INSA
WHERE BUSEO LIKE ('개발부')
)T
GROUP BY ROLLUP(T.성별);
/*
남자	1535667
여자	1523625
합계	1528786
*/


--45. 부서별 남자와 여자 인원수 구하기


SELECT T.부서,COUNT(T.남자)"남자",COUNT(T.여자)"여자"
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3)THEN'남자' END"남자"
       ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4)THEN'여자' END"여자"
       ,BUSEO"부서"
FROM TBL_INSA
)T
GROUP BY T.부서;

/*
총무부	4	3
개발부	6	8
영업부	8	8
기획부	4	3
인사부	4	0
자재부	2	4
홍보부	3	3
*/



--46. 지역별 남자와 여자 인원수 구하기

SELECT T.지역,COUNT(T.남자)"남자",COUNT(T.여자)"여자"
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3)THEN'남자' END"남자"
       ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4)THEN'여자' END"여자"
       ,CITY"지역"
FROM TBL_INSA
)T
GROUP BY T.지역;

SELECT *
FROM TBL_INSA;

/*
서울	9	11
충남	1	0
인천	4	5
부산	1	2
제주	2	0
전북	4	1
강원	2	0
경북	1	0
전남	1	2
경기	5	8
경남	1	0
*/


--47. 입사년도별 남자와 여자 인원수 구하기

SELECT T.입사년도,COUNT(T.남자)"남자",COUNT(T.여자)"여자"
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3)THEN'남자' END"남자"
       ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4)THEN'여자' END"여자"
       ,TO_CHAR(IBSADATE,'YYYY')"입사년도"
FROM TBL_INSA
)T
GROUP BY T.입사년도;

/*
2000	6	6
2003	3	7
1997	1	0
2001	7	2
2005	1	0
1995	1	0
1999	5	5
2004	4	1
2002	0	5
1998	3	3
*/

--48. 영업부, 총무부 인원만을 가지고 입사년도별 남자와 여자 인원수 구하기

SELECT T.입사년도,COUNT(T.남자)"남자",COUNT(T.여자)"여자"
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3)THEN'남자' END"남자"
       ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4)THEN'여자' END"여자"
       ,TO_CHAR(IBSADATE,'YYYY')"입사년도"
FROM TBL_INSA
WHERE BUSEO IN ('영업부','총무부')
)T
GROUP BY T.입사년도;
/*
2000	4	3
1997	1	0
2003	1	2
2001	1	0
1995	1	0
1999	1	3
2004	3	1
2002	0	1
1998	0	1
*/


--49. 서울 사람중 부서별 남자와 여자인원수, 남자와 여자 급여합 조회.

SELECT T.부서,COUNT(T.남자)"남자",COUNT(T.여자)"여자"
      ,SUM(T.남자),SUM(T.여자)
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3)THEN BASICPAY+SUDANG END"남자"
       ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4)THEN BASICPAY+SUDANG END"여자"
       ,BUSEO"부서"
       ,BASICPAY+SUDANG"급여합"
FROM TBL_INSA
WHERE CITY = '서울'
)T
GROUP BY T.부서;

SELECT *
FROM TBL_INSA;

--==>> 
/*
총무부	2	1	4090000	1044000
영업부	4	5	7422000	7062000
개발부	0	2		1994000
기획부	2	1	5420000	2070000
인사부	1	0	2465000	
자재부	0	1		1150400
홍보부	0	1		1095000
*/


--50. 부서별 인원수 출력. 인원수가 10 이상인 경우만.


SELECT T.부서,COUNT(*)
FROM
(
SELECT BUSEO"부서"
FROM TBL_INSA
)T
GROUP BY T.부서
HAVING COUNT(*) > 10;
/*
개발부	14
영업부	16
*/




SELECT *
FROM TBL_INSA;


--51. 부서별 남,여 인원수 출력. 여자인원수가 5명 이상인 부서만 조회.


SELECT T.부서,COUNT(T.남자)"남자",COUNT(T.여자)"여자"
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3)THEN '남자' END"남자"
       ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4)THEN '여자' END"여자"
       ,BUSEO"부서"
FROM TBL_INSA
)T
GROUP BY T.부서
HAVING COUNT(T.여자) >= 5;
/*
개발부	6	8
영업부	8	8
*/




--52. 이름, 성별, 나이 조회
--    성별: 주민번호 활용 1,3 → 남자, 2,4 → 여자 (DECODE() 사용)
--    나이: 주민번호 활용
    
    
    SELECT NAME"이름"
            ,DECODE(SUBSTR(SSN,8,1),'1','남자','2','여자','3','남자','4','여자')"성별"
            ,CASE WHEN SUBSTR(SSN,8,1) IN (1,2)THEN 2024 - (SUBSTR(SSN,1,2) + 1899) END "나이"
    FROM TBL_INSA;
    /*
    홍길동	남자	48
이순신	남자	45
이순애	여자	48
김정훈	남자	46
한석봉	남자	44
이기자	여자	47
장인철	남자	47
김영년	여자	43
나윤균	남자	44
김종서	남자	50
유관순	여자	45
정한국	남자	49
조미숙	여자	46
황진이	여자	44
이현숙	여자	45
이상헌	남자	47
엄용수	남자	43
이성길	남자	45
박문수	남자	47
유영희	여자	45
홍길남	남자	45
이영숙	여자	45
김인수	남자	52
김말자	여자	42
우재옥	남자	45
김숙남	여자	44
김영길	남자	45
이남신	남자	44
김말숙	여자	45
정정해	여자	46
지재환	남자	48
심심해	여자	44
김미나	여자	47
이정석	남자	43
정영희	여자	42
이재영	여자	55
최석규	남자	48
손인수	여자	46
고순정	여자	45
박세열	남자	46
문길수	남자	53
채정희	여자	44
양미옥	여자	42
지수환	남자	43
홍원신	남자	56
허경운	남자	49
산마루	남자	47
이기상	남자	46
이미성	여자	42
이미인	여자	44
권영미	여자	46
권옥경	여자	43
김싱식	남자	45
정상호	남자	44
정한나	여자	43
전용재	남자	45
이미경	여자	47
김신제	남자	45
임수봉	여자	44
김신애	여자	44
    */

--53. 서울 사람 중에서 기본급이 200만원 이상인 사람 조회. 
--    ( 이름, 기본급 )


SELECT NAME,BASICPAY
FROM TBL_INSA
WHERE CITY = '서울' AND BASICPAY > 2000000;
/*
홍길동	2610000
박문수	2300000
김인수	2500000
김영길	2340000
지재환	2450000
산마루	2100000
권영미	2260000
*/



--54. 입사월별 인원수 구하기. (월, 인원수)   COUNT, GROUP BY, TO_CHAR 사용
    출력형태 
     월  인원수
    1월    10명
    2월    25명
    
    
    
    SELECT SUBSTR(TO_CHAR(SSN),3,2)"월",COUNT(*)"인원수"
    FROM TBL_INSA
    GROUP BY SUBSTR(TO_CHAR(SSN),3,2);
    
    /*
    09	5
08	3
04	3
07	6
12	4
11	4
01	4
10	9
03	5
05	11
02	3
06	3
    */
    
    
    


55. 이름, 생년월일, 기본급, 수당을 조회.
    생년월일은 주민번호 기준 (2000-10-10 형식으로 출력)
    기본급은 \1,000,000 형식으로 출력
    
    
    
    SELECT NAME,BASICPAY,SUDANG
               ,CASE WHEN SUBSTR(SSN,8,1) IN (1,2)THEN (SUBSTR(SSN,1,2) + 1899) || '-'|| SUBSTR(SSN,3,2) || '-' || SUBSTR(SSN,4,2)
               END "생년월일"
               ,INSTR(BASICPAY,'0',1,3)
               ,BASICPAY
    FROM TBL_INSA;
    
    

--56. 이름, 출신도, 기본급을 조회하되 출신도 내림차순 출력(1차 정렬 기준).
    출신도가 같으면 기본급 오름차순 출력(2차 정렬 기준).
    
    
    
    SELECT NAME,CITY,BASICPAY
    FROM TBL_INSA
    ORDER BY 2 DESC,3 ASC;
    /*
문길수	충남	2300000
이남신	제주	892000
장인철	제주	1250000
이성길	전북	880000
심심해	전북	880000
김싱식	전북	960000
홍원신	전북	960000
김정훈	전북	1954200
유영희	전남	880000
이영숙	전남	1960000
이기상	전남	2050000
엄용수	인천	950000
정영희	인천	1050000
황진이	인천	1100000
이미성	인천	1300000
전용재	인천	1950000
김신제	인천	1950000
이기자	인천	2265000
최석규	인천	2350000
이순애	인천	2550000
임수봉	서울	890000
김신애	서울	900000
김말숙	서울	920000
김영년	서울	950000
이재영	서울	960400
정한나	서울	1000000
김미나	서울	1020000
유관순	서울	1020000
지수환	서울	1060000
양미옥	서울	1100000
우재옥	서울	1100000
한석봉	서울	1420000
김말자	서울	1900000
산마루	서울	2100000
권영미	서울	2260000
박문수	서울	2300000
김영길	서울	2340000
지재환	서울	2450000
김인수	서울	2500000
홍길동	서울	2610000
손인수	부산	2000000
정정해	부산	2304000
김종서	부산	2540000
박세열	경북	2100000
허경운	경남	2650000
나윤균	경기	840000
홍길남	경기	875000
채정희	경기	1020000
권옥경	경기	1020000
김숙남	경기	1050000
이현숙	경기	1050000
이정석	경기	1100000
이순신	경기	1320000
조미숙	경기	1601000
이미인	경기	1950000
고순정	경기	2010000
이상헌	경기	2350000
이미경	경기	2520000
정한국	강원	880000
정상호	강원	980000
    */
    

--57. 전화번호가 NULL이 아닌것만 조회. (이름, 전화번호)


SELECT NAME,TEL
FROM TBL_INSA
WHERE TEL IS NOT NULL;
/*
홍길동	011-2356-4528
이순신	010-4758-6532
이순애	010-4231-1236
김정훈	019-5236-4221
한석봉	018-5211-3542
이기자	010-3214-5357
장인철	011-2345-2525
김영년	016-2222-4444
나윤균	019-1111-2222
김종서	011-3214-5555
유관순	010-8888-4422
정한국	018-2222-4242
조미숙	019-6666-4444
황진이	010-3214-5467
이현숙	016-2548-3365
이상헌	010-4526-1234
엄용수	010-3254-2542
이성길	018-1333-3333
박문수	017-4747-4848
유영희	011-9595-8585
홍길남	011-9999-7575
이영숙	017-5214-5282
김말자	011-5248-7789
우재옥	010-4563-2587
김숙남	010-2112-5225
김영길	019-8523-1478
이남신	016-1818-4848
김말숙	016-3535-3636
정정해	019-6564-6752
지재환	019-5552-7511
심심해	016-8888-7474
김미나	011-2444-4444
이정석	011-3697-7412
이재영	011-9999-9999
최석규	011-7777-7777
손인수	010-6542-7412
고순정	010-2587-7895
박세열	016-4444-7777
문길수	016-4444-5555
채정희	011-5125-5511
양미옥	016-8548-6547
지수환	011-5555-7548
홍원신	011-7777-7777
허경운	017-3333-3333
산마루	018-0505-0505
이미성	010-6654-8854
이미인	011-8585-5252
권영미	011-5555-7548
권옥경	010-3644-5577
김싱식	011-7585-7474
정상호	016-1919-4242
정한나	016-2424-4242
전용재	010-7549-8654
이미경	016-6542-7546
김신제	010-2415-5444
임수봉	011-4151-4154
김신애	011-4151-4444
*/







--58. 근무년수가 10년 이상인 사람 조회. (이름, 입사일)




SELECT NAME,IBSADATE
FROM TBL_INSA
WHERE TO_CHAR(IBSADATE,'YYYY') - TO_CHAR(SYSDATE,'YYYY') < 10;

/*
홍길동	1998-10-11
이순신	2000-11-29
이순애	1999-02-25
김정훈	2000-10-01
한석봉	2004-08-13
이기자	2002-02-11
장인철	1998-03-16
김영년	2002-04-30
나윤균	2003-10-10
김종서	1997-08-08
유관순	2000-07-07
정한국	1999-10-16
조미숙	1998-06-07
황진이	2002-02-15
이현숙	1999-07-26
이상헌	2001-11-29
엄용수	2000-08-28
이성길	2004-08-08
박문수	1999-12-10
유영희	2003-10-10
홍길남	2001-09-07
이영숙	2003-02-25
김인수	1995-02-23
김말자	1999-08-28
우재옥	2000-10-01
김숙남	2002-08-28
김영길	2000-10-18
이남신	2001-09-07
김말숙	2000-09-08
정정해	1999-10-17
지재환	2001-01-21
심심해	2000-05-05
김미나	1998-06-07
이정석	2005-09-26
정영희	2002-05-16
이재영	2003-08-10
최석규	1998-10-15
손인수	1999-11-15
고순정	2003-12-28
박세열	2000-09-10
문길수	2001-12-10
채정희	2003-10-17
양미옥	2003-09-24
지수환	2004-01-21
홍원신	2003-03-16
허경운	1999-05-04
산마루	2001-07-15
이기상	2001-06-07
이미성	2000-04-07
이미인	2003-06-07
권영미	2000-06-04
권옥경	2000-10-10
김싱식	1999-12-12
정상호	1999-10-16
정한나	2004-06-07
전용재	2004-08-13
이미경	1998-02-11
김신제	2003-08-08
임수봉	2001-10-10
김신애	2001-10-10
*/






--59. 주민번호를 기준으로 75~82년생 조회. (이름, 주민번호, 출신도).
--    SUBSTR() 함수, BEWTEEN AND 구문, TO_NUMBER() 함수 이용.
    
    
    SELECT NAME,SSN,CITY
    FROM TBL_INSA
    WHERE TO_NUMBER(SUBSTR(SSN,1,2)) BETWEEN 75 AND 82;
    /*
    홍길동	771212-1022432	서울
이순신	801007-1544236	경기
이순애	770922-2312547	인천
김정훈	790304-1788896	전북
한석봉	811112-1566789	서울
이기자	780505-2978541	인천
장인철	780506-1625148	제주
김영년	821011-2362514	서울
나윤균	810810-1552147	경기
김종서	751010-1122233	부산
유관순	801010-2987897	서울
정한국	760909-1333333	강원
조미숙	790102-2777777	경기
황진이	810707-2574812	인천
이현숙	800606-2954687	경기
이상헌	781010-1666678	경기
엄용수	820507-1452365	인천
이성길	801028-1849534	전북
박문수	780710-1985632	서울
유영희	800304-2741258	전남
홍길남	801010-1111111	경기
이영숙	800501-2312456	전남
우재옥	801103-1654442	서울
김숙남	810907-2015457	경기
김영길	801216-1898752	서울
이남신	810101-1010101	제주
김말숙	800301-2020202	서울
정정해	790210-2101010	부산
지재환	771115-1687988	서울
심심해	810206-2222222	전북
김미나	780505-2999999	서울
이정석	820505-1325468	경기
최석규	770129-1456987	인천
손인수	791009-2321456	부산
고순정	800504-2000032	경기
박세열	790509-1635214	경북
채정희	810709-2000054	경기
지수환	820305-1475286	서울
허경운	760105-1458752	경남
산마루	780505-1234567	서울
이기상	790604-1415141	전남
이미인	810403-2828287	경기
권영미	790303-2155554	서울
권옥경	820406-2000456	경기
김싱식	800715-1313131	전북
정상호	810705-1212141	강원
정한나	820506-2425153	서울
전용재	800605-1456987	인천
이미경	780406-2003214	경기
김신제	800709-1321456	인천
임수봉	810809-2121244	서울
김신애	810809-2111111	서울
    */
    
    
    
    

--60. 근무년수가 5~10년인 사람 조회. (이름, 입사일)


    SELECT NAME,IBSADATE
    FROM TBL_INSA
    WHERE TO_CHAR(SYSDATE,'YYYY') - TO_CHAR(IBSADATE,'YYYY') <= 10
          AND TO_CHAR(SYSDATE,'YYYY') - TO_CHAR(IBSADATE,'YYYY') <= 5;
    --==>>조회결과 없음




--61. 김씨, 이씨, 박씨만 조회 (이름, 부서). SUBSTR() 함수 이용.



SELECT NAME,BUSEO
FROM TBL_INSA
WHERE SUBSTR(NAME,1,1) IN ('김','이','박');
/*
이순신	총무부
이순애	개발부
김정훈	영업부
이기자	개발부
김영년	홍보부
김종서	영업부
이현숙	총무부
이상헌	개발부
이성길	개발부
박문수	인사부
이영숙	기획부
김인수	영업부
김말자	기획부
김숙남	영업부
김영길	총무부
이남신	인사부
김말숙	총무부
김미나	영업부
이정석	기획부
이재영	자재부
박세열	인사부
이기상	개발부
이미성	개발부
이미인	홍보부
김싱식	자재부
이미경	자재부
김신제	기획부
김신애	개발부
*/







--62. 입사일을 "년-월-일 요일" 형식으로 남자만 조회 (이름, 주민번호, 입사일)


SELECT NAME,SSN,TO_CHAR(IBSADATE,'YYYY-MM-DD') || ' ' ||  TO_CHAR(IBSADATE,'DAY')"입사일"
FROM TBL_INSA
WHERE SUBSTR(SSN,8,1) IN (1,3);

/*
홍길동	771212-1022432	1998-10-11 일요일
이순신	801007-1544236	2000-11-29 수요일
김정훈	790304-1788896	2000-10-01 일요일
한석봉	811112-1566789	2004-08-13 금요일
장인철	780506-1625148	1998-03-16 월요일
나윤균	810810-1552147	2003-10-10 금요일
김종서	751010-1122233	1997-08-08 금요일
정한국	760909-1333333	1999-10-16 토요일
이상헌	781010-1666678	2001-11-29 목요일
엄용수	820507-1452365	2000-08-28 월요일
이성길	801028-1849534	2004-08-08 일요일
박문수	780710-1985632	1999-12-10 금요일
홍길남	801010-1111111	2001-09-07 금요일
김인수	731211-1214576	1995-02-23 목요일
우재옥	801103-1654442	2000-10-01 일요일
김영길	801216-1898752	2000-10-18 수요일
이남신	810101-1010101	2001-09-07 금요일
지재환	771115-1687988	2001-01-21 일요일
이정석	820505-1325468	2005-09-26 월요일
최석규	770129-1456987	1998-10-15 목요일
박세열	790509-1635214	2000-09-10 일요일
문길수	721217-1951357	2001-12-10 월요일
지수환	820305-1475286	2004-01-21 수요일
홍원신	690906-1985214	2003-03-16 일요일
허경운	760105-1458752	1999-05-04 화요일
산마루	780505-1234567	2001-07-15 일요일
이기상	790604-1415141	2001-06-07 목요일
김싱식	800715-1313131	1999-12-12 일요일
정상호	810705-1212141	1999-10-16 토요일
전용재	800605-1456987	2004-08-13 금요일
김신제	800709-1321456	2003-08-08 금요일
*/






--63. 부서별 직위별 급여합 구하기. (부서, 직위, 급여합)


SELECT T.부서,T.직위,SUM(T.급여합)"급여합"
FROM
(
SELECT BUSEO"부서",JIKWI"직위",BASICPAY+SUDANG"급여합"
FROM TBL_INSA
)T
GROUP BY T.부서,T.직위;
/*
총무부	사원	5298000
개발부	대리	3556000
영업부	부장	5340000
영업부	사원	9550000
총무부	과장	4938000
기획부	부장	5420000
인사부	사원	2062400
홍보부	대리	3757000
자재부	사원	4226400
기획부	사원	2385000
인사부	대리	2230000
홍보부	사원	3183000
인사부	과장	2465000
개발부	부장	2710000
영업부	대리	10806200
개발부	사원	10222000
홍보부	과장	2537000
자재부	과장	2450000
총무부	부장	2800000
기획부	대리	6340000
개발부	과장	4915000
영업부	과장	2364000
자재부	부장	2680000
*/



--64. 부서별 직위별 인원수, 급여합, 급여평균 구하기. (부서, 직위, 급여합)



SELECT T.부서,T.직위,COUNT(*),SUM(T.급여합)"급여합",ROUND(AVG(T.급여합))"급여평균"
FROM
(
SELECT BUSEO"부서",JIKWI"직위",BASICPAY+SUDANG"급여합"
FROM TBL_INSA
)T
GROUP BY T.부서,T.직위;

/*
총무부	사원	4	5298000	1324500
개발부	대리	2	3556000	1778000
영업부	부장	2	5340000	2670000
영업부	사원	8	9550000	1193750
총무부	과장	2	4938000	2469000
기획부	부장	2	5420000	2710000
인사부	사원	2	2062400	1031200
홍보부	대리	2	3757000	1878500
자재부	사원	4	4226400	1056600
기획부	사원	2	2385000	1192500
인사부	대리	1	2230000	2230000
홍보부	사원	3	3183000	1061000
인사부	과장	1	2465000	2465000
개발부	부장	1	2710000	2710000
영업부	대리	5	10806200	2161240
개발부	사원	9	10222000	1135778
홍보부	과장	1	2537000	2537000
자재부	과장	1	2450000	2450000
총무부	부장	1	2800000	2800000
기획부	대리	3	6340000	2113333
개발부	과장	2	4915000	2457500
영업부	과장	1	2364000	2364000
자재부	부장	1	2680000	2680000
*/







--65. 부서별 직위별 인원수를 구하되 인원수가 5명 이상인 경우만 조회.



SELECT T.부서,T.직위,COUNT(*)"인원수"
FROM
(
SELECT BUSEO"부서",JIKWI"직위",BASICPAY+SUDANG"급여합"
FROM TBL_INSA
)T
GROUP BY T.부서,T.직위
HAVING COUNT(*) >= 5;

/*
영업부	사원	8
영업부	대리	5
개발부	사원	9
*/










--66. 2000년에 입사한 여사원 조회. (이름, 주민번호, 입사일)




SELECT NAME,SSN,IBSADATE
FROM TBL_INSA
WHERE TO_CHAR(IBSADATE,'YYYY') IN ('2000') AND SUBSTR(SSN,8,1) IN (2,4);
/*
유관순	801010-2987897	2000-07-07
김말숙	800301-2020202	2000-09-08
심심해	810206-2222222	2000-05-05
이미성	830908-2456548	2000-04-07
권영미	790303-2155554	2000-06-04
권옥경	820406-2000456	2000-10-10
*/



--67. 성씨가 한 글자(김, 이, 박 등)라는 가정하에 성씨별 인원수 조회 (성씨, 인원수)

SELECT T.성씨별||'씨'"성씨",COUNT(*)"인원수"
FROM
(
SELECT SUBSTR(NAME,1,1)"성씨별"
FROM TBL_INSA
)T
GROUP BY T.성씨별;

/*
이씨	14
김씨	12
정씨	5
우씨	1
최씨	1
손씨	1
채씨	1
장씨	1
임씨	1
지씨	2
고씨	1
전씨	1
조씨	1
문씨	1
산씨	1
황씨	1
박씨	2
심씨	1
허씨	1
홍씨	3
한씨	1
나씨	1
유씨	2
엄씨	1
양씨	1
권씨	2
*/


--68. 출신도(CITY)별 성별 인원수 조회.

SELECT T.출신도,COUNT(T.남자)"남자",COUNT(T.여자)"여자"
FROM
(
SELECT CASE WHEN SUBSTR(SSN,8,1) IN (1,3) THEN '남자' END"남자"
      ,CASE WHEN SUBSTR(SSN,8,1) IN (2,4) THEN '여자' END"여자"
      ,CITY"출신도"
FROM TBL_INSA
)T
GROUP BY T.출신도;
/*
서울	9	11
충남	1	0
인천	4	5
부산	1	2
제주	2	0
전북	4	1
강원	2	0
경북	1	0
전남	1	2
경기	5	8
경남	1	0
*/



--69. 부서별 남자인원수가 5명 이상인 부서와 남자인원수 조회.

SELECT T.부서,T.남자
FROM
(
SELECT BUSEO"부서",COUNT(CASE WHEN SUBSTR(SSN,8,1) IN (1,3) THEN '남자' END)"남자"
FROM TBL_INSA
GROUP BY BUSEO
)T
WHERE T.남자 > 5;
/*
개발부	6
영업부	8
*/





--70. 입사년도별 인원수 조회.

SELECT T.입사년도,COUNT(*)"인원수"
FROM 
(
SELECT SUBSTR(IBSADATE,1,4)"입사년도"
FROM TBL_INSA
)T
GROUP BY T.입사년도;
/*
2000	12
2003	10
1997	1
2001	9
2005	1
1995	1
1999	10
2004	5
2002	5
1998	6
*/






--71. 전체인원수, 2000년, 1999년, 1998년도에 입사한 인원을 다음의 형식으로 조회.
    출력형태 ---------------    
    전체 2000 1999 1998;
      60    x    x    x;
      

SELECT COUNT(T.전체)"전체",T."2000년",T."1999년",T."1998년"
FROM
(
SELECT IBSADATE"전체", (SELECT COUNT(*)
                        FROM TBL_INSA
                        WHERE SUBSTR(IBSADATE,1,4) IN (2000)) "2000년" 
                     , (SELECT COUNT(*)
                        FROM TBL_INSA
                        WHERE SUBSTR(IBSADATE,1,4) IN (1999)) "1999년"
                    ,  (SELECT COUNT(*)
                        FROM TBL_INSA
                        WHERE SUBSTR(IBSADATE,1,4) IN (1998)) "1998년"
FROM TBL_INSA
)T
GROUP BY T."2000년",T."1999년",T."1998년";

/*
61	12	10	6
*/




      

--72. 아래 형식으로 지역별 인원수 조회.
    출력형태 -----------------
    전체 서울  인천  경기
      60    x     x     x
      
      

SELECT COUNT(T.전체)"전체",T.서울,T.인천,T.경기
FROM
(
SELECT IBSADATE"전체", (SELECT COUNT(*)
                        FROM TBL_INSA
                        WHERE CITY LIKE('서울')) "서울" 
                     , (SELECT COUNT(*)
                        FROM TBL_INSA
                        WHERE CITY LIKE('인천')) "인천"
                    ,  (SELECT COUNT(*)
                        FROM TBL_INSA
                        WHERE CITY LIKE('경기')) "경기"
FROM TBL_INSA
)T
GROUP BY T.서울,T.인천,T.경기;
--==>> 61	21	9	13
      
      
      
      
      
    

--73. 기본급(BASICPAY)이 평균 이하인 사원 조회. (이름, 기본급). AVG() 함수. 서브쿼리.



SELECT NAME"이름",BASICPAY"기본급"
FROM TBL_INSA
WHERE BASICPAY > (SELECT AVG(BASICPAY)
                  FROM TBL_INSA);
/*
홍길동	2610000
이순애	2550000
김정훈	1954200
이기자	2265000
김종서	2540000
이상헌	2350000
박문수	2300000
이영숙	1960000
김인수	2500000
김말자	1900000
김영길	2340000
정정해	2304000
지재환	2450000
최석규	2350000
손인수	2000000
고순정	2010000
박세열	2100000
문길수	2300000
허경운	2650000
산마루	2100000
이기상	2050000
이미인	1950000
권영미	2260000
전용재	1950000
이미경	2520000
김신제	1950000
안예지	5000000
*/








74. 기본급 상위 10%만 조회. (이름, 기본급)


SELECT NAME"이름",BASICPAY"기본급"
FROM TBL_INSA
WHERE;




75. 기본급 순위가 5순위까지만 조회. (모든 정보)




SELECT NUM,NAME,SSN,IBSADATE,CITY,TEL,BUSEO,JIKWI,BASICPAY,SUDANG
        , RANK() OVER(ORDER BY BASICPAY DESC)
FROM TBL_INSA;




76. 입사일이 빠른 순서로 5순위까지만 조회. (모든 정보)

77. 평균 급여보다 많은 급여를 받는 직원 정보 조회. (모든 정보)

78. '이순애' 직원의 급여보다 더 많은 급여를 받는 직원 조회. (모든 정보)
    단, 이순애 직원의 급여가 변하더라도 작성된 쿼리문은 기능 수행이 가능하도록 조회.

79. 총무부의 평균 급여보다 많은 급여를 받는 직원들의 이름, 부서명 조회.

80. 총무부 직원들의 평균 수당보다 더 많은 수당을 받는 직원 정보 조회.

81. 직원 전체 평균 급여보다 많은 급여를 받는 직원의 수 조회.

82. '홍길동' 직원과 같은 부서의 직원 정보 조회.
    단, 홍길동 직원의 부서가 바뀌더라도 작성된 쿼리문은 기능 수행이 가능하도록 조회.

83. '김신애' 직원과 같은 부서, 직위를 가진 직원 정보 조회.
    단, 김신애 직원의 부서 및 직위가 바뀌더라도 작성된 쿼리문은 기능 수행이 가능하도록 조회.

84. 부서별 기본급이 가장 높은 사람 조회. (이름, 부서, 기본급)
    단, 사원들의 기본급이 변경되더라도 작성된 쿼리문은 기능 수행이 가능하도록 조회.

85. 남, 여별 기본급 순위 조회.

86. 지역(CITY)별로 급여(기본급+수당) 1순위 직원만 조회.

87. 부서별 인원수가 가장 많은 부서 및 인원수 조회.

88. 지역(CITY)별 인원수가 가장 많은 지역 및 인원수 조회.

89. 지역(CITY)별 평균 급여(BASICPAY + SUDANG)가
    가장 높은 지역 및 평균급여 조회.

90. 여자 인원수가 가장 많은 부서 및 인원수 조회.

91. 지역별 인원수 순위 조회.

92. 지역별 인원수 순위 조회하되 5순위까지만 출력.

93. 이름, 부서, 출신도, 기본급, 수당, 기본급+수당, 세금, 실수령액 조회
    단, 세금: 총급여가 250만원 이상이면 2%, 200만원 이상이면 1%, 나머지 0.
    실수령액: 총급여-세금

94. 부서별 평균 급여를 조회하되, A, B, C 등급으로 나눠서 출력.
    200만원 초과 - A등급
    150~200만원  - B등급
    150만원 미만 - C등급

95. 기본급+수당이 가장 많은 사람의 이름, 기본급+수당 조회.
    MAX() 함수, 하위 쿼리 이용.


----------------------------------------------------------------------------
















